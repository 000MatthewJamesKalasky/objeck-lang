use Collection;
use System.IO.Filesystem;
use Data.XML;

#~
Blah code generators are ugly, rather parsing XML or C source
~#
class GtkTestRunner {
	@debug : Bool;
	@filename : String;
	@basic_type_map : Hash<String, String>;
	@consts_set : Set<String>;
	@namespace : String;
	@objk_out : FileWriter;
	@cxx_out : FileWriter;

	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			GtkTestRunner->New(args[0])->Parse();
		};
	}

	New(filename : String) {
		@filename := filename;

		@basic_type_map := Hash->New()<String, String>;
		@basic_type_map->Insert("gpointer", "Int");
		@basic_type_map->Insert("gboolean", "Bool");
		@basic_type_map->Insert("gshort", "Int");
		@basic_type_map->Insert("gint", "Int");
		@basic_type_map->Insert("gint8", "Int");
		@basic_type_map->Insert("gint16", "Int");
		@basic_type_map->Insert("gint32", "Int");
		@basic_type_map->Insert("guint", "Int");
		@basic_type_map->Insert("guint8", "Int");
		@basic_type_map->Insert("guint16", "Int");
		@basic_type_map->Insert("guint32", "Int");
		@basic_type_map->Insert("glong", "Int");
		@basic_type_map->Insert("gulong", "Int");
		@basic_type_map->Insert("gfloat", "Float");
		@basic_type_map->Insert("gdouble", "Float");
		@basic_type_map->Insert("utf8", "String");
		@basic_type_map->Insert("gchar*", "String");
		@basic_type_map->Insert("gchar**", "String[]");
		@basic_type_map->Insert("filename", "String");
		@basic_type_map->Insert("void", "Nil");
		@basic_type_map->Insert("guint8*", "Byte[]");

		@consts_set := Set->New()<String>;

		@objk_out := FileWriter->New("gens/objk_code.txt");
		@cxx_out := FileWriter->New("gens/cxx_code.txt");
	}

	method : Parse() ~ Nil {
		# read file
		data := FileReader->ReadFile(@filename);
		data_size := data->Size()->ToCommaString();
		if(#~@debug~#true) {
			"[file: name='{$@filename}', size={$data_size} byte(s)]\n###"->PrintLine();
		};

		# parse xml
		timer := System.Time.Timer->New();
		timer->Start();

#		TODO: store in look up table and handle as ints
#		classes_xml := parser->FindElements("/repository/namespace/bitfield")<XmlElement>;
#		classes_xml := parser->FindElements("/repository/namespace/record")<XmlElement>;

#		classes_xml := parser->FindElements("/repository/namespace/enumeration")<XmlElement>;

		parser := XmlParser->New(data);
		if(parser->Parse()) {
			WriteObjeckHeader();
			WriteCxxHeader();

			@namespace := parser->GetRoot()->GetFirstChild("namespace")->GetAttribute("name")->GetValue();

			enums_xml := parser->FindElements("/repository/namespace/enumeration")<XmlElement>;
			if(enums_xml <> Nil) {
				ParseEnums(enums_xml);
			};

			classes_xml := parser->FindElements("/repository/namespace/class")<XmlElement>;
			if(classes_xml <> Nil) {
				ParseClasses(classes_xml);
			};

			@objk_out->WriteString("}\n");
			@cxx_out->WriteString("}\n");
		};

		@objk_out->Close();
		@cxx_out->Close();

		timer->End();

		String->SetFloatPrecision(3);
		tick_secs := timer->GetElapsedTime();
		"###\ntime={$tick_secs} sec(s)"->PrintLine();
	}

	method : ParseEnums(enums_xml : Vector<XmlElement>) ~ Nil {
		objk_buffer := "";

		each(enum_xml := enums_xml) {
			enum_name := enum_xml->GetAttribute("name")->GetValue();
			@consts_set->Insert(enum_name);

			objk_buffer += "  consts {$enum_name} {\n";

			members_xml := enum_xml->GetChildren("member")<XmlElement>;
			each(member_xml := members_xml) {
				value_name := member_xml->GetAttribute("value")->GetValue();
				identifier_name := member_xml->GetAttribute("identifier")->GetValue();

				objk_buffer += "    {$identifier_name} := {$value_name},\n";
			};
			objk_buffer->Pop();
			objk_buffer->Pop();

			objk_buffer += "\n  }\n\n";
		};

		@objk_out->WriteString(objk_buffer);
	}

	method : ParseClasses(classes_xml : Vector<XmlElement>) ~ Nil {
		each(i : classes_xml) {
			cxx_buffer := "";
			objk_buffer := "";

			class_xml := classes_xml->Get(i);

			class_name := class_xml->GetAttribute("name")->GetValue();
			if(class_name->Equals("Window")) {
				@debug := true;

				WriteClass(class_name, class_xml, objk_buffer, cxx_buffer);

				@debug := false;
			};
			
			if(i + 1 = classes_xml->Size()) {
				objk_buffer->Pop();
				cxx_buffer->Pop();
			};
			@objk_out->WriteString(objk_buffer);
			@cxx_out->WriteString(cxx_buffer);
		};

		"\n==============================================================="->PrintLine();
	}

	method : WriteClass(class_name : String, class_xml : XmlElement, objk_buffer : String, cxx_buffer : String) ~ String {
		if(@debug) {
			"\n[class/record: name='{$class_name}']"->PrintLine();
		};

		# start class
		objk_buffer += "  class {$class_name} {\n";

		ref_name := "gobject"; #class_name->ToLower();
		objk_buffer += "    @{$ref_name} : Int;\n\n";

		# parse parameters
		fields_xml := class_xml->GetChildren("field")<XmlElement>;
		getters_setters := ParseParameters(fields_xml, objk_buffer, cxx_buffer);

		# write constructor
		objk_buffer += "    New({$ref_name} : Int) {\n";
		objk_buffer += "      @{$ref_name} := {$ref_name};\n";
		objk_buffer += "    }\n\n";

		# write getters and setters
		WriteGettersSetters(ref_name, getters_setters, objk_buffer, cxx_buffer);

		# add space
		objk_buffer += '\n';

		# write methods
		methods_xml := class_xml->GetChildren("method")<XmlElement>;
		WriteMethods(ref_name, methods_xml, objk_buffer, cxx_buffer, false);

		# end class
		objk_buffer += "  }\n\n";

		return class_name;
	}

	method : WriteGettersSetters(ref_name : String, getters_setters : Vector<Pair<String, String>>, objk_buffer : String, cxx_buffer : String) ~ Nil {
		# write getters and setters
		each(getter_setter := getters_setters) {
			name := getter_setter->GetFirst();
			method_case_name := CamelCaseName(name->Copy());
			type := getter_setter->GetSecond();

			#
			# getter
			#
			objk_buffer += "    method : public : Get{$method_case_name}() ~ {$type} {\n";
			objk_buffer += "      array_args := Base->New[2];\n\n";
			
			# set params
			if(type->Equals("Byte") | type->Equals("Char") | type->Equals("Int") | type->Equals("Bool")) {
				objk_buffer += "      array_args[0] := IntRef->New();\n";
			}
			else if(type->Equals("Float")) {
				objk_buffer += "      array_args[0] := FloatRef->New();\n";
			}
			else {
				objk_buffer += "      array_args[0] := Nil;\n";
			};

			objk_buffer += "      array_args[1] := IntRef->New(@{$ref_name});\n";

			c_call_name := "{$ref_name}_get_{$method_case_name}"->ToLower();
			objk_buffer += "\n      Proxy->GetDllProxy()->CallFunction(\"{$c_call_name}\", array_args);\n";

			cxx_buffer += "  #ifdef _WIN32\n";
			cxx_buffer += "    __declspec(dllexport)";
			cxx_buffer += "  #endif\n";
			cxx_buffer += "  void {$c_call_name}(VMContext& context) {\n";
			cxx_buffer += "  }\n";

			# get return
			if(type->Equals("Byte")) {
				objk_buffer += "\n      value := array_args[0]->As(IntRef);\n";
				objk_buffer += "      return value->Get()->As(Byte);\n";
			}
			else if(type->Equals("Char")) {
				objk_buffer += "\n      value := array_args[0]->As(IntRef);\n";
				objk_buffer += "      return value->Get()->As(Char);\n";
			}
			else if(type->Equals("Int")) {
				objk_buffer += "\n      value := array_args[0]->As(IntRef);\n";
				objk_buffer += "      return value->Get();\n";
			}
			else if(type->Equals("Bool")) {
				objk_buffer += "\n      value := array_args[0]->As(IntRef);\n";
				objk_buffer += "      return value->Get() = 0 ? false : true;\n";
			}
			else if(type->Equals("Float")) {
				objk_buffer += "\n      value := array_args[0]->As(FloatRef);\n";
				objk_buffer += "      return value->Get();\n";
			}
			else if(type->Equals("String")) {
				objk_buffer += "\n      return array_args[0]->As(String);\n";
			}
			else {
				objk_buffer += "\n      value := array_args[0]->As(IntRef);\n";
				objk_buffer += "      return {$type}->New(value);\n";
			};
			objk_buffer += "    }\n\n";

			#
			# setter
			#
			objk_buffer += "    method : public : Set{$method_case_name}({$name} : {$type}) ~ Nil {\n";
			objk_buffer += "      array_args := Base->New[2];\n\n";
			objk_buffer += "      array_args[0] := IntRef->New(@{$ref_name});\n";

			# set value
			if(type->Equals("Byte") | type->Equals("Char") | type->Equals("Int")) {
				objk_buffer += "      array_args[1] := IntRef->New({$name});\n";
			}
			else if(type->Equals("Bool")) {
				objk_buffer += "      array_args[1] := IntRef->New({$name} ? 1 : 0);\n";
			}
			else if(type->Equals("Float")) {
				objk_buffer += "      array_args[1] := FloatRef->New({$name});\n";
			}
			else {
				objk_buffer += "      array_args[1] := {$name};\n";
			};

			c_call_name := "{$ref_name}_set_{$method_case_name}"->ToLower();
			objk_buffer += "\n      Proxy->GetDllProxy()->CallFunction(\"{$c_call_name}\", array_args);\n";

			objk_buffer += "    }\n\n";
		};

		objk_buffer->Pop();
	}

	method : WriteMethods(ref_name : String, methods_xml : Vector<XmlElement>, objk_buffer : String, cxx_buffer : String, is_constructor : Bool) ~ Nil {
		each(method_xml := methods_xml) {
			method_name := method_xml->GetAttribute("name")->GetValue();
			identifier_name := method_xml->GetAttribute("identifier")->GetValue();
			method_case_name := CamelCaseName(method_name->Copy());

			return_type_xml := method_xml->GetFirstChild("return-value")->GetFirstChild("type");
			return_type := GetMappingName(return_type_xml->GetAttribute("type")->GetValue());

			if(@debug) {
				"  ---\n  [method: name='{$method_name}']"->PrintLine();
			};

			# get parameters and returns types
			params_xml := method_xml->GetFirstChild("parameters");
			return_xml := method_xml->GetFirstChild("return-value");

			if(CanEmitMethod(params_xml, return_xml, false)) {
				cxx_buffer += "#ifdef _WIN32\n";
				cxx_buffer += "    __declspec(dllexport)\n";
				cxx_buffer += "#endif\n";
				cxx_buffer += "    void gtk3_{$identifier_name}(VMContext& context) {\n";
				cxx_buffer += "      GObject* p1 = (GObject*)APITools_GetIntValue(context, 1);\n";
				
				objk_buffer += "    method : public : {$method_case_name}";

				WriteParameters(params_xml, objk_buffer, cxx_buffer);
				objk_buffer += " ~ {$return_type} {\n";

				cxx_params_buffer := "";
				cxx_params_count := 0;

				parameters_size := params_xml->Size() + 1;
				if(return_type->Equals("Nil")) {
					
					objk_buffer += "      array_args := Base->New[{$parameters_size}];\n\n";

					objk_buffer += "      array_args[0] := Nil;\n";
					objk_buffer += "      array_args[1] := IntRef->New(@{$ref_name});\n";
					cxx_params_count := WriteProxyParameters(params_xml, objk_buffer, cxx_params_buffer, true, is_constructor);
				}
				else {
					objk_buffer += "      array_args := Base->New[{$parameters_size}];\n";
					WriteProxyReturnParameter(return_xml, objk_buffer, cxx_buffer);
					
					objk_buffer += "      array_args[1] := IntRef->New(@{$ref_name});\n";
					cxx_params_count := WriteProxyParameters(params_xml, objk_buffer, cxx_params_buffer, false, is_constructor);
				};

				objk_buffer += "\n      Proxy->GetDllProxy()->CallFunction(\"gtk3_{$identifier_name}\", array_args);\n";

				cxx_params_buffer += "      const auto status = {$identifier_name}(p1";
				
				for(i := 1; i < cxx_params_count; i += 1;) {
					if(i <= cxx_params_count) {
						cxx_params_buffer += ", ";
					};

					cxx_params_buffer += "p" + (i + 1);
				};
				cxx_params_buffer += ");\n";
				
				cxx_return_buffer := "";
				WriteProxyReturn(return_xml, objk_buffer, cxx_return_buffer, is_constructor);

				objk_buffer += "    }\n\n";

				cxx_buffer += cxx_params_buffer;
				if(<>cxx_return_buffer->IsEmpty()) {
					cxx_buffer += '\n';
					cxx_buffer += cxx_return_buffer;
				};
				cxx_buffer += "    }\n\n";
			}
		};

		objk_buffer->Pop();
	}

	method : CanEmitMethod(params_xml : XmlElement, return_xml : XmlElement, is_constructor : Bool) ~ Bool {
		each(param_xml := params_xml) {
			param_name := param_xml->GetName();
			if(param_name->Equals("parameter")) {
				type_xml := param_xml->GetFirstChild("type");
				if(type_xml <> Nil) {									
					type_name := GetMappingName(type_xml->GetAttribute("name")->GetValue());
					if(type_name->Has('.')) {
						return false;
					};
				};
			};
		};


		type_xml := return_xml->GetFirstChild("type");
		if(type_xml <> Nil) {									
			type_name := GetMappingName(type_xml->GetAttribute("name")->GetValue());
			if(type_name->Has('.')) {
				return false;
			};
		};

		return true;
	}

	method : WriteParameters(params_xml : XmlElement, objk_buffer : String, cxx_buffer : String) ~ Nil {
		objk_buffer += '(';

		if(params_xml <> Nil & params_xml->Size() > 0) {
			clean_up : Bool;

			each(param_xml := params_xml) {
				param_name := param_xml->GetName();
				if(param_name->Equals("parameter")) {
					clean_up := true;

					param_name := param_xml->GetAttribute("name")->GetValue();
					type_xml := param_xml->GetFirstChild("type");
					if(type_xml <> Nil) {									
						type_name := GetMappingName(type_xml->GetAttribute("name")->GetValue());
						type_ctype := XmlElement->DecodeString(type_xml->GetAttribute("type")->GetValue());
						if(@debug) {
							"    [param='{$param_name}', type='{$type_name}', ctype='{$type_ctype}']"->PrintLine();
						};

						objk_buffer += "{$param_name} : {$type_name}, ";
					};
				};
			};

			if(clean_up) {
				objk_buffer->Pop();
				objk_buffer->Pop();
			};
		};

		objk_buffer += ')';
	}

	method : WriteProxyReturn(return_xml : XmlElement, objk_buffer : String, cxx_buffer : String, is_constructor : Bool) ~ Nil {		
		return_type_xml := return_xml->GetFirstChild("type");
		if(return_type_xml <> Nil) {
			type_xml := return_type_xml->GetAttribute("type");
			if(type_xml <> Nil) {				
				type_name := GetMappingName(type_xml->GetValue());
				
				# TODO: hash sub-strings
				if(type_name->Equals("Int")) {
					objk_buffer += "\n      value := array_args[0]->As(IntRef);\n";
					objk_buffer += "      return value->Get();\n";

					cxx_buffer += "      APITools_SetIntValue(context, 0, status);\n";
				}
				else if(type_name->Equals("Bool")) {
					objk_buffer += "\n      value := array_args[0]->As(IntRef);\n";
					objk_buffer += "      return value->Get() = 0 ? false : true;\n";

					cxx_buffer += "      APITools_SetIntValue(context, 0, status);\n";
				}
				else if(type_name->Equals("Float")) {
					objk_buffer += "\n      value := array_args[0]->As(FloatRef);\n";
					objk_buffer += "      return value->Get();\n";

					cxx_buffer += "      APITools_SetFloatValue(context, 0, status);\n";
				}
				else if(type_name->Equals("String")) {
					objk_buffer += "\n      return array_args[0]->As(String);\n";

					cxx_buffer += "      APITools_SetStringValue(context, 0, status);\n";
				}
				else if(<>type_name->Equals("Nil")) {
					objk_buffer += "\n      value := array_args[0]->As(IntRef);\n";

					if(@consts_set->Has(type_name)) {
						objk_buffer += "      return value->As({$type_name});\n";

						cxx_buffer += "      APITools_SetIntValue(context, 0, (size_t)status);\n";						
					}
					else {
						objk_buffer += "      return {$type_name}->New(value);\n";

						cxx_buffer += "      APITools_SetIntValue(context, 0, status);\n";
					};
				};
			};			
		};
	}

	method : WriteProxyParameters(params_xml : XmlElement, objk_buffer : String, cxx_buffer : String, is_nil : Bool, is_constructor : Bool) ~ Int {
		if(params_xml <> Nil) {
			each(i : params_xml) {
				index := i;
				
				if(<>is_constructor) {
					index += 1;
				};

				param_xml := params_xml->Get(i);
				param_name := param_xml->GetName();
				if(param_name->Equals("parameter")) {
					param_name := param_xml->GetAttribute("name")->GetValue();
					type_xml := param_xml->GetFirstChild("type");
					if(type_xml <> Nil) {									
						type_name := GetMappingName(type_xml->GetAttribute("name")->GetValue());
						
						# TODO: hash sub-strings
						if(type_name->Equals("Int")) {
							objk_buffer += "      array_args[{$index}] := IntRef->New({$param_name});\n";

							cxx_buffer += "      const long p{$index} = APITools_GetIntValue(context, {$index});\n";
						}
						else if(type_name->Equals("Float")) {
							objk_buffer += "      array_args[{$index}] := FloatRef->New({$param_name});\n";

							cxx_buffer += "      const double p{$index} = APITools_GetFloatValue(context, {$index});\n";
						}
						else if(type_name->Equals("Bool")) {
							objk_buffer += "      array_args[{$index}] := IntRef->New({$param_name} = 0 ? 0 : 1);\n";

							cxx_buffer += "      const bool p{$index} = APITools_GetIntValue(context, {$index}) ? false : true;\n";
						}
						else if(type_name->Equals("String")) {
							cxx_buffer += "      const std::string parm{$index} = UnicodeToBytes(APITools_GetStringValue(context, {$index}));\n";
						}
						else {
							objk_buffer += "      array_args[{$index}] := {$param_name};\n";

							ctype_xml := type_xml->GetAttribute("name");
							if(ctype_xml <> Nil) {
								c_type_name := ctype_xml->GetValue();
								cxx_buffer += "\n      const size_t* p{$index}_obj = APITools_GetObjectValue(context, {$index});\n";
								cxx_buffer += "      {$c_type_name}* p{$index} = ({$c_type_name}*)p{$index}_obj[0];\n\n";
							};
						};
					};
				};
			};

			cxx_buffer += '\n';
			return params_xml->Size();
		};

		return 0;
	}

	method : WriteProxyReturnParameter(return_xml : XmlElement, objk_buffer : String, cxx_buffer : String) ~ Nil {		
		return_type_xml := return_xml->GetFirstChild("type");
		if(return_type_xml <> Nil) {
			type_xml := return_type_xml->GetAttribute("type");
			if(type_xml <> Nil) {									
				type_name := GetMappingName(type_xml->GetValue());
				
				# TODO: hash sub-strings
				if(type_name->Equals("Int") | type_name->Equals("Bool")) {
					objk_buffer += "      array_args[0] := IntRef->New();\n";
				}
				else if(type_name->Equals("Float")) {
					objk_buffer += "      array_args[0] := FloatRef->New();\n";
				}
				else {
					objk_buffer += "      array_args[0] := Nil;\n";
				};
			};
		};
	}

	method : ParseParameters(fields_xml : Vector<XmlElement>, objk_buffer : String, cxx_buffer : String) ~ Vector<Pair<String, String>> {
		# TODO: check 'writable' flag
		getters_setters := Vector->New()<Pair<String, String>>;

		if(fields_xml->Size() > 0) {
			each(field_xml := fields_xml) {
				type_xml := field_xml->GetFirstChild("type");
				field_name := field_xml->GetAttribute("name")->GetValue();

				if(type_xml <> Nil) {
					type_name := type_xml->GetAttribute("name")->GetValue();
					ctype_type_xml := type_xml->GetAttribute("type");
					if(ctype_type_xml <> Nil) {
						ctype_type := ctype_type_xml->GetValue();
						if(@debug) {
							"  [\"{$field_name}\": type: name='{$type_name}', ctype='{$ctype_type}']"->PrintLine();
						};
						
						mapping_name := GetMappingName(type_name);
						getters_setters->AddBack(Pair->New(field_name, mapping_name)<String, String>);

					}
					else {
						if(@debug) {
							"  [\"{$field_name}\": type: name='{$type_name}']"->PrintLine();
						};
					};
				};
			};
			objk_buffer += "\n";
		};

		return getters_setters;
	}

	method : GetMappingName(ctype_name : String) ~ String {
		mapping_name := @basic_type_map->Find(ctype_name);
		if(mapping_name <> Nil) {
			return mapping_name;
		};

		mapping_name := ctype_name->Copy()->Remove(@namespace);
		if(mapping_name->EndsWith('*')) {
			mapping_name->Pop();
		};

		return mapping_name;
	}

	function : CamelCaseName(name : String) ~ String {
		if(<>name->IsEmpty()) {
			name->Set(name->Get(0)->ToUpper(), 0);

			do {
				underscore_index := name->Find('_');
				if(underscore_index > -1) {
					name->Delete(underscore_index);
					name->Set(name->Get(underscore_index)->ToUpper(), underscore_index);
				};
			}
			while(underscore_index > -1);
		};

		return name;
	}

	method : WriteObjeckHeader() ~ Nil {
		objk_buffer := "";

		objk_buffer += "bundle GTK3 {\n";
		objk_buffer += "  class : private : Proxy {\n";
		objk_buffer += "    @lib_proxy : static : DllProxy;\n\n";
		objk_buffer += "    function : GetDllProxy() ~ DllProxy {\n";
		objk_buffer += "      if(@lib_proxy = Nil) {\n";
		objk_buffer += "        @lib_proxy := DllProxy->New(\"libobjk_gtk3\";\n";
		objk_buffer += "      };\n\n";
		objk_buffer += "      return @lib_proxy;\n";
		objk_buffer += "    }\n";
		objk_buffer += "  }\n\n";
		
		@objk_out->WriteString(objk_buffer);
	}

	method : WriteCxxHeader() ~ Nil {
		cxx_buffer := "";

		cxx_buffer += "#include \"gtk3_test.h\"\n\n";
		cxx_buffer += "extern \"C\" {\n";
		cxx_buffer += "  static ResourceManager* res_manager = nullptr;\n";
		cxx_buffer += "\n";
		cxx_buffer += "  //\n";
		cxx_buffer += "  // initialize library\n";
		cxx_buffer += "  //\n";
		cxx_buffer += "#ifdef _WIN32\n";
		cxx_buffer += "  __declspec(dllexport)\n";
		cxx_buffer += "#endif\n";
		cxx_buffer += "  void load_lib(VMContext& context) {\n";
		cxx_buffer += "    if(!res_manager) {\n";
		cxx_buffer += "      res_manager = new ResourceManager(context.alloc_managed_obj, context.call_method_by_id);\n";
		cxx_buffer += "    }\n";
		cxx_buffer += "  }\n\n";
		cxx_buffer += "  //\n";
		cxx_buffer += "  // release library\n";
		cxx_buffer += "  //\n";
		cxx_buffer += "#ifdef _WIN32\n";
		cxx_buffer += "  __declspec(dllexport)\n";
		cxx_buffer += "#endif\n";
		cxx_buffer += "  void unload_lib() {\n";
		cxx_buffer += "    if(res_manager) {\n";
		cxx_buffer += "      delete res_manager;\n";
		cxx_buffer += "      res_manager = nullptr;\n";
		cxx_buffer += "    }\n";
		cxx_buffer += "  }\n\n";
		cxx_buffer += "  //\n";
		cxx_buffer += "  // GObject\n";
		cxx_buffer += "  //\n";
		cxx_buffer += "  static void callback_handler(GObject* handler, gpointer callback_data) {\n";
		cxx_buffer += "    if(handler && callback_data) {\n";
		cxx_buffer += "      std::pair<size_t, size_t*>* callback_params = (std::pair<size_t, size_t*>*)callback_data;\n";
		cxx_buffer += "      size_t const mthd_cls_id = callback_params->first;\n";
		cxx_buffer += "      const int cls_id = (mthd_cls_id >> (16 * (1))) & 0xFFFF;\n";
		cxx_buffer += "      const int mthd_id = (mthd_cls_id >> (16 * (0))) & 0xFFFF;\n";
		cxx_buffer += "      size_t* callback_data = callback_params->second;\n\n";
		cxx_buffer += "      GType handler_ctype = G_TYPE_FROM_INSTANCE(handler);\n";
		cxx_buffer += "      if(G_TYPE_IS_CLASSED(handler_ctype)) {\n";
		cxx_buffer += "        const std::string handler_cname(g_type_name(handler_ctype));\n";
		cxx_buffer += "        const char prefix_str[] = \"Gtk\n";
		cxx_buffer += "        size_t handler_cname_prefix_offset = handler_cname.find(prefix_str);\n";
		cxx_buffer += "        if(handler_cname_prefix_offset != std::string::npos) {\n";
		cxx_buffer += "          std::pair<size_t*, long*> exec_stack_mem = res_manager->GetOpStackMemory();\n\n";
		cxx_buffer += "          size_t* op_stack = exec_stack_mem.first;\n";
		cxx_buffer += "          long* stack_pos = exec_stack_mem.second;\n";
		cxx_buffer += "          \n";
		cxx_buffer += "          const std::string post_objk_name = handler_cname.substr(handler_cname_prefix_offset + strlen(prefix_str));\n";
		cxx_buffer += "          const std::string handler_objk_name(\"Gtk3.\" + post_objk_name);\n\n";
		cxx_buffer += "          const APITools_AllocateObject_Ptr alloc_obj = res_manager->GetAllocateObject();\n";
		cxx_buffer += "          size_t* gobject_obj = alloc_obj(BytesToUnicode(handler_objk_name).c_str(), op_stack, *stack_pos, true);\n";
		cxx_buffer += "          if(gobject_obj) {\n";
		cxx_buffer += "            gobject_obj[0] = (size_t)handler;\n\n";
		cxx_buffer += "            // set stack\n";
		cxx_buffer += "            op_stack[0] = (size_t)gobject_obj;\n";
		cxx_buffer += "            op_stack[1] = (size_t)callback_data;\n";
		cxx_buffer += "            (*stack_pos) = 2;\n\n";
		cxx_buffer += "            // call method\n";
		cxx_buffer += "            const APITools_MethodCallById_Ptr mthd_call_id = res_manager->GetMethodCallById();\n";
		cxx_buffer += "            mthd_call_id(op_stack, stack_pos, nullptr, cls_id, mthd_id);\n";
		cxx_buffer += "          }\n\n";
		cxx_buffer += "          // clean up\n";
		cxx_buffer += "          res_manager->ReleaseOpStackMemory(exec_stack_mem);\n";
		cxx_buffer += "        }\n";
		cxx_buffer += "      }\n";
		cxx_buffer += "    }\n";
		cxx_buffer += "  }\n";
		cxx_buffer += "}\n\n";

		@cxx_out->WriteString(cxx_buffer);
	}
}