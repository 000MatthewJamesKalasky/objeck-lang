use Collection;

class GtkClass from GtkDocType {
	New(doc : String) {
		Parent(doc);
	}

	method : public : ToString() ~ String {
		return "TODO";
	}

	method : public : EmitCxx() ~ String {
		return "TODO";
	}

	method : public : EmitObjeck() ~ String {
		return "TODO";
	}
}

class GtkMethod from GtkDocType {
	New(doc : String) {
		Parent(doc);
	}

	function : ToCamelCase(name : String) ~ String {
		if(<>name->IsEmpty()) {
			name->Set(name->Get(0)->ToUpper(), 0);

			do {
				underscore_index := name->Find('_');
				if(underscore_index > -1) {
					name->Delete(underscore_index);
					name->Set(name->Get(underscore_index)->ToUpper(), underscore_index);
				};
			}
			while(underscore_index > -1);
		};

		return name;
	}

	method : public : ToString() ~ String {
		return "TODO";
	}

	method : public : EmitCxx() ~ String {
		return "TODO";
	}

	method : public : EmitObjeck() ~ String {
		return "TODO";
	}
}

class GtkRecord from GtkDocType {
	@name : String;
	@ctype : String;
	@field_types : Vector<GtkRecordField>;

	New(name : String, ctype : String, doc : String) {
		Parent(doc);

		@name := name;
		@ctype := ctype;

		@field_types := Vector->New()<GtkRecordField>;
	}

	method : public : AddField(name : String, ctype : String, is_writable : Bool, doc : String := "") ~ Nil {
		@field_types->AddBack(GtkRecordField->New(name, ctype, is_writable, doc));
	}

	method : public : ToString() ~ String {
		buffer := "";

		doc_size := @doc->Size();
		buffer += "[Record: name='{$@name}', cytpe='{$@ctype}', doc_size={$doc_size}]\n";
		each(field_type := @field_types) {
			buffer += field_type->ToString() + '\n';
		};

		return buffer;
	}

	method : public : EmitCxx() ~ String {
		return "TODO";
	}

	method : public : EmitObjeck() ~ String {
		buffer := "";

		each(field_type := @field_types) {
			buffer += field_type->EmitObjeck();
		};

		return buffer;
	}
}

class GtkRecordField from GtkDocType {
	@type : GtkType;
	@is_writable : Bool;

	New(name : String, ctype : String, is_writable : Bool, doc : String) {
		Parent(doc);

		@type := GtkType->New(name, ctype);
		@is_writable := is_writable;
	}

	method : public : GetType() ~ GtkType {
		return @type;
	}

	method : public : ToString() ~ String {
		buffer := "";

		buffer += "\t[Field: ";
		buffer += @type->ToString();

		doc_size := @doc->Size();
		buffer += ", is_writable={$@is_writable}, doc_size={$doc_size}]";

		return buffer;
	}

	method : public : EmitCxx() ~ String {
		buffer += "";

		# getter
		cxx_name := @type->GetName();
		cxx_name := "objk_get_{$cxx_name}"->ToLower();

		buffer += "#ifdef _WIN32\n";
		buffer += "\t__declspec(dllexport)\n";
		buffer += "#endif\n";
		buffer += "void ${name}(VMContext& context) {\n";

		buffer += "}\n";

		return "buffer";
	}

	method : public : EmitObjeck() ~ String {
		buffer := "";

		# getter
		objk_name := "Get";
		objk_name += GtkMethod->ToCamelCase(@type->GetName());

		buffer += "method : public : {$objk_name}() ~ ";

		# set return type
		select(@type->GetType()) {
			label GtkType->Type->CHAR {
				buffer += "Char {\n";
			}

			label GtkType->Type->INT {
				buffer += "Int {\n";
			}
			label GtkType->Type->BOOL {
				buffer += "Bool {\n";
			}

			label GtkType->Type->FLOAT {
				buffer += "Float {\n";
			}

			other {
				objk_name := @type->GetObjkName();
				buffer += "{$objk_name} {\n";
			}
		};

		buffer += "\tarray_args := Base->New[2];\n\n";

		# set parameters
		buffer += "\tarray_args[0] := ";
		select(@type->GetType()) {
			label GtkType->Type->CHAR
			label GtkType->Type->INT
			label GtkType->Type->CONSTS
			label GtkType->Type->BOOL {
				buffer += "IntRef->New();\n";
			}

			label GtkType->Type->FLOAT {
				buffer += "FloatRef->New();\n";
			}

			other {
				buffer += "Nil;\n";
			}
		};
		buffer += "\tarray_args[1] := IntRef->New(@gobject);\n\n";

		cxx_name := @type->GetName();
		cxx_name := "objk_get_{$cxx_name}"->ToLower();

		buffer += "\tProxy->GetDllProxy()->CallFunction(\"{$cxx_name}\", array_args);\n\n";

		# set return parameter
		select(@type->GetType()) {
			label GtkType->Type->CHAR
			label GtkType->Type->INT
			label GtkType->Type->BOOL {
				buffer += "\tvalue := array_args[0]->As(IntRef);\n";
				buffer += "\treturn value->Get();\n";
			}

			label GtkType->Type->FLOAT {
				buffer += "\tvalue := array_args[0]->As(FloatRef);\n";
				buffer += "\treturn value->Get();\n";
			}

			label GtkType->Type->CONSTS {
				objk_name := @type->GetObjkName();
				buffer += "\tvalue := array_args[0]->As(IntRef);\n";
				buffer += "\treturn value->Get()->As({$objk_name});\n";
			}

			other {
				objk_name := @type->GetObjkName();
				buffer += "\treturn value->As({$objk_name});\n";
			}
		};
		buffer += "}\n\n";

		return buffer;
	}
}

class GtkConst from GtkDocType {
	@name : String;
	@ctype : String;
	@consts_types : Vector<GtkConstField>;

	New(name : String, ctype : String, doc : String) {
		Parent(doc);

		@name := name;
		@ctype := ctype;

		@consts_types := Vector->New()<GtkConstField>;
	}

	method : public : AddConst(name : String, ctype : String, value : Int) ~ Nil {
		@consts_types->AddBack(GtkConstField->New(name, ctype, value));
	}

	method : public : ToString() ~ String {
		buffer := "";

		doc_size := @doc->Size();
		buffer += "[Const: name='{$@name}', cytpe='{$@ctype}', doc_size={$doc_size}]\n";
		each(cont_type := @consts_types) {
			buffer += cont_type->ToString() + '\n';
		};

		return buffer;
	}

	method : public : EmitCxx() ~ String {
		return "TODO";
	}

	method : public : EmitObjeck() ~ String {
		return "TODO";
	}
}	

class GtkConstField implements CodeEmitter {
	@name : String;
	@ctype : String;
	@value : Int;

	New(name : String, ctype : String, value : Int) {
		Parent();

		@name := name;
		@ctype := ctype;
		@value := value;
	}

	method : public : ToString() ~ String {
		return "\t[Member: name='{$@name}', cytpe='{$@ctype}', value={$@value}]";
	}

	method : public : EmitCxx() ~ String {
		return "TODO";
	}

	method : public : EmitObjeck() ~ String {
		return "TODO";
	}
}

class GtkDocType implements CodeEmitter {
	@doc : String;

	New(doc : String) {
		Parent();
		@doc := doc;
	}

	method : virtual : public : ToString() ~ String;
	method : virtual : public : EmitCxx() ~ String;
	method : virtual : public : EmitObjeck() ~ String;
}

interface CodeEmitter {
	method : virtual : public : ToString() ~ String;
	method : virtual : public : EmitCxx() ~ String;
	method : virtual : public : EmitObjeck() ~ String;
}

class GtkType {
	@name : String;
	@ctype_name : String;
	@objk_type_name : String;
	@objk_type : GtkType->Type;

	@type_mapping : static : Map<String, Pair<String, IntRef>>;
	@unknown_type : static : Pair<String, IntRef>;
	@enum_inventory : static : Set<String>;
	@union_inventory : static : Set<String>;
	@record_inventory : static : Set<String>;
	@klass_inventory : static : Set<String>;

	enum Type {
		INT,
		FLOAT,
		CHAR,
		BOOL,
		CONSTS,
		STRING,
		OBJECT,
		UNKNOWN
	}

	New(name : String, ctype_name : String) {
		@name := name;
		@ctype_name := ctype_name;
		
		mapped_type := MapType(ctype_name);
		@objk_type_name := mapped_type->GetFirst();
		@objk_type := mapped_type->GetSecond()->Get();
	}

	function : Init(enum_inventory : Set<String>, union_inventory : Set<String>, record_inventory : Set<String>, klass_inventory : Set<String>) ~ Nil {
		@enum_inventory := enum_inventory;
		@union_inventory := union_inventory;
		@record_inventory := record_inventory;
		@klass_inventory := klass_inventory;

		@type_mapping := Map->New()<String, Pair<String, IntRef>>;
		@unknown_type := Pair->New("Unknown", IntRef->New(GtkType->Type->UNKNOWN))<String, IntRef>;

		# ints
		type_pair := Pair->New("Int", IntRef->New(GtkType->Type->INT))<String, IntRef>;
		@type_mapping->Insert("gint", type_pair);
		@type_mapping->Insert("guint", type_pair);
		@type_mapping->Insert("int", type_pair);
		@type_mapping->Insert("gint8", type_pair);
		@type_mapping->Insert("guint8", type_pair);
		@type_mapping->Insert("gint16", type_pair);
		@type_mapping->Insert("guint16", type_pair);
		@type_mapping->Insert("gshort", type_pair);
		@type_mapping->Insert("guint32", type_pair);
		@type_mapping->Insert("guint32", type_pair);
		@type_mapping->Insert("int", type_pair);

		# doubles
		type_pair := Pair->New("Float", IntRef->New(GtkType->Type->FLOAT))<String, IntRef>;
		@type_mapping->Insert("gdouble", type_pair);

		# bools
		type_pair := Pair->New("Bool", IntRef->New(GtkType->Type->BOOL))<String, IntRef>;
		@type_mapping->Insert("gboolean", type_pair);

		# strings
		type_pair := Pair->New("String", IntRef->New(GtkType->Type->STRING))<String, IntRef>;
		@type_mapping->Insert("utf8", type_pair);
		@type_mapping->Insert("gchar*", type_pair);
		@type_mapping->Insert("char*", type_pair);
	}

	method : MapType(ctype_name : String) ~ Pair<String, IntRef> {
		result := @type_mapping->Find(ctype_name);
		if(result <> Nil) {
			return result;
		};

		if(@enum_inventory->Has(ctype_name)) {
			name := ctype_name->Remove("Gdk");
"=== {$name} ==="->PrintLine();			

			type_pair := Pair->New(name, IntRef->New(GtkType->Type->CONSTS))<String, IntRef>;
			@type_mapping->Insert(name, type_pair);

			return type_pair;
		};
		
		return @unknown_type;
	}

	method : public : GetName() ~ String {
		return @name;
	}

	method : public : GetCxxName() ~ String {		
		return @ctype_name;
	}

	method : public : GetObjkName() ~ String {		
		return @objk_type_name;
	}

	method : public : GetType() ~ GtkType->Type {		
		return @objk_type;
	}
	
	method : public : ToString() ~ String {
		type_str : String;

		select(@objk_type) {
			label Type->INT {
				type_str := "Type->INT";
			}
		
			label Type->FLOAT {
				type_str := "Type->INT";
			}

			label Type->CHAR {
				type_str := "Type->INT";
			}

			label Type->STRING {
				type_str := "Type->INT";
			}

			label Type->OBJECT {
				type_str := "Type->INT";
			}

			other {
				type_str := "<Unknown>";
			}
		};

		return "[Type: name='{$@name}', ctype_name='{$@ctype_name}', type='{$type_str}']";
	}
}
