use Collection;

class GtkClass from GtkDocType {
	New(doc : String, type : GtkType->Type) {
		Parent(doc, type);
	}

	method : public : ToString() ~ String {
		return "TODO";
	}
}

class GtkMethod from GtkDocType {
	New(doc : String, type : GtkType->Type) {
		Parent(doc, type);
	}

	method : public : ToString() ~ String {
		return "TODO";
	}
}

class GtkRecord from GtkDocType {
	@name : String;
	@ctype : String;
	@field_types : Vector<GtkRecordField>;

	New(name : String, ctype : String, doc : String) {
		Parent(doc, GtkType->Type->RECORD);

		@name := name;
		@ctype := ctype;

		@field_types := Vector->New()<GtkRecordField>;
	}

	method : public : AddField(name : String, ctype : String, is_writable : Bool, doc : String := "") ~ Nil {
		objk_type := GtkConst->MapType(ctype);
objk_type->PrintLine();

		@field_types->AddBack(GtkRecordField->New(name, ctype, is_writable, doc));
	}

	method : public : ToString() ~ String {
		buffer := "";

		doc_size := @doc->Size();
		buffer += "[Record: name='{$@name}', cytpe='{$@ctype}', doc_size={$doc_size}]\n";
		each(field_type := @field_types) {
			buffer += field_type->ToString() + '\n';
		};

		return buffer;
	}
}

class GtkRecordField from GtkDocType {
	@name : String;
	@ctype : String;
	@is_writable : Bool;

	New(name : String, ctype : String, is_writable : Bool, doc : String) {
		Parent(doc, GtkType->Type->RECORD);

		@name := name;
		@ctype := ctype;
		@is_writable := is_writable;
	}

	method : public : ToString() ~ String {
		doc_size := @doc->Size();
		return "\t[Field: name='{$@name}', cytpe='{$@ctype}', is_writable={$@is_writable}, doc_size={$doc_size}]";
	}
}

class GtkConst from GtkDocType {
	@name : String;
	@ctype : String;
	@consts_types : Vector<GtkConstField>;

	New(name : String, ctype : String, doc : String) {
		Parent(doc, GtkType->Type->ENUM);

		@name := name;
		@ctype := ctype;

		@consts_types := Vector->New()<GtkConstField>;
	}

	method : public : AddConst(name : String, ctype : String, value : Int) ~ Nil {
		@consts_types->AddBack(GtkConstField->New(name, ctype, value));
	}

	method : public : ToString() ~ String {
		buffer := "";

		doc_size := @doc->Size();
		buffer += "[Const: name='{$@name}', cytpe='{$@ctype}', doc_size={$doc_size}]\n";
		each(cont_type := @consts_types) {
			buffer += cont_type->ToString() + '\n';
		};

		return buffer;
	}
}	

class GtkConstField from GtkType {
	@name : String;
	@ctype : String;
	@value : Int;

	New(name : String, ctype : String, value : Int) {
		Parent(GtkType->Type->CONST);

		@name := name;
		@ctype := ctype;
		@value := value;
	}

	method : public : ToString() ~ String {
		return "\t[Member: name='{$@name}', cytpe='{$@ctype}', value={$@value}]";
	}
}

class GtkDocType from GtkType {
	@doc : String;

	New(doc : String, type : GtkType->Type) {
		Parent(type);
		@doc := doc;
	}

	method : virtual : public : ToString() ~ String;
}

class GtkType {
	@type_mapping : static : Map<String, String>;
	@type : GtkType->Type;

	enum Type {
		ENUM,
		CONST,
		RECORD,
		CLASS,
		METHOD
	}

	function : Init() ~ Nil {
		@type_mapping := Map->New()<String, String>;

		# ints
		@type_mapping->Insert("gint", "Int");
		@type_mapping->Insert("guint", "Int");
		@type_mapping->Insert("int", "Int");
		@type_mapping->Insert("gint8", "Int");
		@type_mapping->Insert("guint8", "Int");
		@type_mapping->Insert("gint16", "Int");
		@type_mapping->Insert("guint16", "Int");
		@type_mapping->Insert("gshort", "Int");
		@type_mapping->Insert("guint32", "Int");
		@type_mapping->Insert("guint32", "Int");
		@type_mapping->Insert("int", "Int");
		# doubles
		@type_mapping->Insert("gdouble", "Float");
		# bools
		@type_mapping->Insert("gboolean", "Bool");
		# strings
		@type_mapping->Insert("utf8", "String");
		@type_mapping->Insert("gchar*", "String");
		@type_mapping->Insert("char*", "String");
	}

	function : MapType(ctype : String) ~ String {
		result := @type_mapping->Find(ctype);
		if(result = Nil) {
			return ctype;
		};

		return result;
	}

	New(type : GtkType->Type) {
		@type := type;
	}

	method : public : GetType() ~ GtkType->Type {
		return @type;
	}

	method : virtual : public : ToString() ~ String;

	function : ToCamelCase(name : String) ~ String {
		if(<>name->IsEmpty()) {
			name->Set(name->Get(0)->ToUpper(), 0);

			do {
				underscore_index := name->Find('_');
				if(underscore_index > -1) {
					name->Delete(underscore_index);
					name->Set(name->Get(underscore_index)->ToUpper(), underscore_index);
				};
			}
			while(underscore_index > -1);
		};

		return name;
	}
}

interface CodeEmitter {
	method : virtual : EmitCxx() ~ String;

	method : virtual : EmitObjeck() ~ String;
}