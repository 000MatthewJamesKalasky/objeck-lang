use Web.HTTP, Collection, Data.JSON;

#~
Google Gemini ML client APIs
~#
bundle API.Google.Gemini {
	#~
	Gemini model interactions
	~#
	class Model from EndPoint implements Stringify {
		@description : String;
		@display_name : String;
		@input_token_limit : Int;
		@name : String;
		@output_token_limit : Int;
		@generation_methods : Vector<String>;
		@temperature : Float;
		@top_k : Int;
		@top_p : Float;
		@version : String;

		New : private(description : String, display_name : String, input_token_limit : Int, 
				name : String, output_token_limit : Int, generation_methods : Vector<String>, 
				temperature : Float, top_k : Int, top_p : Float, version : String) {
			Parent();

			@description := description;
			@display_name := display_name;
			@input_token_limit := input_token_limit;
			@name := name;
			@output_token_limit := output_token_limit;
			@generation_methods := generation_methods;
			@temperature := temperature;
			@top_k := top_k;
			@top_p := top_p;
			@version := version;
		}
		
		#~
		Lists available models
		@param key API key
		@return available models
		~#
		function : ListModels(key : String) ~ Vector<Model> {
			models := Vector->New()<Model>;

			url := Url->New("https://generativelanguage.googleapis.com/v1/models?key={$key}");
			response := GetRequest(url);

			if(response <> Nil) {
				# response->ToString()->PrintLine();			
				models_json := response->Get("models");

				each(model_json in models_json) {
					description := model_json->Get("description")->GetString();
					display_name := model_json->Get("displayName")->GetString();
					input_token_limit := model_json->Get("inputTokenLimit")->GetInt();
					name := model_json->Get("name")->GetString();
					output_token_limit := model_json->Get("outputTokenLimit")->GetInt();

					generation_methods := Vector->New()<String>;
					generation_methods_json := model_json->Get("supportedGenerationMethods");
					each(generation_method_json in generation_methods_json) {
						generation_methods->AddBack(generation_method_json->GetString());
					}

					temperature := 0.9;
					temperature_json := model_json->Get("temperature");
					if(temperature_json <> Nil) {
						temperature := temperature_json->GetFloat();
					};

					top_k := 0;			
					top_k_json := model_json->Get("topK");
					if(top_k_json <> Nil) {
						top_k := top_k_json->GetInt();
					};

					top_p := 1.0;
					top_p_json := model_json->Get("topP");
					if(top_p_json <> Nil) {
						top_p := top_p_json->GetFloat();
					};
					version := model_json->Get("version")->GetString();

					models->AddBack(Model->New(description, display_name, input_token_limit, name, output_token_limit, 
						generation_methods, temperature, top_k, top_p, version));
				};
			};

			return models;
		}

		#~
		Gets a model by name
		@param model_name model name
		@param key API key
		@return available models
		~#
		function : GetModel(model_name : String, key : String) ~ Model {
			url := Url->New("https://generativelanguage.googleapis.com/v1/{$model_name}?key={$key}");
			model_json := GetRequest(url);

			if(model_json <> Nil) {
				# model_json->ToString()->PrintLine();

				description := model_json->Get("description")->GetString();
				display_name := model_json->Get("displayName")->GetString();
				input_token_limit := model_json->Get("inputTokenLimit")->GetInt();
				name := model_json->Get("name")->GetString();
				output_token_limit := model_json->Get("outputTokenLimit")->GetInt();

				generation_methods := Vector->New()<String>;
				generation_methods_json := model_json->Get("supportedGenerationMethods");
				each(generation_method_json in generation_methods_json) {
					generation_methods->AddBack(generation_method_json->GetString());
				}

				temperature := 0.9;
				temperature_json := model_json->Get("temperature");
				if(temperature_json <> Nil) {
					temperature := temperature_json->GetFloat();
				};

				top_k := 0;			
				top_k_json := model_json->Get("topK");
				if(top_k_json <> Nil) {
					top_k := top_k_json->GetInt();
				};

				top_p := 1.0;
				top_p_json := model_json->Get("topP");
				if(top_p_json <> Nil) {
					top_p := top_p_json->GetFloat();
				};
				version := model_json->Get("version")->GetString();

				return Model->New(description, display_name, input_token_limit, name, output_token_limit, 
					generation_methods, temperature, top_k, top_p, version);
				
			};

			return Nil;
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param content content for the model
		@param key API key		
		~#
		function : GenerateContent(model_name : String, content : Content, key : String) ~ Vector<Candidate> {
			return GenerateContent(model_name, content, Nil, Nil, key);
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param content model content
		@param safety_settings key/value safety settings
		@param config generation configuration, currently unsupported
		@param key API key		
		~#
		function : GenerateContent(model_name : String, content : Content, safety_settings : Vector<Tuples.Pair<String, String>>, config : GenerationConfig, key : String) ~ Vector<Candidate> {
			contents := Vector->New()<Content>;
			contents->AddBack(content);

			return GenerateContent(model_name, contents, safety_settings, config, key);
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param contents list of content for the model
		@param safety_settings key/value safety settings
		@param config generation configuration, currently unsupported
		@param key API key		
		~#
		function : GenerateContent(model_name : String, contents : Vector<Content>, safety_settings : Vector<Tuples.Pair<String, String>>, config : GenerationConfig, key : String) ~ Vector<Candidate> {
			# contents
			content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			each(content in contents) {
				parts := content->GetParts();
				content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

				content_obj_json->Insert("role", content->GetRole());

				parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(part in parts) {
					part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

					# text
					if(part->TypeOf(TextPart)) {
						text_part := part->As(TextPart);
						part_obj_json->Insert("text", text_part->GetText());
					}					
					else {
						binary_part := part->As(BinaryPart);

						inline_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
						inline_obj_json->Insert("mimeType", binary_part->GetMimeType());
						inline_obj_json->Insert("data", binary_part->GetBase64Data());
						
						part_obj_json->Insert("inlineData", inline_obj_json);
					};

					parts_obj_json->Add(part_obj_json);
				};
				content_obj_json->Insert("parts", parts_obj_json);

				content_array_json->Add(content_obj_json);
			};
			contents_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			contents_obj_json->Insert("contents", content_array_json);

			# safety settings
			if(safety_settings <> Nil) {
				safety_setting_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(safety_setting in safety_settings) {
					safety_setting_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
					safety_setting_obj_json->Insert("category", safety_setting->GetFirst());
					safety_setting_obj_json->Insert("threshold", safety_setting->GetSecond());
					safety_setting_array_json->Add(safety_setting_obj_json);
				};
				contents_obj_json->Insert("safetySettings", safety_setting_array_json);
			};

			#~
			# TODO: GenerationConfig 
			if(config <> Nil) {
				#  generation configuration
				gen_config_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				contents_obj_json->Insert("generationConfig", gen_config_obj_json);
			};
			~#

			# contents_obj_json->ToString()->PrintLine();

			url := Url->New("https://generativelanguage.googleapis.com/v1/{$model_name}:generateContent?key={$key}");
			if(url->GetQueryParameters()->Has("key")) {			
				response := PostRequest(contents_obj_json, url);
				if(response <> Nil) {
					# response->ToString()->PrintLine();
					candidates := Vector->New()<Candidate>;
					
					candidates_json := response->Get("candidates");
					each(candidate_json in candidates_json) {						
						# general attributes
						role := candidate_json->Get("content")->Get("role")->GetString();
						finish_reason := candidate_json->Get("finishReason")->GetString();
						index := candidate_json->Get("index")->GetInt();

						# parts
						parts := Vector->New()<Part>;
						parts_json := candidate_json->Get("content")->Get("parts");
						each(part_json in parts_json) {
							part : Part;

							# text part
							if(part_json->Has("text")) {
								text_json := part_json->Get("text");
								part := TextPart->New(text_json->GetString());
							};

							# inline part
							if(part_json->Has("inlineData")) {
								inline_mime_type := part_json->FindElements("inlineData/mimeType")->GetString();
								inline_data := part_json->FindElements("inlineData/data")->GetString();
								part := BinaryPart->New(Encryption.Decrypt->Base64(inline_data), inline_mime_type);
							};

							parts->AddBack(part);
						};

						# safety ratings
						safety_ratings := Vector->New()<Tuples.Pair<String,String>>;
						safety_ratings_json := candidate_json->Get("safetyRatings");
						each(safety_rating_json in safety_ratings_json) {
							safety_category := safety_rating_json->Get("category")->GetString();
							safety_probability := safety_rating_json->Get("probability")->GetString();
							safety_rating := Tuples.Pair->New(safety_category, safety_probability)<String, String>;

							safety_ratings->AddBack(safety_rating);
						};

						candidates->AddBack(Candidate->New(index, role, finish_reason, parts, safety_ratings));
					};

					return candidates;
				};
			};
			
			return Nil;
		}

		#~
		Runs a model's tokenizer on input content and returns the token count
		@param model_name model name
		@param content content for the model
		@param key API key		
		~#
		function : CountTokens(model_name : String, content : Content, key : String) ~ Int {
			contents := Vector->New()<Content>;
			contents->AddBack(content);

			return CountTokens(model_name, contents, key);
		}

		#~
		Runs a model's tokenizer on input content and returns the token count
		@param model_name model name
		@param contents list of content for the model
		@param key API key		
		~#
		function : CountTokens(model_name : String, contents : Vector<Content>, key : String) ~ Int {
			# contents
			content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			each(content in contents) {
				parts := content->GetParts();
				content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

				content_obj_json->Insert("role", content->GetRole())

				parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(part in parts) {
					part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

					# text
					if(part->TypeOf(TextPart)) {
						text_part := part->As(TextPart);
						part_obj_json->Insert("text", text_part->GetText());
					}					
					else {
						binary_part := part->As(BinaryPart);

						inline_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
						inline_obj_json->Insert("mimeType", binary_part->GetMimeType());
						inline_obj_json->Insert("data", binary_part->GetBase64Data());
						
						part_obj_json->Insert("inlineData", inline_obj_json);
					};

					parts_obj_json->Add(part_obj_json);
				};
				content_obj_json->Insert("parts", parts_obj_json);

				content_array_json->Add(content_obj_json)
			};
			contents_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			contents_obj_json->Insert("contents", content_array_json);

			url := Url->New("https://generativelanguage.googleapis.com/v1/{$model_name}:countTokens?key={$key}");
			if(url->GetQueryParameters()->Has("key")) {			
				response := PostRequest(contents_obj_json, url);
				if(response <> Nil) {
					# response->ToString()->PrintLine();
					return response->Get("totalTokens")->GetInt();
				};
			};

			return -1;
		}

		#~
		Get the model's description
		@return model's description
		~#
		method : public : GetDescription() ~ String {
			return @description;
		}

		#~
		Get the model's display name
		@return model's display name
		~#
		method : public : GetDisplayName() ~ String {
			return @display_name;
		}

		#~
		Get the model's input token limit
		@return model's input token limit
		~#
		method : public : GetInputTokenLimit() ~ Int {
			return @input_token_limit;
		}

		#~
		Get the model's name
		@return model's name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Maximum number of output tokens available for this model
		@return maximum number of output tokens
		~#
		method : public : GetOutputTokenLimit() ~ Int {
			return @output_token_limit;
		}

		#~
		The model's supported generation methods.
		@return generation methods
		~#
		method : public : GetGenerationMethods() ~ Vector<String> {
			return @generation_methods;
		}

		#~
		Controls the randomness of the output. Values can range over [0.0,1.0], 
		inclusive. A value closer to 1.0 will produce responses that are more 
		varied, while a value closer to 0.0 will typically result in less 
		surprising responses from the model.
		@return model temperature 
		~#
		method : public : GetTemperature() ~ Float {
			return @temperature;
		}

		#~
		Get the top-k sampling of the most probable tokens.
		@return top-k sampling
		~#
		method : public : GetTopK() ~ Int {
			return @top_k;
		}

		#~
		Nucleus sampling considers the smallest set of tokens whose probability sum is at least topP.
		~#
		method : public : GetTopP() ~ Float {
			return @top_p;
		}

		#~
		Get the model version
		@return model version
		~#
		method : public : GetVersion() ~ String {
			return @version;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			buffer += "name='"
			buffer += @name;

			buffer += "', display_name="
			buffer += @display_name;

			buffer += "', version="
			buffer += @version;

			buffer += "' input_token_limit="
			buffer += @input_token_limit;

			buffer += ", output_token_limit="
			buffer += @output_token_limit;

			buffer += ", description=\""
			buffer += @description;

			buffer += "\"\nmethods:"
			each(generation_method in @generation_methods) {
				buffer += "\n\t";
				buffer += generation_method;
			};
			buffer += ']';

			return buffer;
		}
	}

	#~
	Text message part
	~#
	class TextPart from Part implements Stringify {
		@text : String;

		New(text : String) {
			Parent();
			@text := text;
		}

		#~
		Get text
		@return text
		~#
		method : public : GetText() ~ String {
			return @text;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			return "text='{$@text}'";
		}
	}

	#~
	Binary message part
	~#
	class BinaryPart from Part implements Stringify {
		@data : Byte[];
		@mime_type : String;

		New(data : Byte[], mime_type : String) {
			Parent();

			@data := data;
			@mime_type := mime_type;
		}

		#~
		Get Base64 encoding binary string
		@return encoding binary string
		~#
		method : public : GetBase64Data() ~ String {
			return Encryption.Encrypt->Base64(@data);
		}

		#~
		Get MIME type
		@return MIME type
		~#
		method : public : GetMimeType() ~ String {
			return @mime_type;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			data_size := @data->Size();
			return "data_size={$data_size}, mime_type='{$@mime_type}'";
		}
	}

	#~
	Abstract message part
	~#
	class Part {
		New() {}
		method : virtual : public : ToString() ~ String;
	}

	# TODO: implement, support is spotty
	class GenerationConfig from EndPoint {
		New() {
			Parent();
		}
	}

	#~
	Prompt content
	~#
	class Content from EndPoint implements Stringify {
		@parts : Vector<Part>;
		@role : String;

		#~
		Constructor
		@param parts message parts to add
		@param role role
		~#
		New(parts : Vector<Part>, role : String) {
			Parent();
			@role := role;
			@parts := parts;
		}

		#~
		Adds a part to the content
		@param part to add
		@return self reference to Content
		~#
		method : public : AddPart(part : Part) ~ Content {
			@parts->AddBack(part);
			return @self;
		}

		#~
		Get all parts
		@return all parts
		~#
		method : public : GetParts() ~ Vector<Part> {
			return @parts;
		}

		#~
		Get the first part
		@return first part
		~#
		method : public : GetFirstPart() ~ Part {
			last := @parts->Size() - 1;
			if(last > -1) {
				return @parts->Get(last);
			};

			return Nil;
		}

		#~
		Get the role
		@return role
		~#
		method : public : GetRole() ~ String {
			return @role;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "{";

			buffer->Append("role='");
			buffer->Append(@role);

			buffer->Append("'\nparts:");
			each(part in @parts) {
				buffer->Append("\n\t");
				buffer->Append(part->ToString());
			};
			buffer->Append('}');
			
			return buffer;
		}
	}

	#~
	Candidate prompt response
	~#
	class Candidate from Content implements Stringify {
		@index : Int;
		@finish_reason : String;
		@safety_ratings : Vector<Tuples.Pair<String,String>>;
		
		New(index : Int, role : String, finish_reason : String, parts : Vector<Part>, safety_ratings : Vector<Tuples.Pair<String,String>>) {
			Parent(parts, role);

			@index := index;
			@role := role;
			@finish_reason := finish_reason;
			@parts := parts;
			@safety_ratings := safety_ratings;
		}

		#~
		Get index
		@return index
		~#
		method : public : GetIndex() ~ Int {
			return @index;
		}

		#~
		Get finishing reason
		@return finishing reason
		~#
		method : public : GetFinishReason () ~ String {
			return @finish_reason;
		}

		#~
		Get safety ratings
		@return list of safety ratings
		~#
		method : public : GetSafetyRatings() ~ Vector<Tuples.Pair<String,String>> {
			return @safety_ratings;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "";

			buffer->Append("index='");
			buffer->Append(@index);

			buffer->Append("', role='");
			buffer->Append(@role);

			buffer->Append("', finish_reason='");
			buffer->Append(@finish_reason);

			buffer->Append("'\nparts:");
			each(part in @parts) {
				buffer->Append("\n\t");
				buffer->Append(part->ToString());
			};

			buffer->Append("'\n\tsafety_ratings:");
			each(safety_rating in @safety_ratings) {
				buffer->Append("\n\t");
				buffer->Append(safety_rating->ToString());
			};

			return buffer;
		}
	}

	#~
	Gemini chat session
	~#
	class Chat from Content implements Stringify {
		@content_array_json : JsonElement;
		@contents_obj_json : JsonElement;
		@model_name : String;
		@key : String;

		New(model_name : String, key : String) {
			Parent();

			@model_name := model_name;
			@key := key;

			@content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			@contents_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			@contents_obj_json->Insert("contents", @content_array_json);
		}

		#~
		Send chart part
		@param part prompt chat part
		@param role prompt role
		@return prompt response
		~#
		method : public : SendPart(part : Part, role : String) ~ Candidate {
			content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			content_obj_json->Insert("role", role);

			parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			# text
			if(part->TypeOf(TextPart)) {
				text_part := part->As(TextPart);
				part_obj_json->Insert("text", text_part->GetText());
			}					
			else {
				binary_part := part->As(BinaryPart);

				inline_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
				inline_obj_json->Insert("mimeType", binary_part->GetMimeType());
				inline_obj_json->Insert("data", binary_part->GetBase64Data());
				
				part_obj_json->Insert("inlineData", inline_obj_json);
			};

			parts_obj_json->Add(part_obj_json);

			content_obj_json->Insert("parts", parts_obj_json);
			@content_array_json->Add(content_obj_json);


			url := Url->New("https://generativelanguage.googleapis.com/v1/{$@model_name}:generateContent?key={$@key}");
			if(url->GetQueryParameters()->Has("key")) {
				# @contents_obj_json->ToString()->PrintLine();
				response := EndPoint->PostRequest(@contents_obj_json, url);
				if(response <> Nil) {
					# response->ToString()->PrintLine();
					candidates := Vector->New()<Candidate>;
					candidates_json := response->Get("candidates");
					each(candidate_json in candidates_json) {						
						# general attributes
						role := candidate_json->Get("content")->Get("role")->GetString();
						finish_reason := candidate_json->Get("finishReason")->GetString();
						index := candidate_json->Get("index")->GetInt();

						# parts
						parts := Vector->New()<Part>;
						content_json := candidate_json->Get("content");
						parts_json := content_json->Get("parts");

						@content_array_json->Add(content_json);

						each(part_json in parts_json) {
							# text part
							if(part_json->Has("text")) {
								text_json := part_json->Get("text");
								part := TextPart->New(text_json->GetString());
							};

							# inline part
							if(part_json->Has("inlineData")) {
								inline_mime_type := part_json->FindElements("inlineData/mimeType")->GetString();
								inline_data := part_json->FindElements("inlineData/data")->GetString();
								part := BinaryPart->New(Encryption.Decrypt->Base64(inline_data), inline_mime_type);
							};

							parts->AddBack(part);
						};

						# safety ratings
						safety_ratings := Vector->New()<Tuples.Pair<String,String>>;
						safety_ratings_json := candidate_json->Get("safetyRatings");
						each(safety_rating_json in safety_ratings_json) {
							safety_category := safety_rating_json->Get("category")->GetString();
							safety_probability := safety_rating_json->Get("probability")->GetString();
							safety_rating := Tuples.Pair->New(safety_category, safety_probability)<String, String>;

							safety_ratings->AddBack(safety_rating);
						};

						candidates->AddBack(Candidate->New(index, role, finish_reason, parts, safety_ratings));
					};

					return candidates->Last();
				};
			};
			
			return Nil;
		}

		#~
		Get all chat parts
		@return list of all chat parts
		~#
		method : public : GetAllParts() ~ Vector<Content> {
			contents := Vector->New()<Content>;

			contents_array_json := @contents_obj_json->Get("contents");
			each(candidate_json in contents_array_json) {
				# role and parts
				role := candidate_json->Get("role")->GetString();
				parts_json := candidate_json->Get("parts");
				
				parts := Vector->New()<Part>;
				each(part_json in parts_json) {
					part : Part;

					# text part
					if(part_json->Has("text")) {
						text_json := part_json->Get("text");
						part := TextPart->New(text_json->GetString());
					};

					# inline part
					if(part_json->Has("inlineData")) {
						inline_mime_type := part_json->FindElements("inlineData/mimeType")->GetString();
						inline_data := part_json->FindElements("inlineData/data")->GetString();
						part := BinaryPart->New(Encryption.Decrypt->Base64(inline_data), inline_mime_type);
					};

					parts->AddBack(part);
				};

				contents->AddBack(Content->New(parts, role));
			};

			return contents;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "";

			buffer->Append("model_name='")
			buffer->Append(@model_name);
			buffer->Append("', ")
			buffer->Append(GetAllParts()->ToString());

			return buffer;
		}
	}

	#~
	Gemini endpoint
	~#
	class EndPoint {
		@last_message : static : String;
		@api_key : static : String;

		New() {}

		function : private : GetRequest(url : Url) ~ JsonElement {
			response := HttpsClient->QuickGet(url, "application/json");
			if(response <> Nil) {
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				
				# response->GetContent()->ToString()->PrintLine();
				
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				error_json := response_json->FindElements("error/message")
				if(error_json <> Nil) {
					error_message := error_json->GetString();
					">>> Error: {$error_message} <<<"->ErrorLine();
					return Nil;
				};

				return response_json;
			};

			return Nil;
		}

		function : private : PostRequest(request : JsonElement, url : Url, headers : Map<String,String>) ~ JsonElement {
			response := HttpsClient->QuickPost(url, request->ToString()->ToByteArray(), "application/json", headers);
			if(response <> Nil) {
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				
				# response->GetContent()->ToString()->PrintLine();			
				
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				error_json := response_json->FindElements("error/message")
				if(error_json <> Nil) {
					error_message := error_json->GetString();
					">>> Error: {$error_message} <<<"->ErrorLine();
					return Nil;
				};

				return response_json;
			};

			return Nil;
		}

		function : private : PostRequest(request : JsonElement, url : Url) ~ JsonElement {
			response := HttpsClient->QuickPost(url, request->ToString()->ToByteArray(), "application/json");
			if(response <> Nil) {
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				
				# response->GetContent()->ToString()->PrintLine();			
				
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				error_json := response_json->FindElements("error/message")
				if(error_json <> Nil) {
					error_message := error_json->GetString();
					">>> Error: {$error_message} <<<"->ErrorLine();
					return Nil;
				};

				return response_json;
			};

			return Nil;
		}

		#~
		Reads API from 'api_key.dat'
		@return API key
		~#
		function : GetApiKey() ~ String {
			if(@api_key = Nil) {
				token := System.IO.Filesystem.FileReader->ReadFile("api_key.dat");
				if(token <> Nil) {
					@api_key := token->Trim();
				};
			};

			return @api_key;
		}

		function : SetLastError(last_message : String) ~ Nil {
			@last_message := last_message;
		}

		#~
		Get the last error
		@return last error
		~#
		function : GetLastError() ~ String {
			return @last_message;
		}
	}
}

#~
Google Gemini corpus APIs
~#
bundle API.Google.Gemini.Corpus {
	#~
	Google Gemini corpus
	~#
	class Corpus from OAuthEndPoint implements Stringify {
		@name : String;
		@display_name : String;
		@create_time_str : String;
		@update_time_str : String;

		#~
		Get corpus ID
		@return corpus ID
		~#
		method : public : GetId() ~ String {
			return @name;
		}

		#~
		Get the display name
		@return display name
		~#
		method : public : GetName() ~ String {
			return @display_name;
		}

		#~
		Get creation time
		@return creation time
		~#
		method : public : GetCreateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@create_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Get update time
		@return update time
		~#
		method : public : GetUpdateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@update_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		New : private(request_json : JsonElement) {
			Parent();

			@name := request_json->Get("name")->GetString();
			@display_name := request_json->Get("displayName")->GetString();
			@create_time_str := request_json->Get("createTime")->GetString();
			@update_time_str := request_json->Get("updateTime")->GetString();
		}

		#~
		Create a new corpus
		@param name corpus name
		@return new corpus
		~#
		function : Create(name : String) ~ Corpus {
			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("displayName", name);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/corpora"), data, 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Corpus->New(response_json);
			};

			return Nil;	
		}

		#~
		Get existing corpus
		@param name corpus name
		@return existing corpus
		~#
		function : Get(name : String) ~ Corpus {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$name}"), 
				"application/json", headers);

			if(response <> Nil) {
				#response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Corpus->New(response_json);
			};

			return Nil;	
		}

		#~
		Get all existing corpupa
		@return list of corpusa
		~#
		function : List() ~ Collection.Vector<Corpus> {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/corpora"), 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				corpuses := Collection.Vector->New()<Corpus>;
				
				corporas_json := response_json->Get("corpora");
				if(corporas_json <> Nil) {
					each(corpora_json in corporas_json) {
						corpuses->AddBack(Corpus->New(corpora_json));
					};
				};

				return corpuses;
			};

			return Nil;	
		}

		#~
		Delete existing corpus
		@return true if successful, false otherwise
		~#
		method : public : Delete() ~ Bool {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickDelete(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}"), 
				"application/json", headers);
			
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return false;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return false;
				};

				return true;
			};

			return false;	
		}

		#~
		Query the corpus
		@param query string query
		@return query results as triple, 1) relevance, 2) string content, 3) content metadata
		~#
		method : public : Query(query : String) ~ Vector<Tuples.Triplet<FloatRef, String, Map<String, String>>> {
			# TODO metadata filters
			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("query", query);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}:query"), data, 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				# process results
				relevance_results := Vector->New()<Tuples.Triplet<FloatRef, String, Map<String, String>>>;
				chunks_array_json := response_json->Get("relevantChunks");;
				each(chunk_json in chunks_array_json) {
					relevance_score := chunk_json->Get("chunkRelevanceScore")->GetFloat();
					relevance_data := Url->Decode(chunk_json->FindElements("chunk/data/stringValue")->ToString());

					relevance_metadata := Map->New()<String, String>;
					metadata_array_json := chunk_json->FindElements("chunk/customMetadata");
					each(metadata_obj_json in metadata_array_json) {
						key := metadata_obj_json->Get("key")->GetString();
						value := metadata_obj_json->Get("stringValue")->GetString();

						relevance_metadata->Insert(key, value);
					}

					result := Tuples.Triplet->New(relevance_score, relevance_data, relevance_metadata)<FloatRef, String, Map<String, String>>;
					relevance_results->AddBack(result);
				};

				return relevance_results;
			};

			return Nil;	
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[name='";
			buffer += @name;

			buffer += "', display_name='"
			buffer += @display_name;

			buffer += "', create_time_str='"
			buffer += @create_time_str;

			buffer += "', update_time_str='"
			buffer += @update_time_str;

			buffer += "']";
			return buffer;
		}
	}

	#~
	Google Gemini document
	~#
	class Document from OAuthEndPoint implements Stringify {
		@name : String;
		@display_name : String;
		@create_time_str : String;
		@update_time_str : String;

		New : private(request_json : JsonElement) {
			Parent();

			@name := request_json->Get("name")->GetString();
			@display_name := request_json->Get("displayName")->GetString();
			@create_time_str := request_json->Get("createTime")->GetString();
			@update_time_str := request_json->Get("updateTime")->GetString();
		}

		#~
		Get document ID
		@return document ID
		~#
		method : public : GetId() ~ String {
			return @name;
		}

		#~
		Get the display name
		@return display name
		~#
		method : public : GetName() ~ String {
			return @display_name;
		}

		#~
		Get creation time
		@return creation time
		~#
		method : public : GetCreateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@create_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Get update time
		@return update time
		~#
		method : public : GetUpdateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@update_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Query the corpus
		@param query string query
		@return query results as triple, 1) relevance, 2) string content, 3) content metadata
		~#
		method : public : Query(query : String) ~ Vector<Tuples.Triplet<FloatRef, String, Map<String, String>>> {
			# TODO metadata filters
			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("query", query);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}:query"), data, 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				# process results
				relevance_results := Vector->New()<Tuples.Triplet<FloatRef, String, Map<String, String>>>;
				chunks_array_json := response_json->Get("relevantChunks");;
				each(chunk_json in chunks_array_json) {
					relevance_score := chunk_json->Get("chunkRelevanceScore")->GetFloat();
					relevance_data := Url->Decode(chunk_json->FindElements("chunk/data/stringValue")->ToString());

					relevance_metadata := Map->New()<String, String>;
					metadata_array_json := chunk_json->FindElements("chunk/customMetadata");
					each(metadata_obj_json in metadata_array_json) {
						key := metadata_obj_json->Get("key")->GetString();
						value := metadata_obj_json->Get("stringValue")->GetString();

						relevance_metadata->Insert(key, value);
					}

					result := Tuples.Triplet->New(relevance_score, relevance_data, relevance_metadata)<FloatRef, String, Map<String, String>>;
					relevance_results->AddBack(result);
				};

				return relevance_results;
			};

			return Nil;	
		}

		#~
		Create a new document
		@param name document name
		@param metadata document metadata
		@param corpus corpus to attach document
		@return new Document
		~#
		function : Create(name : String, metadata : Collection.Map<String, String>, corpus : Corpus) ~ Document {
			metadata_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			if(metadata <> Nil) {
				metadata_keys_values := metadata->GetKeyValues()<Pair<String, String>>;
				each(metadata_key_value in metadata_keys_values) {
					metadata_json := JsonElement->New(JsonElement->JsonType->OBJECT);
					metadata_json->Insert("key", metadata_key_value->GetFirst());
					metadata_json->Insert("stringValue", metadata_key_value->GetSecond());

					metadata_array_json->Add(metadata_json);
				};
			};

			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("displayName", name);
			request_json->Insert("customMetadata", metadata_array_json);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			corpora_id := corpus->GetId();
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/{$corpora_id}/documents"), data, 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Document->New(response_json);
			};

			return Nil;	
		}

		#~
		Get existing document
		@param name document name
		@return existing document
		~#
		function : Get(name : String) ~ Document {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$name}"), 
				"application/json", headers);

			if(response <> Nil) {
				#response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Document->New(response_json);
			};

			return Nil;	
		}

		#~
		Get all existing documents
		@param corpus corpus of documents to list
		@return list of documents
		~#
		function : List(corpus : Corpus) ~ Collection.Vector<Document> {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");

			corpora_id := corpus->GetId();
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$corpora_id}/documents"), 
				"application/json", headers);

			if(response <> Nil) {
				
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				corpuses := Collection.Vector->New()<Document>;
				
				corporas_json := response_json->Get("documents");
				if(corporas_json <> Nil) {
					each(corpora_json in corporas_json) {
						corpuses->AddBack(Document->New(corpora_json));
					};
				};

				return corpuses;
			};

			return Nil;	
		}

		#~
		Delete existing document
		@return true if successful, false otherwise
		~#
		method : public : Delete() ~ Bool {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickDelete(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}"), 
				"application/json", headers);
			
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return false;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return false;
				};

				return true;
			};

			return false;	
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[name='";
			buffer += @name;

			buffer += "', display_name='"
			buffer += @display_name;

			buffer += "', create_time_str='"
			buffer += @create_time_str;

			buffer += "', update_time_str='"
			buffer += @update_time_str;

			buffer += "']";
			return buffer;
		}
	}

	#~
	Google Gemini document chunk
	~#
	class Chunk from OAuthEndPoint implements Stringify {
		@name : String;
		@data : String;
		@state : String;
		@create_time_str : String;
		@update_time_str : String;
		@metadata : Map<String, String>;

		New : private(request_json : JsonElement) {
			Parent();

			@name := request_json->Get("name")->GetString();
			@data := request_json->FindElements("data/stringValue")->GetString();
			@state := request_json->Get("state")->GetString();
			@create_time_str := request_json->Get("createTime")->GetString();
			@update_time_str := request_json->Get("updateTime")->GetString();

			@metadata := Map->New()<String, String>;
			metadata_array_json := request_json->Get("customMetadata");
			if(metadata_array_json <> Nil) {
				each(metadata_json in metadata_array_json) {
					name := metadata_json->Get("key")->GetString();
					value := metadata_json->Get("stringValue")->GetString();
					@metadata->Insert(name, value);
				};
			};
		}

		#~
		Get chunk ID
		@return chunk ID
		~#
		method : public : GetId() ~ String {
			return @name;
		}

		method : public : GetData() ~ String {
			return @data;
		}

		method : public : GetState() ~ String {
			return @state;
		}

		method : public : GetMetadata() ~  Map<String, String> {
			return @metadata;
		}

		#~
		Get creation time
		@return creation time
		~#
		method : public : GetCreateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@create_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Get update time
		@return update time
		~#
		method : public : GetUpdateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@update_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Create a new document
		@param value check string value
		@param metadata document metadata
		@param document document to attach chunk
		@return new Document
		~#
		function : Create(value : String, metadata : Map<String, String>, document : Document) ~ Chunk {
			metadata_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			if(metadata <> Nil) {
				metadata_keys_values := metadata->GetKeyValues()<Pair<String, String>>;
				each(metadata_key_value in metadata_keys_values) {
					metadata_json := JsonElement->New(JsonElement->JsonType->OBJECT);
					metadata_json->Insert("key", metadata_key_value->GetFirst());
					metadata_json->Insert("stringValue", metadata_key_value->GetSecond());

					metadata_array_json->Add(metadata_json);
				};
			};

			request_data_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_data_json->Insert("stringValue", value);

			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("data", request_data_json);
			
			request_json->Insert("customMetadata", metadata_array_json);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			doc_id := document->GetId();
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/{$doc_id}/chunks"), data, 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Chunk->New(response_json);
			};

			return Nil;
		}

		#~
		Get existing chunk
		@param name chunk name
		@return existing chunk
		~#
		function : Get(name : String) ~ Chunk {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$name}"), 
				"application/json", headers);

			if(response <> Nil) {
				#response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Chunk->New(response_json);
			};

			return Nil;	
		}

		#~
		Delete existing chunk
		@return true if successful, false otherwise
		~#
		method : public : Delete() ~ Bool {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickDelete(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}"), 
				"application/json", headers);
			
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return false;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return false;
				};

				return true;
			};

			return false;	
		}

		#~
		Get all existing chunks
		@param document document of documents to list
		@return list of chunks
		~#
		function : List(document : Document) ~ Collection.Vector<Chunk> {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");

			doc_id := document->GetId();
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$doc_id}/chunks"), "application/json", headers);
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				corpuses := Collection.Vector->New()<Chunk>;
				
				corporas_json := response_json->Get("chunks");
				if(corporas_json <> Nil) {
					each(corpora_json in corporas_json) {
						corpuses->AddBack(Chunk->New(corpora_json));
					};
				};

				return corpuses;
			};

			return Nil;	
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[name='";
			buffer += @name;

			buffer += "', state='"
			buffer += @state;

			buffer += "', data='"
			buffer += @data;

			buffer += "', create_time_str='"
			buffer += @create_time_str;

			buffer += "', update_time_str='"
			buffer += @update_time_str;

			buffer += "']";
			return buffer;
		}
	}

	class : private : OAuthEndPoint {
		@last_message : static : String;

		New() {}

		function : private : WriteNewToken() ~ Nil {
			scopes := ["https://www.googleapis.com/auth/cloud-platform", 
				"https://www.googleapis.com/auth/generative-language.retriever"];
			token := System.IO.Net.OAuth.OAuthClient->New("client_secret.json", scopes)->GetToken();

			token_str := token->GetAccessToken();
			date := System.Time.Date->New();
			date->AddSeconds(token->GetExpiresIn());
			date_str := date->GetUnixTime()->ToString();

			System.IO.Filesystem.FileWriter->WriteFile("client_secret.dat", "{$date_str}\r\n{$token_str}");
		}

		function : private : ReadToken() ~ String {
			client_secrets := System.IO.Filesystem.FileReader->ReadFile("client_secret.dat");
			if(client_secrets <> Nil) {
				client_secret_parts := client_secrets->Split("\r\n");
				if(client_secret_parts->Size() = 2){
					date_str := client_secret_parts[0];
					create_time := System.Time.Date->New(date_str->ToInt());
					create_time->AddMinutes(-2);

					if(create_time->Compare(System.Time.Date->New(true)) > 0) {
						token_str := client_secret_parts[1];
						return token_str;
					};
				};
			};

			return Nil;
		}

		function : GetToken() ~ String {		
			token := ReadToken();
			if(token = Nil) {
				WriteNewToken();
				token := ReadToken();
			};

			return token;
		}

		function : SetLastError(last_message : String) ~ Nil {
			@last_message := last_message;
		}

		#~
		Get the last error
		@return last error
		~#
		function : GetLastError() ~ String {
			return @last_message;
		}
	}

}