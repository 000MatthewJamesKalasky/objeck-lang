use Web.HTTP, Collection, System.IO.Filesystem, Data.JSON;

bundle API.Google.Gemini {
	class Model from EndPoint {
		@description : String;
		@display_name : String;
		@input_token_limit : Int;
		@name : String;
		@output_token_limit : Int;
		@generation_methods : Vector<String>;
		@temperature : Float;
		@top_k : Int;
		@top_p : Float;
		@version : String;

		New : private(description : String, display_name : String, input_token_limit : Int, 
				name : String, output_token_limit : Int, generation_methods : Vector<String>, 
				temperature : Float, top_k : Int, top_p : Float, version : String) {
			Parent();

			@description := description;
			@display_name := display_name;
			@input_token_limit := input_token_limit;
			@name := name;
			@output_token_limit := output_token_limit;
			@generation_methods := generation_methods;
			@temperature := temperature;
			@top_k := top_k;
			@top_p := top_p;
			@version := version;
		}
		
		function : Create(model_name : String, key : String) ~ Model { 
			models := ListModels(key);
			each(model in models) {
				if(model->GetName()->Equals(model_name)) {
					return model;
				};
			};

			return Nil;
		}

		function : ListModels(key : String) ~ Vector<Model> {
			models := Vector->New()<Model>;

			url := Url->New("https://generativelanguage.googleapis.com/v1beta/models?key={$key}");
			response := GetRequest(url);

			if(response <> Nil) {
				# response->ToString()->PrintLine();			
				models_json := response->Get("models");

				each(model_json in models_json) {
					description := model_json->Get("description")->GetString();
					display_name := model_json->Get("displayName")->GetString();
					input_token_limit := model_json->Get("inputTokenLimit")->GetInt();
					name := model_json->Get("name")->GetString();
					output_token_limit := model_json->Get("outputTokenLimit")->GetInt();

					generation_methods := Vector->New()<String>;
					generation_methods_json := model_json->Get("supportedGenerationMethods");
					each(generation_method_json in generation_methods_json) {
						generation_methods->AddBack(generation_method_json->GetString());
					}

					temperature := 0.9;
					temperature_json := model_json->Get("temperature");
					if(temperature_json <> Nil) {
						temperature := temperature_json->GetFloat();
					};

					top_k := 0;			
					top_k_json := model_json->Get("topK");
					if(top_k_json <> Nil) {
						top_k := top_k_json->GetInt();
					};

					top_p := 1.0;
					top_p_json := model_json->Get("topP");
					if(top_p_json <> Nil) {
						top_p := top_p_json->GetFloat();
					};
					version := model_json->Get("version")->GetString();

					models->AddBack(Model->New(description, display_name, input_token_limit, name, output_token_limit, 
						generation_methods, temperature, top_k, top_p, version));
				};
			};

			return models;
		}

		method : public : GenerateContent(contents : Vector<Content>, safety_settings : Vector<SafetySetting>, config : GenerationConfig, key : String) ~ ContentResponse {
			content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);

			each(content in contents) {
				parts := content->GetParts();
				content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

				content_obj_json->Insert("role", content->GetRole())

				parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(part in parts) {
					part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

					# text
					if(part->TypeOf(TextPart)) {
						text_part := part->As(TextPart);
						part_obj_json->Insert("text", text_part->GetText());
					}					
					else {
						binary_part := part->As(BinaryPart);

						inline_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
						inline_obj_json->Insert("mimeType", binary_part->GetMimeType());
						inline_obj_json->Insert("data", binary_part->GetBase64Data());
						
						part_obj_json->Insert("inlineData", inline_obj_json);
					};

					parts_obj_json->Add(part_obj_json);
				};
				content_obj_json->Insert("parts", parts_obj_json);

				content_array_json->Add(content_obj_json)
			};
			
			contents_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			contents_obj_json->Insert("contents", content_array_json);

# TODO: safetySettings and generationConfig
			# contents_obj_json->ToString()->PrintLine();

			url := Url->New("https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:generateContent?key={$key}");
			if(url->GetQueryParameters()->Has("key")) {			
				response := PostRequest(contents_obj_json, url);
				if(response <> Nil) {
					candidates_json := response->Get("candidates");
					each(candidate_json in candidates_json) {
						content_json := candidate_json->Get("content");
						parts_json := content_json->Get("parts");
						each(part_json in parts_json) {
							text_json := part_json->Get("text");
							role_json := content_json->Get("role");

							role_json->GetString()->Trim()->PrintLine();
							JsonElement->Decode(text_json->GetString()->Trim())->PrintLine();
							"---"->PrintLine();
						};
					};
				};
			};
					
			return Nil;
		}

		method : public : CountTokens(contents : Vector<Content>, key : String) ~ Int {
			return 0;
		}

		method : public : GetDescription() ~ String {
			return @description;
		}

		method : public : GetDisplayName() ~ String {
			return @display_name;
		}

		method : public : GetInputTokenLimit() ~ Int {
			return @input_token_limit;
		}

		method : public : GetName() ~ String {
			return @name;
		}

		method : public : GetOutputTokenLimit() ~ Int {
			return @output_token_limit;
		}

		method : public : GetGenerationMethods() ~ Vector<String> {
			return @generation_methods;
		}

		method : public : GetTemperature() ~ Float {
			return @temperature;
		}

		method : public : GetTopK() ~ Int {
			return @top_k;
		}

		method : public : GetTopP() ~ Float {
			return @top_p;
		}

		method : public : GetVersion() ~ String {
			return @version;
		}

		method : public : ToString() ~ String {
			buffer := "";

			buffer += "name='"
			buffer += @name;
			buffer += "', version="
			buffer += @version;
			buffer += "', description=\""
			buffer += @description;
			buffer += "\"\nmethods:\n\t"
			each(generation_method in @generation_methods) {
				buffer += generation_method;
				buffer += "\n\t";
			};

			return buffer;
		}
	}

	class Content from EndPoint {
		@parts : Vector<Part>;
		@role : String;

		New(role : String) {
			Parent();
			@role := role;
			@parts := Vector->New()<Part>;
		}

		New(role : String, parts : Vector<Part>) {
			Parent();
			@role := role;
			@parts := parts;
		}

		method : public : AddPart(part : Part) ~ Nil {
			@parts->AddBack(part);
		}

		method : public : GetParts() ~ Vector<Part> {
			return @parts;
		}

		method : public : GetRole() ~ String {
			return @role;
		}
	}

	class TextPart from Part {
		@text : String;

		New(text : String) {
			Parent();
			@text := text;
		}

		method : public : GetText() ~ String {
			return @text;
		}
	}

	class BinaryPart from Part {
		@data : Byte[];
		@mime_type : String;

		New(data : Byte[], mime_type : String) {
			Parent();

			@data := data;
			@mime_type := mime_type;
		}

		method : public : GetBase64Data() ~ String {
			return Encryption.Encrypt->Base64(@data);
		}

		method : public : GetMimeType() ~ String {
			return @mime_type;
		}
	}

	class Part {
		New() {}
	}

	class SafetySetting from EndPoint {
		New() {
			Parent();
		}
	}

	class GenerationConfig from EndPoint {
		New() {
			Parent();
		}
	}

	class ContentResponse {
		New() {}
	}

	#~
	Gemini endpoint
	~#
	class EndPoint {
		@last_message : static : String;
		@api_key : static : String;

		New() {}

		function : GetRequest(url : Url) ~ JsonElement {
			response := HttpsClient->QuickGet(url, "application/json");
			if(response <> Nil) {
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				
				# response->GetContent()->ToString()->PrintLine();			
				
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				error_json := response_json->FindElements("error/message")
				if(error_json <> Nil) {
					error_message := error_json->GetString();
					">>> Error: {$error_message} <<<"->ErrorLine();
					return Nil;
				};

				return response_json;
			};

			return Nil;
		}

		function : PostRequest(request : JsonElement, url : Url) ~ JsonElement {
			response := HttpsClient->QuickPost(url, request->ToString()->ToByteArray(), "application/json");
			if(response <> Nil) {
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				
				# response->GetContent()->ToString()->PrintLine();			
				
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				error_json := response_json->FindElements("error/message")
				if(error_json <> Nil) {
					error_message := error_json->GetString();
					">>> Error: {$error_message} <<<"->ErrorLine();
					return Nil;
				};

				return response_json;
			};

			return Nil;
		}

		function : GetApiKey() ~ String {
			if(@api_key = Nil) {
				token := FileReader->ReadFile("api_key.txt");
				if(token <> Nil) {
					@api_key := token->Trim();
				};
			};

			return @api_key;
		}

		function : SetLastError(last_message : String) ~ Nil {
			@last_message := last_message;

		}

		#~
		Get the last error
		@return last error
		~#
		function : GetLastError() ~ String {
			return @last_message;
		}
	}
}