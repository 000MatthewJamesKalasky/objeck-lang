use Web.HTTP, Collection, System.IO.Filesystem, Data.JSON;

bundle API.Google.Gemini {
	class Model from EndPoint {
		@description : String;
		@display_name : String;
		@input_token_limit : Int;
		@name : String;
		@output_token_limit : Int;
		@generation_methods : Vector<String>;
		@temperature : Float;
		@top_k : Int;
		@top_p : Float;
		@version : String;

		New : private(description : String, display_name : String, input_token_limit : Int, 
				name : String, output_token_limit : Int, generation_methods : Vector<String>, 
				temperature : Float, top_k : Int, top_p : Float, version : String) {
			Parent();

			@description := description;
			@display_name := display_name;
			@input_token_limit := input_token_limit;
			@name := name;
			@output_token_limit := output_token_limit;
			@generation_methods := generation_methods;
			@temperature := temperature;
			@top_k := top_k;
			@top_p := top_p;
			@version := version;
		}
		
		# TODO: tuned models
		function : ListModels(key : String) ~ Vector<Model> {
			models := Vector->New()<Model>;

			url := Url->New("https://generativelanguage.googleapis.com/v1/models?key={$key}");
			response := GetRequest(url);

			if(response <> Nil) {
				# response->ToString()->PrintLine();			
				models_json := response->Get("models");

				each(model_json in models_json) {
					description := model_json->Get("description")->GetString();
					display_name := model_json->Get("displayName")->GetString();
					input_token_limit := model_json->Get("inputTokenLimit")->GetInt();
					name := model_json->Get("name")->GetString();
					output_token_limit := model_json->Get("outputTokenLimit")->GetInt();

					generation_methods := Vector->New()<String>;
					generation_methods_json := model_json->Get("supportedGenerationMethods");
					each(generation_method_json in generation_methods_json) {
						generation_methods->AddBack(generation_method_json->GetString());
					}

					temperature := 0.9;
					temperature_json := model_json->Get("temperature");
					if(temperature_json <> Nil) {
						temperature := temperature_json->GetFloat();
					};

					top_k := 0;			
					top_k_json := model_json->Get("topK");
					if(top_k_json <> Nil) {
						top_k := top_k_json->GetInt();
					};

					top_p := 1.0;
					top_p_json := model_json->Get("topP");
					if(top_p_json <> Nil) {
						top_p := top_p_json->GetFloat();
					};
					version := model_json->Get("version")->GetString();

					models->AddBack(Model->New(description, display_name, input_token_limit, name, output_token_limit, 
						generation_methods, temperature, top_k, top_p, version));
				};
			};

			return models;
		}

		# TODO: tuned models
		function : Chat(model_name : String, key : String) ~ ChatSession {
			return Nil;
		}

		# TODO: tuned models
		function : GetModel(model_name : String, key : String) ~ Model {
			url := Url->New("https://generativelanguage.googleapis.com/v1/{$model_name}?key={$key}");
			model_json := GetRequest(url);

			if(model_json <> Nil) {
				# model_json->ToString()->PrintLine();

				description := model_json->Get("description")->GetString();
				display_name := model_json->Get("displayName")->GetString();
				input_token_limit := model_json->Get("inputTokenLimit")->GetInt();
				name := model_json->Get("name")->GetString();
				output_token_limit := model_json->Get("outputTokenLimit")->GetInt();

				generation_methods := Vector->New()<String>;
				generation_methods_json := model_json->Get("supportedGenerationMethods");
				each(generation_method_json in generation_methods_json) {
					generation_methods->AddBack(generation_method_json->GetString());
				}

				temperature := 0.9;
				temperature_json := model_json->Get("temperature");
				if(temperature_json <> Nil) {
					temperature := temperature_json->GetFloat();
				};

				top_k := 0;			
				top_k_json := model_json->Get("topK");
				if(top_k_json <> Nil) {
					top_k := top_k_json->GetInt();
				};

				top_p := 1.0;
				top_p_json := model_json->Get("topP");
				if(top_p_json <> Nil) {
					top_p := top_p_json->GetFloat();
				};
				version := model_json->Get("version")->GetString();

				return Model->New(description, display_name, input_token_limit, name, output_token_limit, 
					generation_methods, temperature, top_k, top_p, version);
				
			};

			return Nil;
		}

		# TODO: tuned models
		function : GenerateContent(model_name : String, content : Content, key : String) ~ Vector<Candidate> {
			return GenerateContent(model_name, content, Nil, Nil, key);
		}

		# TODO: tuned models
		function : GenerateContent(model_name : String, content : Content, safety_settings : Vector<Tuples.Pair<String, String>>, config : GenerationConfig, key : String) ~ Vector<Candidate> {
			contents := Vector->New()<Content>;
			contents->AddBack(content);

			return GenerateContent(model_name, contents, safety_settings, config, key);
		}

		# TODO: tuned models
		function : GenerateContent(model_name : String, contents : Vector<Content>, safety_settings : Vector<Tuples.Pair<String, String>>, config : GenerationConfig, key : String) ~ Vector<Candidate> {
			# contents
			content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			each(content in contents) {
				parts := content->GetParts();
				content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

				content_obj_json->Insert("role", content->GetRole())

				parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(part in parts) {
					part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

					# text
					if(part->TypeOf(TextPart)) {
						text_part := part->As(TextPart);
						part_obj_json->Insert("text", text_part->GetText());
					}					
					else {
						binary_part := part->As(BinaryPart);

						inline_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
						inline_obj_json->Insert("mimeType", binary_part->GetMimeType());
						inline_obj_json->Insert("data", binary_part->GetBase64Data());
						
						part_obj_json->Insert("inlineData", inline_obj_json);
					};

					parts_obj_json->Add(part_obj_json);
				};
				content_obj_json->Insert("parts", parts_obj_json);

				content_array_json->Add(content_obj_json)
			};
			contents_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			contents_obj_json->Insert("contents", content_array_json);

			# safety settings
			if(safety_settings <> Nil) {
				safety_setting_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(safety_setting in safety_settings) {
					safety_setting_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
					safety_setting_obj_json->Insert("category", safety_setting->GetFirst());
					safety_setting_obj_json->Insert("threshold", safety_setting->GetSecond());
					safety_setting_array_json->Add(safety_setting_obj_json);
				};
				contents_obj_json->Insert("safetySettings", safety_setting_array_json);
			};

			#~
			# TODO: GenerationConfig 
			if(config <> Nil) {
				#  generation configuration
				gen_config_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				contents_obj_json->Insert("generationConfig", gen_config_obj_json);
			};
			~#

			# contents_obj_json->ToString()->PrintLine();

			url := Url->New("https://generativelanguage.googleapis.com/v1/{$model_name}:generateContent?key={$key}");
			if(url->GetQueryParameters()->Has("key")) {			
				response := PostRequest(contents_obj_json, url);
				if(response <> Nil) {
					# response->ToString()->PrintLine();
					candidates := Vector->New()<Candidate>;
					
					candidates_json := response->Get("candidates");
					each(candidate_json in candidates_json) {						
						# general attributes
						role := candidate_json->Get("content")->Get("role")->GetString();
						finish_reason := candidate_json->Get("finishReason")->GetString();
						index := candidate_json->Get("index")->GetInt();

						# parts
						parts := Vector->New()<Part>;
						parts_json := candidate_json->Get("content")->Get("parts");
						each(part_json in parts_json) {
							part : Part;

							# text part
							if(part_json->Has("text")) {
								text_json := part_json->Get("text");
								part := TextPart->New(text_json->GetString());
							};

							# inline part
							if(part_json->Has("inlineData")) {
								inline_mime_type := part_json->FindElements("inlineData/mimeType")->GetString();
								inline_data := part_json->FindElements("inlineData/data")->GetString();
								part := BinaryPart->New(Encryption.Decrypt->Base64(inline_data), inline_mime_type);
							};

							parts->AddBack(part);
						};

						# safety ratings
						safety_ratings := Vector->New()<Tuples.Pair<String,String>>;
						safety_ratings_json := candidate_json->Get("safetyRatings");
						each(safety_rating_json in safety_ratings_json) {
							safety_category := safety_rating_json->Get("category")->GetString();
							safety_probability := safety_rating_json->Get("probability")->GetString();
							safety_rating := Tuples.Pair->New(safety_category, safety_probability)<String, String>;

							safety_ratings->AddBack(safety_rating);
						};

						candidates->AddBack(Candidate->New(index, role, finish_reason, parts, safety_ratings));
					};

					return candidates;
				};
			};
			
			return Nil;
		}

		# TODO: tuned models
		function : CountTokens(model_name : String, content : Content, key : String) ~ Int {
			contents := Vector->New()<Content>;
			contents->AddBack(content);

			return CountTokens(model_name, contents, key);
		}

		# TODO: tuned models
		function : CountTokens(model_name : String, contents : Vector<Content>, key : String) ~ Int {
			# contents
			content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			each(content in contents) {
				parts := content->GetParts();
				content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

				content_obj_json->Insert("role", content->GetRole())

				parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(part in parts) {
					part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

					# text
					if(part->TypeOf(TextPart)) {
						text_part := part->As(TextPart);
						part_obj_json->Insert("text", text_part->GetText());
					}					
					else {
						binary_part := part->As(BinaryPart);

						inline_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
						inline_obj_json->Insert("mimeType", binary_part->GetMimeType());
						inline_obj_json->Insert("data", binary_part->GetBase64Data());
						
						part_obj_json->Insert("inlineData", inline_obj_json);
					};

					parts_obj_json->Add(part_obj_json);
				};
				content_obj_json->Insert("parts", parts_obj_json);

				content_array_json->Add(content_obj_json)
			};
			contents_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			contents_obj_json->Insert("contents", content_array_json);

			url := Url->New("https://generativelanguage.googleapis.com/v1/{$model_name}:countTokens?key={$key}");
			if(url->GetQueryParameters()->Has("key")) {			
				response := PostRequest(contents_obj_json, url);
				if(response <> Nil) {
					# response->ToString()->PrintLine();
					return response->Get("totalTokens")->GetInt();
				};
			};

			return -1;
		}

		method : public : GetDescription() ~ String {
			return @description;
		}

		method : public : GetDisplayName() ~ String {
			return @display_name;
		}

		method : public : GetInputTokenLimit() ~ Int {
			return @input_token_limit;
		}

		method : public : GetName() ~ String {
			return @name;
		}

		method : public : GetOutputTokenLimit() ~ Int {
			return @output_token_limit;
		}

		method : public : GetGenerationMethods() ~ Vector<String> {
			return @generation_methods;
		}

		method : public : GetTemperature() ~ Float {
			return @temperature;
		}

		method : public : GetTopK() ~ Int {
			return @top_k;
		}

		method : public : GetTopP() ~ Float {
			return @top_p;
		}

		method : public : GetVersion() ~ String {
			return @version;
		}

		method : public : ToString() ~ String {
			buffer := "[";

			buffer += "name='"
			buffer += @name;

			buffer += "', display_name="
			buffer += @display_name;

			buffer += "', version="
			buffer += @version;

			buffer += "' input_token_limit="
			buffer += @input_token_limit;

			buffer += ", output_token_limit="
			buffer += @output_token_limit;

			buffer += ", description=\""
			buffer += @description;

			buffer += "\"\n\tmethods:"
			each(generation_method in @generation_methods) {
				buffer += "\n\t\t";
				buffer += generation_method;
			};
			buffer += ']';

			return buffer;
		}
	}

	class Content from EndPoint {
		@parts : Vector<Part>;
		@role : String;

		New(role : String) {
			Parent();
			@role := role;
			@parts := Vector->New()<Part>;
		}

		New(role : String, parts : Vector<Part>) {
			Parent();
			@role := role;
			@parts := parts;
		}

		method : public : AddPart(part : Part) ~ Content {
			@parts->AddBack(part);
			return @self;
		}

		method : public : GetParts() ~ Vector<Part> {
			return @parts;
		}

		method : public : GetRole() ~ String {
			return @role;
		}
	}

	class TextPart from Part {
		@text : String;

		New(text : String) {
			Parent();
			@text := text;
		}

		method : public : GetText() ~ String {
			return @text;
		}

		method : public : ToString() ~ String {
			return "[text='{$@text}']";
		}
	}

	class BinaryPart from Part {
		@data : Byte[];
		@mime_type : String;

		New(data : Byte[], mime_type : String) {
			Parent();

			@data := data;
			@mime_type := mime_type;
		}

		method : public : GetBase64Data() ~ String {
			return Encryption.Encrypt->Base64(@data);
		}

		method : public : GetMimeType() ~ String {
			return @mime_type;
		}

		method : public : ToString() ~ String {
			data_size := @data->Size();
			return "[data_size={$data_size}, mime_type='{$@mime_type}']";
		}
	}

	class Part {
		New() {}
		method : virtual : public : ToString() ~ String;
	}

	class GenerationConfig from EndPoint {
		New() {
			Parent();
		}
	}

	class Candidate {
		@index : Int;
		@role : String;
		@finish_reason : String;
		@parts : Vector<Part>;
		@safety_ratings : Vector<Tuples.Pair<String,String>>;
		
		New(index : Int, role : String, finish_reason : String, parts : Vector<Part>, safety_ratings : Vector<Tuples.Pair<String,String>>) {
			@index := index;
			@role := role;
			@finish_reason := finish_reason;
			@parts := parts;
			@safety_ratings := safety_ratings;
		}

		method : public : ToString() ~ String {
			buffer := "";

			buffer->Append("index='");
			buffer->Append(@index);

			buffer->Append("', role='");
			buffer->Append(@role);

			buffer->Append("', finish_reason='");
			buffer->Append(@finish_reason);

			buffer->Append("'\n\tparts:");
			each(part in @parts) {
				buffer->Append("\n\t\t");
				buffer->Append(part->ToString());
			};

			buffer->Append("'\n\tsafety_ratings:");
			each(safety_rating in @safety_ratings) {
				buffer->Append("\n\t\t");
				buffer->Append(safety_rating->ToString());
			};

			return buffer;
		}
	}

	class ChatSession {
		@session : Vector<Part>;

		New() {
			@session := Vector->New()<Part>;
		}

		method : public : AddPart(content : Part) ~ Nil {
		}

		method : public : GetSession() ~ Vector<Part> {
			return @session;
		}
	}

	#~
	Gemini endpoint
	~#
	class EndPoint {
		@last_message : static : String;
		@api_key : static : String;

		New() {}

		function : GetRequest(url : Url) ~ JsonElement {
			response := HttpsClient->QuickGet(url, "application/json");
			if(response <> Nil) {
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				
				# response->GetContent()->ToString()->PrintLine();
				
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				error_json := response_json->FindElements("error/message")
				if(error_json <> Nil) {
					error_message := error_json->GetString();
					">>> Error: {$error_message} <<<"->ErrorLine();
					return Nil;
				};

				return response_json;
			};

			return Nil;
		}

		function : PostRequest(request : JsonElement, url : Url) ~ JsonElement {
			response := HttpsClient->QuickPost(url, request->ToString()->ToByteArray(), "application/json");
			if(response <> Nil) {
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				
				# response->GetContent()->ToString()->PrintLine();			
				
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				error_json := response_json->FindElements("error/message")
				if(error_json <> Nil) {
					error_message := error_json->GetString();
					">>> Error: {$error_message} <<<"->ErrorLine();
					return Nil;
				};

				return response_json;
			};

			return Nil;
		}

		function : GetApiKey() ~ String {
			if(@api_key = Nil) {
				token := FileReader->ReadFile("api_key.txt");
				if(token <> Nil) {
					@api_key := token->Trim();
				};
			};

			return @api_key;
		}

		function : SetLastError(last_message : String) ~ Nil {
			@last_message := last_message;

		}

		#~
		Get the last error
		@return last error
		~#
		function : GetLastError() ~ String {
			return @last_message;
		}
	}
}