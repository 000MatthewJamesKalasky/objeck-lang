use System.IO.Net; 
use System.IO.File;
use System.Time;
use Collection.Generic;

#~
Provides support for conversions
~#	
bundle System.Time {
	#~
	Utilities for handling dates.
	~#
	class DateUtility {
		#~
		Parses a date from a String. Format <i>MM: </i>month, <i>dd: </i>day, <i>yy(yy): </i>year, <i>hh: </i>hour, <i>mm: </i>minutes and <i>ss: </i>seconds. 
		@param format date string format 
		@param date_str date
		@param gmt true is GMT, false otherwise
		@return Date instance
		~#
		function : Parse(date_str : String, format : String, gmt : Bool) ~ Date {
			parts := Map->New()<IntHolder, DatePart>;
		
			# month
			month := format->Find("MM");
			if(month > -1) {
				parts->Insert(month, DatePart->New(month, DatePart->Type->Month));
			};

			# day
			day := format->Find("dd");
			if(day > -1) {
				parts->Insert(day, DatePart->New(day, DatePart->Type->Day));
			};

			# year
			long_year_format := true;
			year := format->Find("yyyy");
			if(year > -1) {
				parts->Insert(year, DatePart->New(year, DatePart->Type->Year));
			}
			else {
				year := format->Find("yy");
				if(year > -1) {
					parts->Insert(year, DatePart->New(year, DatePart->Type->Year));
					long_year_format := false;
				};
			};
	
			# hour
			hours := format->Find("hh");
			if(hours > -1) {
				parts->Insert(hours, DatePart->New(hours, DatePart->Type->Hour));
			};

			# mins
			mins := format->Find("mm");
			if(mins > -1) {
				parts->Insert(mins, DatePart->New(mins, DatePart->Type->Min));
			};

			# secs
			secs := format->Find("ss");
			if(secs > -1) {
				parts->Insert(secs, DatePart->New(secs, DatePart->Type->Sec));
			};

			date_month := 0; date_day := 0; date_year := 0;
			date_hours := 0; date_mins := 0; date_secs := 0;
		
			offset := 0;
			values := parts->GetValues()<DatePart>;
			each(i : values) {
				part := values->Get(i);
				index := part->GetIndex();
				type := part->GetType();

				select(type) {
					label DatePart->Type->Month: {
						pos := month + offset + 1;
						if(pos > -1 & pos < date_str->Size()) { 
							if(date_str->Get(pos)->IsDigit()) {
								date_month := date_str->SubString(month + offset, 2)->ToInt();
							}
							else {
								date_month := date_str->SubString(month + offset, 1)->ToInt();
								offset -= 1;
							};
						};
					}

					label DatePart->Type->Day: {
						pos := day + offset + 1;
						if(pos > -1 & pos < date_str->Size()) { 
							if(date_str->Get(pos)->IsDigit()) {
								date_day := date_str->SubString(day + offset, 2)->ToInt();
							}
							else {
								date_day := date_str->SubString(day + offset, 1)->ToInt();
								offset -= 1;
							};
						};
					}
				
					label DatePart->Type->Year: {
						pos := year + offset;
						if(pos > -1 & pos < date_str->Size()) {
							if(long_year_format) {
								date_year := date_str->SubString(year + offset, 4)->ToInt();
							}	
							else {
								date_year := 2000;
								date_year += date_str->SubString(year + offset, 2)->ToInt();
							};
						};
					}

					label DatePart->Type->Hour: {
						pos := hours + offset + 1;
						if(pos > -1 & pos < date_str->Size()) { 
							if(date_str->Get(pos)->IsDigit()) {
								date_hours := date_str->SubString(hours + offset, 2)->ToInt();
							}
							else {
								date_hours := date_str->SubString(hours + offset, 1)->ToInt();
								offset -= 1;
							};
						};
					}

					label DatePart->Type->Min: {
						pos := mins + offset + 1;
						if(pos > -1 & pos < date_str->Size()) { 
							if(date_str->Get(pos)->IsDigit()) {
								date_mins := date_str->SubString(mins + offset, 2)->ToInt();
							}
							else {
								date_mins := date_str->SubString(mins + offset, 1)->ToInt();
								offset -= 1;
							};
						};
					}

					label DatePart->Type->Sec: {
						pos := secs + offset + 1;
						if(pos > -1 & pos < date_str->Size()) { 
							if(date_str->Get(pos)->IsDigit()) {
								date_secs := date_str->SubString(secs + offset, 2)->ToInt();
							}
							else {
								date_secs := date_str->SubString(secs + offset, 1)->ToInt();
								offset -= 1;
							};
						};
					}
				};
			};

			date := Date->New(date_day, date_month, date_year, gmt);
			date->AddHours(date_hours);
			date->AddMinutes(date_mins);
			date->AddSeconds(date_secs);

			return date;
		}
	}
	
	class DatePart {
		@index : Int;
		@type : Type;

		enum Type {
			Month,
			Day,
			Year,
			Hour,
			Min,
			Sec
		}

		New(index : Int, type : Type) {
			@index := index;
			@type := type;
		}

		method : public : GetType() ~ Type {
			return @type;
		}

		method : public : GetIndex() ~ Int {
			return @index;
		}
	}
}


#~
Web client support
~#
bundle Web.HTTP {
	#~
	URL parser, encoder and decoder
	~#
	class Url {
		@parsed : Bool;
		@url : String;
		@scheme : String;
		@host : String;
		@port : Int;
		@frag : String;
		@query : String;
		@path : String;

		#~
		Parsed URL into components
		@param url raw URL
		~#
		New(url : String) {
			@url := url;
			@port := -1;
			@parsed := ParseUrl(url);
		}

		#~
		Determines if given URL has been parsed correctly
		@return true if parsed, false otherwise
		~#
		method : public : Parsed() ~ Bool {
			return @parsed;
		}

		#~
		Gets original URL
		@return original URL
		~#
		method : public : GetUrl() ~ String {
			return @url;
		}

		#~
		Gets scheme
		@return scheme, Nil if not present
		~#
		method : public : GetScheme() ~ String {
			if(@parsed) {
				return @scheme;
			};

			return Nil;
		}

		#~
		Gets host
		@return host, Nil if not present
		~#
		method : public : GetHost() ~ String {
			if(@parsed) {
				return @host;
			};

			return Nil;
		}

		#~
		Gets scheme
		@return scheme, Nil if not present
		~#
		method : public : GetQuery() ~ String {
			if(@parsed) {
				return @query;
			};

			return Nil;
		}
		
		#~
		Gets port
		@return por, -1 if not present
		~#
		method : public : GetPort() ~ Int {
			if(@parsed) {
				return @port;
			};

			return -1;
		}

		#~
		Gets fragment
		@return fragment, Nil if not present
		~#
		method : public : GetFragment() ~ String {
			if(@parsed) {
				return @frag;
			};

			return Nil;
		}

		#~
		Gets path
		@return path, Nil if not present
		~#
		method : public : GetPath() ~ String {
			if(@parsed) {
				return @path;
			};

			return Nil;
		}

		method : ParseUrl(url : String) ~ Bool {
# "-- url='{$url}' --"->PrintLine();
			scheme_index := url->Find(':');
			if(scheme_index < 0) {
				"--- No scheme ---"->ErrorLine();
				return false;
			};
			@scheme := url->SubString(0, scheme_index);
# "\t-- scheme='{$@scheme}' --"->PrintLine();

			scheme_index += 1;
			rest := url->SubString(scheme_index, url->Size() - scheme_index);
# "\t-- rest='{$rest}' --"->PrintLine();

			if(rest->StartsWith("//")) {
				parts := rest->SubString(2, rest->Size() - 2)->Split("/");
				if(parts->Size() = 0) {
					ParsePart(rest->SubString(2, rest->Size() - 2), 0, false);
				}
				else {
					each(i : parts) {
						ParsePart(parts[i], i, i = parts->Size() - 1);
					};
				};
			}
			else {
				@path := rest;
			};

			return true;
		}

		method : ParsePart(part : String, index : Int, last : Bool) ~ Nil {
# "\t-- part='{$part}' --"->PrintLine();
			# host and port
			if(index = 0) {
				if(part->StartsWith('[') | part->StartsWith('(')) {
					@host := part;
				}
				else {
					port_index := part->Find(':');
					if(port_index > -1) {
						@host := part->SubString(port_index);
						port_index += 1;
						port_str := part->SubString(port_index, part->Size() - port_index);
						@port := port_str->ToInt();
					}
					else {
						@host := part;
					};
				};
			}
			# path, query and fragment
			else {
				if(@path = Nil) {
					@path := "";
				};
				@path += '/';

				# query and fragment
				if(last) {
					sub_part : String;
					frag_index := part->Find('#');
					if(frag_index > -1) {
						sub_part := part->SubString(frag_index);
# "\t-- sub_part='{$sub_part}' --"->PrintLine();							
						frag_index += 1;
						@frag := part->SubString(frag_index, part->Size() - frag_index);
					}
					else {
						sub_part := part;
					};

					query_index := sub_part->Find('?');
					if(query_index > -1) {
						# add to path
						if(query_index > 0)	{
							@path += sub_part->SubString(query_index);
						};
						query_index += 1;

						@query := sub_part->SubString(query_index, sub_part->Size() - query_index);
					}
					else {
						@path += sub_part;
					};
				}
				# path
				else {
					@path += part;
				};
			};
		}

		#~
		General encoding for HTML or XML strings
		@param str string to encode 
		@return encoded string 
		~#
		function : native : Encode(str : String) ~ String {
			buffer := String->New();
			each(i : str) {
				c := str->Get(i);
				select(c) {
					label ' ': {
						buffer->Append("%20");
					}

					label ';': {
						buffer->Append("%3B");
					}

					label '=': {
						buffer->Append("%3D");
					}

					label '$': {
						buffer->Append("%26");
					}

					label ',': {
						buffer->Append("%2C");
					}

					label '<': {
						buffer->Append("%3C");
					}

					label '>': {
						buffer->Append("%3E");
					}

					label '^': {
						buffer->Append("%5E");
					}

					label '`': {
						buffer->Append("%60");
					}

					label '\\': {
						buffer->Append("%5C");
					}

					label '[': {
						buffer->Append("%5B");
					}

					label ']': {
						buffer->Append("%5D");
					}

					label '{': {
						buffer->Append("%7B");
					}

					label '}': {
						buffer->Append("%7D");
					}

					label '|': {
						buffer->Append("%7C");
					}

					label '"': {
						buffer->Append("%22");
					}

					label ':': {
						buffer->Append("%3A");
					}

					label '/': {
						buffer->Append("%2F");
					}

					label '#': {
						buffer->Append("%23");
					}

					label '?': {
						buffer->Append("%3F");
					}

					label '&': {
						buffer->Append("%24");
					}

					label '@': {
						buffer->Append("%40");
					}

					label '%': {
						buffer->Append("%25");
					}

					label '+': {
						buffer->Append("%2B");
					}

					label '~': {
						buffer->Append("%7E");
					}

					other: {
						buffer->Append(c);
					}
				};
			};
			
			return buffer;
		}

		#~
		General decoding for HTML or XML strings		
		@param str encoded string
		@return decoded string
		~#
		function : native : Decode(str : String) ~ String {
			buffer := String->New();
			each(i : str) {
				c := str->Get(i);
				if(c = '%' & i + 2 < str->Size()) {
					value := "0x";
					value->Append(str->Get(i + 1));
					value->Append(str->Get(i + 2));
					buffer->Append(value->ToInt()->As(Char));
					i += 2;
				}
				else {
					buffer->Append(c);
				};
			};

			return buffer;
		}

		#~
		String representation of URL
		@return string representation of URL
		~#
		method : public : ToString() ~ String {
			buffer := "{$@url}\n";

			if(@scheme <> Nil) {
				buffer += "\tscheme='{$@scheme}'\n";
			};

			if(@host <> Nil) {
				buffer += "\thost='{$@host}'\n";
			};

			if(@path <> Nil) {
				buffer += "\tpath='{$@path}'\n";
			};
			
			if(@port > -1) {
				buffer += "\tport='{$@port}'\n";
			};

			if(@query <> Nil) {
				buffer += "\tquery='{$@query}'\n";
			};
			
			if(@frag <> Nil) {
				buffer += "\tfragment='{$@frag}'\n";
			};
					
			return buffer;			
		}
	}

	#~
	HTTP client
	~#
	class HttpClient {
		@headers : Hash<String, String>;
		@cookies_enabled : Bool;
		@cookies: Vector<String>;
		
		#~
		Default constructor 
		~#
		New() {
			@cookies_enabled := false;
			@cookies := Vector->New()<String>;
		}
		
		#~
		Gets the HTTP headers
		@return HTTP headers
		~#
		method : GetHeaders() ~ Hash<String, String> {
			return @headers;
		}
		
		#~
		Sets cookie support
		@param cookies_enabled true if cookies are enabled, false otherwise
		~#
		method : public : CookiesEnabled(cookies_enabled : Bool) ~ Nil {
			@cookies_enabled := cookies_enabled;
		}	
		
		#~
		Gets the cookies
		@return vector of cookies
		~#
		method : public : GetCookies() ~ Vector<String> {
			return @cookies;
		}	
		
		#~
		Sets a cookie
		@param cookie cookie nane and value
		~#
		method : public : SetCookie(cookie : String) ~ Nil {
			@cookies->AddBack(cookie);
		}	
		
		#~
		Performs a HTTP POST
		@param url URL
		@param data data to post
		@return vector of read strings
		~#
		method : public : Post(url : String, data : String) ~ Vector<String> {
			return Post(url, "text/plain", data);
		}
		
		#~
		Performs a HTTP POST
		@param url URL
		@param content_type content type
		@param data data to post
		@return vector of read strings
		~#
		method : public : Post(url : String, content_type : String, data : String) ~ Vector<String> {
			@headers := Hash->New()<String, String>;
					
			content := Vector->New()<String>;
			if(url->StartsWith("http://")) {
				url := url->SubString("http://"->Size(), url->Size() - "http://"->Size());
				address := "";
				location := "/";
				index := url->Find('/');
				port := "80";
				if(index > -1) {
				  address := url->SubString(index);
				  port_index := address->Find(':');
				  if(port_index > -1) {
				    port_index += 1;
				    port := address->SubString(port_index, address->Size() - port_index);
				    address := address->SubString(port_index - 1);
				  }
				  else {
				    location->Append(url->SubString(index + 1, url->Size() - index - 1));
				  };
				}
				else {
				  address := url;
				};
				
				socket := TCPSocket->New(address, port->ToInt());
				if(socket->IsOpen()) {
					post := "POST ";
					post->Append(location);
					post->Append(" HTTP/1.1\r\nHost: ");
					post->Append(address);
					post->Append("\r\nContent-Type: ");
					post->Append(content_type);
					post->Append("\r\nContent-Length: ");
					post->Append(data->Size()->ToString());
					post->Append("\r\n");
					if(@cookies_enabled & @cookies->Size() > 0) {
						post->Append("Cookie: ");
						each(i : @cookies) {
							post->Append(@cookies->Get(i));
							if(i + 1 < @cookies->Size()) {
								post->Append("; ");
							};
						};
						post->Append("\r\n");
					};
					post->Append("\r\n");					
					post->Append(data);
					socket->WriteString(post);
					
# post->PrintLine();					
					
					status_code := 500;
					status_line := socket->ReadString();
					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, 
							status_line->Size() - "HTTP/1."->Size() - 2);
						index := status_line->Find(' ');
						status_code := status_line->SubString(index)->ToInt();
					};
					
# status_line->PrintLine();
					
					if(status_code <> 500) {
					  # get @headers
						do {
							line := socket->ReadString();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();			
								@headers->Insert(name, value);
# IO.Console->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
							};
						}
						while(line->Size() > 0);

						# look for chunked blocks
						encoding : String := @headers->Find("Transfer-Encoding");
						if(encoding <> Nil & encoding->Equals("chunked")) {
							done := false;
							do {
								size_line := "0x";
								size_line->Append(socket->ReadString());
								chunk_size := size_line->ToInt();
								line := "";
								if(chunk_size > 0) {
									for(i := 0; i < chunk_size; i += 1;) {
										line->Append(socket->ReadByte());
									};
									socket->ReadString();
									content->AddBack(line);
								}
								else {
									done := true;
								};
							}
							while(done <> true);
						}
						else {
							length_header : String := @headers->Find("Content-Length");
							if(length_header <> Nil) {
								length := length_header->ToInt();
								buffer := Byte->New[length];
								for(i := 0; i < length; i += 1;) {
									buffer[i] := socket->ReadByte();
								};
								line := String->New(buffer);
								content->AddBack(line);
							};						
						};
					};
					socket->Close();
				};
			};
			
			return content;
		}

		#~
		Performs a HTTP GET and returns results as a String
		@param url URL
		@return output as one string
		~#
		method : public : GetAll(url : String) ~ String {
			document := "";
			
			lines := Get(url);
			if(lines = Nil) {
				return Nil;
			};

			each(i : lines) {
				document->Append(lines->Get(i)->As(String));
			};

			return document;
		}
		
		#~
		Performs a HTTP GET
		@param url URL
		@return vector of read strings
		~#
		method : public : Get(url : String) ~ Vector<String> {
			return Get(url, "text/plain");
		}
		
		#~
		Performs a HTTP GET
		@param url URL
		@param content_type content type
		@return vector of read strings
		~#
		method : public : Get(url : String, content_type : String) ~ Vector<String> {
			@headers := Hash->New()<String, String>;
			content := Vector->New()<String>;
			
			if(url->StartsWith("http://")) {
				url := url->SubString("http://"->Size(), url->Size() - "http://"->Size());
				address := "";
				location := "/";
				index := url->Find('/');
				port := "80";
				if(index > -1) {
				  address := url->SubString(index);
				  port_index := address->Find(':');
				  if(port_index > -1) {
				    port_index += 1;
				    port := address->SubString(port_index, address->Size() - port_index);
				    address := address->SubString(port_index - 1);
				  }
				  else {
				    location->Append(url->SubString(index + 1, url->Size() - index - 1));
				  };
				}
				else {
				  address := url;
				};
				
				socket := TCPSocket->New(address, port->ToInt());
				if(socket->IsOpen()) {
					get := "GET ";
					get->Append(location);
					get->Append(" HTTP/1.1\r\nHost: ");
					get->Append(address);
					get->Append("\r\n");
					if(@cookies_enabled & @cookies->Size() > 0) {
						get->Append("Cookie: ");
						each(i : @cookies) {
							get->Append(@cookies->Get(i));
							if(i + 1 < @cookies->Size()) {
								get->Append("; ");
							};
						};
						get->Append("\r\n");
					};					
					get->Append("\r\n");		
					
# IO.Console->Print("Get: |")->Print(get)->PrintLine("|");
					
					socket->WriteString(get);
					
					status_code := 500;
					status_line := socket->ReadString();
# status_line->PrintLine();					
					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, 
							status_line->Size() - "HTTP/1."->Size() - 2);
						index := status_line->Find(' ');
						status_code := status_line->SubString(index)->ToInt();
					};
# status_code->PrintLine();					
					if(status_code <> 500) {
						# get @headers
						do {
							line := socket->ReadString();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();
								
# IO.Console->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
								if(@cookies_enabled & name->Equals("Set-Cookie")) {
									offset := value->Find(';');
									if(offset > -1) {
										value := value->SubString(offset);
									};
									@cookies->AddBack(value);
# IO.Console->Print("cookie=")->PrintLine(value);									
								}
								else {
									@headers->Insert(name, value);
								};
							};
						}
						while(line->Size() > 0);
						
# IO.Console->Print("cookies: size=")->PrintLine(@cookies->Size());						

						# look for chunked blocks
						encoding : String := @headers->Find("Transfer-Encoding");
						if(encoding <> Nil & encoding->Equals("chunked")) {
							done := false;
							do {
								size_line := "0x";
								size_line->Append(socket->ReadString());
								chunk_size := size_line->ToInt();
								buffer := Byte->New[chunk_size];
								if(chunk_size > 0) {
									for(i := 0; i < chunk_size; i += 1;) {
										buffer[i] := socket->ReadByte();
									};
									# add line
									line := String->New(buffer);
									content->AddBack(line);
# line->PrintLine();																	
									# read '\r'
									socket->ReadByte(); 
									# read ''\n'
									socket->ReadByte();
									
								}
								else {
									# read '\r'
									socket->ReadByte(); 
									# read ''\n'
									socket->ReadByte();						
									done := true;
								};
							}
							while(done <> true);
						}
						else {
							length_header : String := @headers->Find("Content-Length");
							if(length_header <> Nil) {
								length := length_header->ToInt();
								buffer := Byte->New[length];
								for(i := 0; i < length; i += 1;) {
									buffer[i] := socket->ReadByte();
								};
								line := String->New(buffer);
								content->AddBack(line);
							}
							else {
								count := 0;
								do {
									line := socket->ReadString();
									if(line->Size() = 0) {
										count += 1;
									}
									else {
										content->AddBack(line);
										count := 0;
									};
								}
								while(count < 2);
							};					
						};
					};
					socket->Close();
				}
				else {
					return Nil;
				};
			};	
			
			return content;
		}
	}

	#~
	HTTPS client that uses a SSL secure socket
	~#
	class HttpsClient {
		@headers : Hash<String, String>;
		@cookies_enabled : Bool;
		@cookies: Vector<String>;
		@cert : String;
		
		#~
		Default constructor 
		~#
		New() {
			@cookies_enabled := false;
			@cookies := Vector->New()<String>;;
		}
		
		#~
		Gets the HTTP headers
		@return HTTP headers
		~#
		method : GetHeaders() ~ Hash<String, String> {
			return @headers;
		}
		
		#~
		Sets cookie support
		@param cookies_enabled true if cookies are enabled, false otherwise
		~#
		method : public : CookiesEnabled(cookies_enabled : Bool) ~ Nil {
			@cookies_enabled := cookies_enabled;
		}	
		
		#~
		Gets the cookies
		@return vector of cookies
		~#
		method : public : GetCookies() ~ Vector<String> {
			return @cookies;
		}	
		
		#~
		Sets a cookie
		@param cookie cookie nane and value
		~#
		method : public : SetCookie(cookie : String) ~ Nil {
			@cookies->AddBack(cookie);
		}	
		
		#~
		Performs a HTTP POST
		@param url URL
		@param data data to post
		@return vector of read strings
		~#
		method : public : Post(url : String, data : String) ~ Vector<String> {
			return Post(url, "text/plain", data);
		}
		
		#~
		Performs a HTTP POST
		@param url URL
		@param content_type content type
		@param data data to post
		@return vector of read strings
		~#
		method : public : Post(url : String, content_type : String, data : String) ~ Vector<String> {
			@headers := Hash->New()<String, String>;
			content := Vector->New()<String>;
			
			if(url->StartsWith("https://")) {
				url := url->SubString("https://"->Size(), url->Size() - "https://"->Size());
				address := "";
				location := "/";
				index := url->Find('/');
				port := "443";
				if(index > -1) {
				  address := url->SubString(index);
				  port_index := address->Find(':');
				  if(port_index > -1) {
				    port_index += 1;
				    port := address->SubString(port_index, address->Size() - port_index);
				    address := address->SubString(port_index - 1);
				  }
				  else {
				    location->Append(url->SubString(index + 1, url->Size() - index - 1));
				  };
				}
				else {
				  address := url;
				};
				
				socket := TCPSecureSocket->New(address, port->ToInt());
				if(socket->IsOpen()) {
					post := "POST ";
					post->Append(location);
					post->Append(" HTTP/1.1\r\nHost: ");
					post->Append(address);
					post->Append("\r\nContent-Type: ");
					post->Append(content_type);
					post->Append("\r\nContent-Length: ");
					post->Append(data->Size()->ToString());
					post->Append("\r\n");
					if(@cookies_enabled & @cookies->Size() > 0) {
						post->Append("Cookie: ");
						each(i : @cookies) {
							post->Append(@cookies->Get(i));
							if(i + 1 < @cookies->Size()) {
								post->Append("; ");
							};
						};
						post->Append("\r\n");
					};
					post->Append("\r\n");					
					post->Append(data);
					socket->WriteString(post);
					
# post->PrintLine();					
					
					status_code := 500;
					status_line := socket->ReadString();
					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, 
							status_line->Size() - "HTTP/1."->Size() - 2);
						index := status_line->Find(' ');
						status_code := status_line->SubString(index)->ToInt();
					};
					
# status_line->PrintLine();
					
					if(status_code <> 500) {
					  # get @headers
						do {
							line := socket->ReadString();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();			
								@headers->Insert(name, value);
# IO.Console->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
							};
						}
						while(line->Size() > 0);

						# look for chunked blocks
						encoding : String := @headers->Find("Transfer-Encoding");
						if(encoding <> Nil & encoding->Equals("chunked")) {
							done := false;
							do {
								size_line := "0x";
								size_line->Append(socket->ReadString());
								chunk_size := size_line->ToInt();
								line := "";
								if(chunk_size > 0) {
									for(i := 0; i < chunk_size; i += 1;) {
										line->Append(socket->ReadByte());
									};
									socket->ReadString();
									content->AddBack(line);
								}
								else {
									done := true;
								};
							}
							while(done <> true);
						}
						else {
							length_header : String := @headers->Find("Content-Length");
							if(length_header <> Nil) {
								length := length_header->ToInt();
								buffer := Byte->New[length];
								for(i := 0; i < length; i += 1;) {
									buffer[i] := socket->ReadByte();
								};
								line := String->New(buffer);
								content->AddBack(line);
							};						
						};
					};
					socket->Close();
				};
			};
			
			return content;
		}
		

		#~
		Performs a HTTP GET and returns results as a String
		@param url URL
		@return output as one string
		~#
		method : public : GetAll(url : String) ~ String {
			document := "";
			
			lines := Get(url);
			if(lines = Nil) {
				return Nil;
			};
			
			each(i : lines) {
				document->Append(lines->Get(i)->As(String));
			};

			return document;
		}

		#~
		Performs a HTTP GET
		@param url URL
		@return vector of read strings
		~#
		method : public : Get(url : String) ~ Vector<String> {
			return Get(url, "text/plain");
		}

		#~
		Gets the socket's X.509 certificate subject name
		@return certificate subject name
		~#
		method : public : GetCert() ~ String {
			return @cert;
		}
		
		#~
		Performs a HTTP GET
		@param url URL
		@param content_type content type
		@return vector of read strings
		~#
		method : public : Get(url : String, content_type : String) ~ Vector<String> {
			@headers := Hash->New()<String, String>;;
			content := Vector->New()<String>;
			
			if(url->StartsWith("https://")) {
				url := url->SubString("https://"->Size(), url->Size() - "https://"->Size());
				address := "";
				location := "/";
				index := url->Find('/');
				port := "443";
				if(index > -1) {
				  address := url->SubString(index);
				  port_index := address->Find(':');
				  if(port_index > -1) {
				    port_index += 1;
				    port := address->SubString(port_index, address->Size() - port_index);
				    address := address->SubString(port_index - 1);
				  }
				  else {
				    location->Append(url->SubString(index + 1, url->Size() - index - 1));
				  };
				}
				else {
				  address := url;
				};
				
				socket := TCPSecureSocket->New(address, port->ToInt());
				if(socket->IsOpen()) {
					get := "GET ";
					get->Append(location);
					get->Append(" HTTP/1.1\r\nHost: ");
					get->Append(address);
					get->Append("\r\n");
					if(@cookies_enabled & @cookies->Size() > 0) {
						get->Append("Cookie: ");
						each(i : @cookies) {
							get->Append(@cookies->Get(i));
							if(i + 1 < @cookies->Size()) {
								get->Append("; ");
							};
						};
						get->Append("\r\n");
					};					
					get->Append("\r\n");		
					
# IO.Console->Print("Get: |")->Print(get)->PrintLine("|");
					
					socket->WriteString(get);
					
					status_code := 500;
					status_line := socket->ReadString();
					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, 
							status_line->Size() - "HTTP/1."->Size() - 2);
						index := status_line->Find(' ');
						status_code := status_line->SubString(index)->ToInt();
					};
					
# status_code->PrintLine();					
					if(status_code <> 500) {
						# get @headers
						do {
							line := socket->ReadString();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();
								
# IO.Console->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
								if(@cookies_enabled & name->Equals("Set-Cookie")) {
									offset := value->Find(';');
									if(offset > -1) {
										value := value->SubString(offset);
									};
									@cookies->AddBack(value);
# IO.Console->Print("cookie=")->PrintLine(value);									
								}
								else {
									@headers->Insert(name, value);
								};
							};
						}
						while(line->Size() > 0);
						
# IO.Console->Print("cookies: size=")->PrintLine(@cookies->Size());						

						# look for chunked blocks
						encoding : String := @headers->Find("Transfer-Encoding");
						if(encoding <> Nil & encoding->Equals("chunked")) {
							done := false;
							do {
								size_line := "0x";
								size_line->Append(socket->ReadString());
								chunk_size := size_line->ToInt();
								buffer := Byte->New[chunk_size];
								if(chunk_size > 0) {
									for(i := 0; i < chunk_size; i += 1;) {
										buffer[i] := socket->ReadByte();
									};
									# add line
									line := String->New(buffer);
									content->AddBack(line);
# line->PrintLine();																	
									# read '\r'
									socket->ReadByte(); 
									# read ''\n'
									socket->ReadByte();
									
								}
								else {
									# read '\r'
									socket->ReadByte(); 
									# read ''\n'
									socket->ReadByte();						
									done := true;
								};
							}
							while(done <> true);
						}
						else {
							length_header : String := @headers->Find("Content-Length")->As(String);
							if(length_header <> Nil) {
								length := length_header->ToInt();
								buffer := Byte->New[length];
								for(i := 0; i < length; i += 1;) {
									buffer[i] := socket->ReadByte();
								};
								line := String->New(buffer);
								content->AddBack(line);
							}
							else {
								count := 0;
								do {
									line := socket->ReadString();
									if(line->Size() = 0) {
										count += 1;
									}
									else {
										content->AddBack(line);
										count := 0;
									};
								}
								while(count < 2);
							};							
						};
						@cert := socket->GetCert();
					};
					socket->Close();
				}
				else {
					return Nil;
				};
			};	
			
			return content;
		}
	}
}