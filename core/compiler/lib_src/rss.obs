use System.Time;
use Collection.Generic;
use System.IO.File;
use Data.XML;
use Web.HTTP;

#~
Provides support for RSS (-lib rss)
~#	
bundle Web.RSS {
	#~
	Reader for RSS feeds
	~#
	class RSSReader {
		@channel : RSSChannel;
		@posts : Vector<RSSPost>;
		@is_ok : Bool;

		#~
		Default constructor
		@param url RSS URL 
		~#
		New(url : String) { 
			xml := FetchXml(url);
			if(xml->Size() > 0) {
				parser := XmlParser->New(xml);
				if(parser->Parse()) {
					@channel := GetChannelData(parser);
					@posts := GetPosts(parser)<RSSPost>;
					@is_ok := true;
				};
			};
		}

		#~
		Get RSS channel meta data
		@return RSS meta data
		~#
		method : public : GetChannel() ~ RSSChannel {			
			return @channel;
		}

		#~
		Get RSS posts
		@return RSS posts
		~#
		method : public : GetPosts() ~ Vector<RSSPost> {
			if(@is_ok) {
				return @posts;
			};

			return Nil;
		}

		#~
		Checks to see if RSS XML was successfully retrieved and parsed
		@return true if success, false otherwise
		~#
		method : public : IsOk() ~ Bool {
			return @is_ok;
		}

		method : GetChannelData(parser : XmlParser) ~ RSSChannel {
			title := GetMatch("/rss/channel/title", parser);
			description := GetMatch("/rss/channel/description", parser);
			link := GetMatch("/rss/channel/link", parser);

			if(title <> Nil & description <> Nil & link <> Nil) {
				return RSSChannel->New(title, description, link);
			};

			return Nil;
		}

		method : GetPosts(parser : XmlParser) ~ Vector<RSSPost> {
			posts := Vector->New()<RSSPost>;

			items := parser->FindElements("/rss/channel/item");
			each(i : items) {
				item := items->Get(i);
				title := GetContent(item->GetFirstChild("title"));
				link := GetContent(item->GetFirstChild("link"));
				description := GetContent(item->GetFirstChild("description"));
				pubDate := GetContent(item->GetFirstChild("pubDate"));

				if(title <> Nil & description <> Nil & link <> Nil & pubDate <> Nil) {
					posts->AddBack(RSSPost->New(title, description, link, pubDate));
				}
				else if(title <> Nil & description <> Nil & link <> Nil) {
					posts->AddBack(RSSPost->New(title, description, link));
				};
			};

			return posts;
		}

		method : GetMatch(path : String, parser : XmlParser) ~ String {
			matches := parser->FindElements(path);
			if(matches->Size() > 0) {			
				return GetContent(matches->Get(0));
			};
			
			return Nil;
		}

		method : GetContent(elem : XmlElement) ~ String {
			if(elem = Nil) {
				return Nil;
			};

			cdata := elem->GetFirstChild("[cdata]");
			if(cdata <> Nil) {
				return cdata->GetContent();
			}
			else {
				return XmlElement->DecodeString(elem->GetContent());
			};	
		}

		method : FetchXml(path : String) ~ String {
			xml := "";

			if(path->StartsWith("http:")) {
				xml := HttpClient->New()->GetAll(path);
			}
			else if(path->StartsWith("https:")) {
				xml := HttpsClient->New()->GetAll(path);
			}
			else {
				xml := FileReader->ReadFile(path);
			};

			return xml;
		}
	}

	#~
	RSS channel meta data
	~#
	class RSSChannel {
		@title : String;
		@description : String;
		@link : String;

		New(title : String, description : String, link : String) {
			@title := title;
			@description := description;
			@link := link;
		}

		#~
		Gets the title
		@return title
		~#
		method : public : GetTitle() ~ String {
			return @title;
		}

		#~
		Gets the description
		@return description
		~#
		method : public : GetDescription() ~ String {
			return @description;
		}

		#~
		Gets the link
		@return link
		~#
		method : public : GetLink() ~ String {
			return @link;
		}
	}

	#~
	RSS post
	~#
	class RSSPost {
		@title : String;
		@description : String;
		@link : String;
		@date : String;

		New(title : String, description : String, link : String, date : String) {
			@title := title;
			@description := description;
			@link := link;
			@date := date;
		}

		New(title : String, description : String, link : String) {
			@title := title;
			@description := description;
			@link := link;
		}

		#~
		Gets the title
		@return title
		~#
		method : public : GetTitle() ~ String {
			return @title;
		}

		#~
		Gets the description
		@return description
		~#
		method : public : GetDescription() ~ String {
			return @description;
		}

		#~
		Gets the link
		@return link
		~#
		method : public : GetLink() ~ String {
			return @link;
		}

		#~
		Gets the date string
		@return date string
		~#
		method : public : GetDate() ~ String {
			return @date;
		}
	}
}

#~
Provides support for conversions (-lib rss)
~#	
bundle System.Time {
	#~
	Utilities for handling dates.
	~#
	class DateUtility {
		#~
		Parses a date from a String. Format <i>MM: </i>month, <i>dd: </i>day, <i>yy(yy): </i>year, <i>hh: </i>hour, <i>mm: </i>minutes and <i>ss: </i>seconds. 
		@param format date string format 
		@param date_str date
		@param gmt true is GMT, false otherwise
		@return Date instance
		~#
		function : Parse(date_str : String, format : String, gmt : Bool) ~ Date {
			parts := Map->New()<IntHolder, DatePart>;
		
			# month
			month := format->Find("MM");
			if(month > -1) {
				parts->Insert(month, DatePart->New(month, DatePart->Type->Month));
			};

			# day
			day := format->Find("dd");
			if(day > -1) {
				parts->Insert(day, DatePart->New(day, DatePart->Type->Day));
			};

			# year
			long_year_format := true;
			year := format->Find("yyyy");
			if(year > -1) {
				parts->Insert(year, DatePart->New(year, DatePart->Type->Year));
			}
			else {
				year := format->Find("yy");
				if(year > -1) {
					parts->Insert(year, DatePart->New(year, DatePart->Type->Year));
					long_year_format := false;
				};
			};
	
			# hour
			hours := format->Find("hh");
			if(hours > -1) {
				parts->Insert(hours, DatePart->New(hours, DatePart->Type->Hour));
			};

			# mins
			mins := format->Find("mm");
			if(mins > -1) {
				parts->Insert(mins, DatePart->New(mins, DatePart->Type->Min));
			};

			# secs
			secs := format->Find("ss");
			if(secs > -1) {
				parts->Insert(secs, DatePart->New(secs, DatePart->Type->Sec));
			};

			date_month := 0; date_day := 0; date_year := 0;
			date_hours := 0; date_mins := 0; date_secs := 0;
		
			offset := 0;
			values := parts->GetValues()<DatePart>;
			each(i : values) {
				part := values->Get(i);
				index := part->GetIndex();
				type := part->GetType();

				select(type) {
					label DatePart->Type->Month: {
						pos := month + offset + 1;
						if(pos > -1 & pos < date_str->Size()) { 
							if(date_str->Get(pos)->IsDigit()) {
								date_month := date_str->SubString(month + offset, 2)->ToInt();
							}
							else {
								date_month := date_str->SubString(month + offset, 1)->ToInt();
								offset -= 1;
							};
						};
					}

					label DatePart->Type->Day: {
						pos := day + offset + 1;
						if(pos > -1 & pos < date_str->Size()) { 
							if(date_str->Get(pos)->IsDigit()) {
								date_day := date_str->SubString(day + offset, 2)->ToInt();
							}
							else {
								date_day := date_str->SubString(day + offset, 1)->ToInt();
								offset -= 1;
							};
						};
					}
				
					label DatePart->Type->Year: {
						pos := year + offset;
						if(pos > -1 & pos < date_str->Size()) {
							if(long_year_format) {
								date_year := date_str->SubString(year + offset, 4)->ToInt();
							}	
							else {
								date_year := 2000;
								date_year += date_str->SubString(year + offset, 2)->ToInt();
							};
						};
					}

					label DatePart->Type->Hour: {
						pos := hours + offset + 1;
						if(pos > -1 & pos < date_str->Size()) { 
							if(date_str->Get(pos)->IsDigit()) {
								date_hours := date_str->SubString(hours + offset, 2)->ToInt();
							}
							else {
								date_hours := date_str->SubString(hours + offset, 1)->ToInt();
								offset -= 1;
							};
						};
					}

					label DatePart->Type->Min: {
						pos := mins + offset + 1;
						if(pos > -1 & pos < date_str->Size()) { 
							if(date_str->Get(pos)->IsDigit()) {
								date_mins := date_str->SubString(mins + offset, 2)->ToInt();
							}
							else {
								date_mins := date_str->SubString(mins + offset, 1)->ToInt();
								offset -= 1;
							};
						};
					}

					label DatePart->Type->Sec: {
						pos := secs + offset + 1;
						if(pos > -1 & pos < date_str->Size()) { 
							if(date_str->Get(pos)->IsDigit()) {
								date_secs := date_str->SubString(secs + offset, 2)->ToInt();
							}
							else {
								date_secs := date_str->SubString(secs + offset, 1)->ToInt();
								offset -= 1;
							};
						};
					}
				};
			};

			date := Date->New(date_day, date_month, date_year, gmt);
			date->AddHours(date_hours);
			date->AddMinutes(date_mins);
			date->AddSeconds(date_secs);

			return date;
		}
	}
	
	class DatePart {
		@index : Int;
		@type : Type;

		enum Type {
			Month,
			Day,
			Year,
			Hour,
			Min,
			Sec
		}

		New(index : Int, type : Type) {
			@index := index;
			@type := type;
		}

		method : public : GetType() ~ Type {
			return @type;
		}

		method : public : GetIndex() ~ Int {
			return @index;
		}
	}
}