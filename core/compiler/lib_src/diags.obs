use Collection.Generic;
use System.API;

#~
Support for basic code diagnostics
~#
bundle System.Diagnostics {
	class Proxy {
		@lib_proxy : static : DllProxy;

		function : GetDllProxy() ~ DllProxy {
			if(@lib_proxy = Nil) {
				@lib_proxy := DllProxy->New("libobjk_diags");
			};

			return @lib_proxy;
		}
	}

	#~
	Parsers source for analysis
	~#
	class Analyzer {
		#~
		Parsers source file for analysis
		@param src_file file to parse
		@return object instance used for analysis
		~#
		function : ParseFile(src_file : String) ~ AnalysisResult {
			array_args := Base->New[3];
			array_args[0] := IntHolder->New();
			array_args[1] := IntHolder->New();
			array_args[2] := src_file;
			Proxy->GetDllProxy()->CallFunction("diag_parse_file", array_args);
			
			handle := array_args[0]->As(IntHolder);
			is_parsed := array_args[1]->As(IntHolder);
			return AnalysisResult->New(handle->Get(), is_parsed->Get() = 1 ? true : false);
		}

		#~
		Parsers text for analysis
		@param src_str text to parse
		@return object instance used for analysis
		~#
		function : ParseText(src_str : String) ~ AnalysisResult {
			array_args := Base->New[3];
			array_args[0] := IntHolder->New();
			array_args[1] := IntHolder->New();
			array_args[2] := src_str;
			Proxy->GetDllProxy()->CallFunction("diag_parse_text", array_args);
			
			handle := array_args[0]->As(IntHolder);
			is_parsed := array_args[1]->As(IntHolder);
			return AnalysisResult->New(handle->Get(), is_parsed->Get() = 1 ? true : false);
		}
	}

	#~
	Analysis results
	~#
	class AnalysisResult {
		@handle : Int;
		@is_parsed : Bool;
		@symbols_result : Result;
		@diagnostics_results : Result[];
		@references_results : Result[];

		New(handle : Int, is_parsed : Bool) {
			Parent();
			@handle := handle;
			@is_parsed := is_parsed;
		}

		#~
		Check to see if source was parsed
		@return true if parsed, false otherwise
		~#
		method : public : IsParsed() ~ Bool {
			return @is_parsed;
		}

		#~
		Get source code analysis symbols
		@return analysis symbols
		~#
		method : public : GetSymbols() ~ Result {
			if(@symbols_result = Nil) {
				array_args := Base->New[1];
				array_args[0] := @self;
				Proxy->GetDllProxy()->CallFunction("diag_get_symbols", array_args);
			};
			
			return @symbols_result;
		}

		#~
		Get parse and analysis errors
		@param sys_path system library path
		@return analysis errors, Nil of no errors
		~#
		method : public : GetDiagnostics(sys_path : String) ~ Result[] {
			if(@diagnostics_results = Nil) {
				array_args := Base->New[2];
				array_args[0] := @self;
				array_args[1] := sys_path;
				Proxy->GetDllProxy()->CallFunction("diag_get_diagnosis", array_args);
			};

			return @diagnostics_results;
		}
		
		#~
		Get references specified symbol
		@param line line of symbol
		@param pos character position of symbol
		@param sys_path system library path
		@return symbol references, Nil of none found
		~#
		method : public : FindReferences(line : Int, pos : Int, sys_path : String) ~ Result[] {
			array_args := Base->New[4];
			array_args[0] := @self;
			array_args[1] := IntHolder->New(line);
			array_args[2] := IntHolder->New(pos);
			array_args[3] := sys_path;
			Proxy->GetDllProxy()->CallFunction("diag_find_references", array_args);
			
			return @references_results;
		}

		#~
		Finds symbol deceleration
		@param line line of symbol
		@param pos character position of symbol
		@param sys_path system library path
		@return symbol deceleration, Nil of none found
		~#
		method : public : FindDeclaration(line : Int, pos : Int, sys_path : String) ~ Result {
			array_args := Base->New[5];
			array_args[0] := Nil;
			array_args[1] := @self;
			array_args[2] := IntHolder->New(line);
			array_args[3] := IntHolder->New(pos);
			array_args[4] := sys_path;
			Proxy->GetDllProxy()->CallFunction("diag_find_declaration", array_args);
			
			return array_args[0]->As(Result);
		}
		
		#~
		Release native resources, required for clean up.
		~#
		method : public : Release() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntHolder->New(@handle);
			Proxy->GetDllProxy()->CallFunction("diag_tree_release", array_args);
		}
	}

	#~
	Analysis results
	~#
	class Result {
		consts Kind {
			# Severity
			ERROR := 101,
			WARN := 102,
			INFO := 103,
			# symbols
			NAMESPACE := 203,
			CLASS := 205,
			ENUM := 210,
			METHOD := 206,
			VARIABLE  := 213,
			# other
			UNKN := 0
		}

		@name : String;
		@kind : Result->Kind;
		@results : Result[];
		@desc : String;
		@start_line : Int;
		@start_pos : Int;
		@end_line : Int;
		@end_pos : Int;

		New(handle : Int) {
		}

		method : public : GetStartLine() ~ Int {
			return @start_line;
		}

		method : public : GetStartPosition() ~ Int {
			return @start_pos;
		}

		method : public : GetEndLine() ~ Int {
			return @end_line;
		}

		method : public : GetEndPosition() ~ Int {
			return @end_pos;
		}

		method : public : GetKind() ~ Result->Kind {
			return @kind;
		}

		method : public : GetName() ~ String {
			return @name;
		}

		method : public : GetResults() ~ Result[] {
			return @results;
		}

		method : public : ToString() ~ String {
			kind := @kind->As(Int);
			return "name='{$@name}', kind={$kind}, start_line={$@start_line}, start_pos={$@start_pos}, end_line={$@end_line}, end_pos={$@end_pos}";
		}
	}
}