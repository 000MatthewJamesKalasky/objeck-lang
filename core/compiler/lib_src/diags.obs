use Collection.Generic;
use System.API;

#~
Support for linting, code metrics and diagnostics
~#
bundle System.Diagnostics {
	class Proxy {
		@lib_proxy : static : DllProxy;

		function : GetDllProxy() ~ DllProxy {
			if(@lib_proxy = Nil) {
				@lib_proxy := DllProxy->New("libobjk_diags");
			};

			return @lib_proxy;
		}
	}

	#~
	Parsers and analyzers source
	~#
	class Analyzer {
		function : ParseFile(src_file : String, sys_path : String) ~ AnalysisTree {
			array_args := Base->New[4];
			array_args[0] := IntHolder->New();
			array_args[1] := IntHolder->New();
			array_args[2] := src_file;
			array_args[3] := sys_path;
			Proxy->GetDllProxy()->CallFunction("diag_parse_file", array_args);
			
			handle := array_args[0]->As(IntHolder);
			is_parsed := array_args[1]->As(IntHolder);
			return AnalysisTree->New(handle->Get(), is_parsed->Get() = 1 ? true : false);
		}

		function : ParseString(src_str : String, sys_path : String) ~ AnalysisTree {
			array_args := Base->New[4];
			array_args[0] := IntHolder->New();
			array_args[1] := IntHolder->New();
			array_args[2] := src_str;
			array_args[3] := sys_path;
			Proxy->GetDllProxy()->CallFunction("diag_parse_string", array_args);
			
			handle := array_args[0]->As(IntHolder);
			is_parsed := array_args[1]->As(IntHolder);
			return AnalysisTree->New(handle->Get(), is_parsed->Get() = 1 ? true : false);
		}
	}

	#~
	Analysis results
	~#
	class AnalysisTree {
		@handle : Int;
		@is_parsed : Bool;

		New(handle : Int, is_parsed : Bool) {
			Parent();
			@handle := handle;
			@is_parsed := is_parsed;
		}

		method : public : IsParsed() ~ Bool {
			return @is_parsed;
		}

		method : public : GetDiagnostics() ~ Symbol {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := @self;
			Proxy->GetDllProxy()->CallFunction("diag_tree_diagnostics", array_args);
			
			return Nil;
		}
		
		method : public : GetSymbol(line : Int, pos : Int) ~ Symbol {
			array_args := Base->New[4];
			array_args[0] := Nil;
			array_args[1] := @self;
			array_args[2] := IntHolder->New(line);
			array_args[3] := IntHolder->New(pos);
			Proxy->GetDllProxy()->CallFunction("diag_tree_get_symbol", array_args);
			
			return Nil;
		}

		method : public : GetSymbols() ~ Symbol {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := @self;
			Proxy->GetDllProxy()->CallFunction("diag_tree_get_symbols", array_args);
			
			return array_args[0]->As(Symbol);
		}

		method : public : Release() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntHolder->New(@handle);
			Proxy->GetDllProxy()->CallFunction("diag_tree_release", array_args);
		}
	}

	#~
	Analysis symbols
	~#
	class Symbol {
		consts Kind {
			NAMESPACE := 2,
			CLASS := 5,
			METHOD := 6,
			UNKN := 0
		}

		@name : String;
		@kind : Symbol->Kind;
		@symbols : Symbol[];
		@desc : String;
		@start_line : Int;
		@start_pos : Int;
		@end_line : Int;
		@end_pos : Int;

		New(handle : Int) {
		}

		method : public : GetStartLine() ~ Int {
			return @start_line;
		}

		method : public : GetStartPosition() ~ Int {
			return @start_pos;
		}

		method : public : GetEndLine() ~ Int {
			return @end_line;
		}

		method : public : GetEndPosition() ~ Int {
			return @end_pos;
		}

		method : public : GetKind() ~ Symbol->Kind {
			return @kind;
		}

		method : public : GetName() ~ String {
			return @name;
		}

		method : public : GetSymbols() ~ Symbol[] {
			return @symbols;
		}

		method : public : ToString() ~ String {
			kind := @kind->As(Int);
			return "name='{$@name}', kind={$kind}, start_line={$@start_line}, start_pos={$@start_pos}, end_line={$@end_line}, end_pos={$@end_pos}";
		}
	}
}