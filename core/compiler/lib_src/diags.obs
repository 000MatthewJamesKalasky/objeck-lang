use Collection.Generic;
use System.API;

#~
Support for basic code diagnostics
~#
bundle System.Diagnostics {
	class Proxy {
		@lib_proxy : static : DllProxy;

		function : GetDllProxy() ~ DllProxy {
			if(@lib_proxy = Nil) {
				@lib_proxy := DllProxy->New("libobjk_diags");
			};

			return @lib_proxy;
		}
	}

	#~
	Parsers source for analysis
	~#
	class Analyzer {
		#~
		Parsers source file for analysis
		@param src_file file to parse
		@return object instance used for analysis
		~#
		function : ParseFile(src_file : String) ~ Analysis {
			array_args := Base->New[3];
			array_args[0] := IntHolder->New();
			array_args[1] := IntHolder->New();
			array_args[2] := src_file;
			Proxy->GetDllProxy()->CallFunction("diag_parse_file", array_args);
			
			handle := array_args[0]->As(IntHolder);
			is_parsed := array_args[1]->As(IntHolder);
			return Analysis->New(handle->Get(), is_parsed->Get() = 1 ? true : false);
		}

		#~
		Parsers text for analysis
		@param src_strs named text to parse, name/content
		@return object instance used for analysis
		~#
		function : ParseText(src_strs : String[,]) ~ Analysis {
			dims := src_strs->Size();
			size := dims[0];

			names := String->New[size]; 
			texts := String->New[size];

			for(i := 0; i < size; i += 1;) {
				names[i] := src_strs[i,0];
				texts[i] := src_strs[i,1];
			};

			array_args := Base->New[4];
			array_args[0] := IntHolder->New();
			array_args[1] := IntHolder->New();
			array_args[2] := StringArrayHolder->New(names);
			array_args[3] := StringArrayHolder->New(texts);
			Proxy->GetDllProxy()->CallFunction("diag_parse_text", array_args);
			
			handle := array_args[0]->As(IntHolder);
			is_parsed := array_args[1]->As(IntHolder);
			return Analysis->New(handle->Get(), is_parsed->Get() = 1 ? true : false);
		}
	}

	#~
	Analysis results
	~#
	class Analysis {
		@handle : Int;
		@is_parsed : Bool;
		@symbols_result : Result;
		@diagnostics_results : Result[];
		@references_results : Result[];

		New(handle : Int, is_parsed : Bool) {
			Parent();
			@handle := handle;
			@is_parsed := is_parsed;
		}

		#~
		Check to see if source was parsed
		@return true if parsed, false otherwise
		~#
		method : public : IsParsed() ~ Bool {
			return @is_parsed;
		}

		#~
		Get source code analysis symbols
		@param uri file uri
		@param sys_path system library path
		@return analysis symbols
		~#
		method : public : GetSymbols(uri : String, sys_path : String) ~ Result {
			if(@symbols_result = Nil) {
				array_args := Base->New[3];
				array_args[0] := @self;
				array_args[1] := uri;
				array_args[2] := sys_path;
				Proxy->GetDllProxy()->CallFunction("diag_get_symbols", array_args);
			};
			
			return @symbols_result;
		}

		#~
		Get parse and analysis errors
		@param sys_path system library path
		@return analysis errors, Nil of no errors
		~#
		method : public : GetDiagnostics(sys_path : String) ~ Result[] {
			if(@diagnostics_results = Nil) {
				array_args := Base->New[2];
				array_args[0] := @self;
				array_args[1] := sys_path;
				Proxy->GetDllProxy()->CallFunction("diag_get_diagnosis", array_args);
			};

			return @diagnostics_results;
		}
		
		#~
		Get references specified symbol
		@param line line of symbol
		@param pos character position of symbol
		@param sys_path system library path
		@return symbol references, Nil of none found
		~#
		method : public : FindReferences(line : Int, pos : Int, sys_path : String) ~ Result[] {
			array_args := Base->New[4];
			array_args[0] := @self;
			array_args[1] := IntHolder->New(line);
			array_args[2] := IntHolder->New(pos);
			array_args[3] := sys_path;
			Proxy->GetDllProxy()->CallFunction("diag_find_references", array_args);
			
			return @references_results;
		}

		#~
		Get signature definitions
		@param line line of symbol
		@param pos character position of symbol
		@param var_str variable string name
		@param mthd_str method string name
		@param sys_path system library path
		@return symbol references, Nil of none found
		~#
		method : public : SignatureHelp(line : Int, pos : Int, var_str : String, mthd_str : String, sys_path : String) ~ Result {
			array_args := Base->New[7];
			array_args[0] := Nil;
			array_args[1] := @self;
			array_args[2] := IntHolder->New(line);
			array_args[3] := IntHolder->New(pos);
			array_args[4] := var_str;
			array_args[5] := mthd_str;
			array_args[6] := sys_path;
			Proxy->GetDllProxy()->CallFunction("diag_signature_help", array_args);
			
			return array_args[0]->As(Result);
		}
		
		#~	
		Get completion options
		@param line line of symbol
		@param pos character position of symbol
		@param var_str variable string name
		@param mthd_str method string name
		@param sys_path system library path
		@return symbol references, Nil of none found
		~#
		method : public : Completion(line : Int, pos : Int, var_str : String, mthd_str : String, sys_path : String) ~ Result {
			array_args := Base->New[7];
			array_args[0] := Nil;
			array_args[1] := @self;
			array_args[2] := IntHolder->New(line);
			array_args[3] := IntHolder->New(pos);
			array_args[4] := var_str;
			array_args[5] := mthd_str;
			array_args[6] := sys_path;
			Proxy->GetDllProxy()->CallFunction("diag_completion_help", array_args);
			
			return array_args[0]->As(Result);
		}

		#~
		Finds symbol deceleration
		@param line line of symbol
		@param pos character position of symbol
		@param sys_path system library path
		@return symbol deceleration, Nil of none found
		~#
		method : public : FindDeclaration(line : Int, pos : Int, sys_path : String) ~ Result {
			array_args := Base->New[5];
			array_args[0] := Nil;
			array_args[1] := @self;
			array_args[2] := IntHolder->New(line);
			array_args[3] := IntHolder->New(pos);
			array_args[4] := sys_path;
			Proxy->GetDllProxy()->CallFunction("diag_find_declaration", array_args);
			
			return array_args[0]->As(Result);
		}
		
		#~
		Release native resources, required for clean up.
		~#
		method : public : Release() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntHolder->New(@handle);
			Proxy->GetDllProxy()->CallFunction("diag_tree_release", array_args);
		}
	}

	#~
	Generic analysis result
	~#
	class Result {
		#~
		Analysis type
		~#
		consts Kind {
			ERROR := 101,
			WARN := 102,
			INFO := 103,

			NAMESPACE := 203,
			CLASS := 205,
			ENUM := 210,
			METHOD := 206,
			VARIABLE  := 213,
			
			UNKN := 0
		}

		@name : String;
		@code : Int;
		@kind : Result->Kind;
		@results : Result[];
		@desc : String;
		@start_line : Int;
		@start_pos : Int;
		@end_line : Int;
		@end_pos : Int;

		New(handle : Int) {
		}

		#~
		Get start line
		@return start line
		~#
		method : public : GetStartLine() ~ Int {
			return @start_line;
		}

		#~
		Get start position
		@return start position
		~#
		method : public : GetStartPosition() ~ Int {
			return @start_pos;
		}

		#~
		Get end line
		@return end line
		~#
		method : public : GetEndLine() ~ Int {
			return @end_line;
		}

		#~
		Get end position
		@return end position
		~#
		method : public : GetEndPosition() ~ Int {
			return @end_pos;
		}

		#~
		Get result kind
		@return result kind
		~#
		method : public : GetKind() ~ Result->Kind {
			return @kind;
		}

		#~
		Get result name
		@return result name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Gets the code
		@return code
		~#
		method : public : GetCode() ~ Int {
			return @code;
		}

		#~
		Get child results
		@return child results
		~#
		method : public : GetResults() ~ Result[] {
			return @results;
		}

		#~
		Result to string
		@return string representation
		~#
		method : public : ToString() ~ String {
			kind := @kind->As(Int);
			return "name='{$@name}', kind={$kind}, start_line={$@start_line}, start_pos={$@start_pos}, end_line={$@end_line}, end_pos={$@end_pos}";
		}
	}
}