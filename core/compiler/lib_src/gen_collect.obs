#~
Generic backed collections
~#	
bundle Collection.Generic {
	# TODO: hash

	#~
	Growable stack of generics
	~#
	class Stack<H> {
		@values : Vector<H>;
		
		#~
		Default constructor 
		~#
		New() {
			@values := Vector->New()<H>	;
		}
		
		#~
		Pushes a value onto the stack
		@value value to push
		~#
		method : public: Push(value : H) ~ Nil {
			@values->AddBack(value);
		}
		
		#~
		Pushes a value from the stack
		@return popped valued, Nil if stack is empty
		~#
		method : public : Pop() ~ H {
			if(@values->Size() > 0) {
				value : H := @values->Get(@values->Size() - 1);
				@values->RemoveBack();
				
				return value;
			};
			
			return Nil;
		}
		
		#~
		Check the top of the stack
		@return value on the top of stack, Nil if stack is empty
		~#
		method : public: Top() ~ H {
			if(@values->Size() > 0) {
				return @values->Get(@values->Size() - 1);
			};
			
			return Nil;
		}

		#~
		Clears the vector
		~#
		method : public : Empty() ~ Nil {
			@values->Empty();
		}
		
		#~
		Checks to see if the vector is empty
		@return true if empty, false otherwise
		~#
		method : public: IsEmpty() ~ Bool {
			return @values->Size() = 0;
		}

		#~
		Size of stack
		@return size of stack
		~#
		method : public: Size() ~ Int {
			return @values->Size();
		}
	}

	#~
	Queue of generics
	~#
	class Queue<H> {
		@queue : List<H>;
		
		#~
		Default constructor 
		~#
		New() {
			@queue := List->New()<H>;
		}
		
		#~
		Adds a value to the back of the queue
		@param value value to add
		~#
		method : public: Add(value : H) ~ Nil {
			@queue->AddBack(value);
		}
		
		#~
		Removes a value from the front of the queue
		@return value removed
		~#
		method : public : Remove() ~ H {
			if(@queue->Size() > 0) {
				value := @queue->Front();
				@queue->RemoveFront();
				return value;
			};
			
			return Nil;
		}
		
		#~
		Get the value from the head of the queue
		@return head value, Nil if queue is empty
		~#
		method : public: Head() ~ H {
			if(@queue->Size() > 0) {
				return @queue->Front();
			};
			
			return Nil;
		}
		
		#~
		Clears the queue
		~#
		method : public : Empty() ~ Nil {
			@queue->Empty();
		}
		
		#~
		Checks to see if the queue is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @queue->IsEmpty();
		}
		
		#~
		Size of queue
		@return size of queue
		~#
		method : public : Size() ~ Int {
			return @queue->Size();
		}
	}

	#~
	List of comparable generics
	~#
	class CompareList<H : Compare> {
		@size : Int;
		@head : CompareListNode<H>;
		@tail : CompareListNode<H>;
		@cursor : CompareListNode<H>;

		#~
		Default constructor 
		~#
		New() {
			@size := 0;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : native : AddBack(value : H) ~ Nil {
			node := CompareListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@tail->SetNext(node);
			 	node->SetPrevious(@tail);	
				@tail := node;
			};
			@size += 1;
		}
	
		#~
		Removes the last value from the list
		~#
		method : public : RemoveBack() ~ Nil {
			Forward();
			Remove();
		}

		#~
		Adds a value to the front
		@param value value to prepend 
		~#
		method : public : native : AddFront(value : H) ~ Nil {
			node := CompareListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@head->SetPrevious(node);
				node->SetNext(@head);
				@head := node;
				@cursor := @head;
			};
			@size += 1;
		}
		
		#~
		Removes the first value from the list
		~#
		method : public : RemoveFront() ~ Nil {
			Rewind();
			Remove();
		}

		#~
		Moves the pointer to the start of the list
		~#
		method : public : Rewind() ~ Nil {
			@cursor := @head;
		}		

		#~
		Moves the pointer to the end of the list
		~#
		method : public : Forward() ~ Nil {
			@cursor := @tail;
		}		

		#~
		Advances the pointer
		~#
		method : public : Next() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetNext();
			};
		}

		#~
		Retreats the pointer
		~#
		method : public : Previous() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetPrevious();
			};
		}

		#~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			if(@cursor <> Nil) {
				return @cursor->Get();
			};

			return Nil;
		}

		#~
		Searches for a value
		@param value value to check for
		@return true if value is found, false otherwise
		~#
		method : public : Has(value : H) ~ Bool {
			start := @head;
			end := @tail;
			
			while(start <> end) {
				if(value->Compare(start->Get()) = 0) {
					return true;
				}
				else if(value->Compare(end->Get()) = 0) {
					return true;
				};
				
				start := start->GetNext();
				end := end->GetPrevious();
			};
			
			if(start <> Nil & value->Compare(start->Get()) = 0) {
				return true;
			}; 

			return false;
		}
		
		#~
		Finds a value in the list and sets the pointer
		@param value value to search for
		@return value that's found
		~#
		method : public : Find(value : H) ~ H {
			@cursor := @head;
			while(@cursor <> Nil) {
				if(value->Compare(@cursor->Get()) = 0) {
					return value;
				};
				@cursor := @cursor->GetNext();
			};
			
			return Nil;
		}
		
		#~
		Inserts a value into the list based upon the pointer location
		@param value value to insert
		~#
		method : public : native : Insert(value : H) ~ Bool {
			if(@cursor <> Nil & @head <> Nil & @tail <> Nil) {
				node := CompareListNode->New(value)<H>;
				if(@cursor = @head & @cursor = @tail) {
			 		@head->SetNext(node);
			 		node->SetPrevious(@head);
			 		@tail := node;
			 	}
			 	else if(@cursor = @tail) {
			 		@tail->SetNext(node);
			 		node->SetPrevious(@tail);
			 		@tail := node;
			 	}
			 	else {
					@cursor->GetNext()->SetPrevious(node);
					node->SetNext(@cursor->GetNext());
			 		@cursor->SetNext(node);
			 		node->SetPrevious(@cursor);
			 	};
			 	@size += 1;
				
				return true;
			}
			else if(@head = Nil & @tail = Nil) {
				AddBack(value);
				return true;
			};
			
			return false;
		}
		
		#~
		Removes the element at the pointer position
		~#
		method : public : native : Remove() ~ Nil {
			if(@cursor <> Nil) {
				if(@cursor->GetPrevious() <> Nil) {
					@cursor->GetPrevious()->SetNext(@cursor->GetNext());
				};
				if(@cursor = @head & @cursor = @tail) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 		@tail := @cursor;
			 	}
			 	else if(@cursor = @head) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 	}
			 	else if(@cursor = @tail) {
			 		@cursor := @cursor->GetNext();
			 		@tail := @cursor;
			 	}
			 	else {
			 		@cursor := @cursor->GetNext();
			 	};
				@size -= 1;
			};
		}

		#~
		Checks to see if the pointer is at the front of the list
		@return true if pointer is at the front of the list, false otherwise
		~#
		method : public : IsFront() ~ Bool {
			return @cursor = @head;
		}		
		
		#~
		Checks to see if the pointer is at the end of the list
		@return true if pointer is at the end of the list, false otherwise
		~#
		method : public : IsBack() ~ Bool {
			return @cursor = @tail;
		}
		
		#~
		Checks to see the pointer can be advanced
		@return true if pointer can be advanced, false otherwise
		~#
		method : public : More() ~ Bool {
			return @cursor <> Nil;
		}

		#~
		Returns the first element in the list
		@return first element in the list, 0.0 if the list is empty
		~#
		method : public : Front() ~ H {
			if(@head <> Nil) {
				return @head->Get();
			};

			return Nil;
		}

		#~
		Returns the last element in the list
		@return last element in the list, 0.0 if the list is empty
		~#
		method : public : Back() ~ H {
			if(@tail <> Nil) {
				return @tail->Get();
			};

			return Nil;
		}

		#~
		Clears the list
		~#
		method : public : Empty() ~ Nil {
			@size := 0;
			@head := Nil;
			@tail := Nil;
			@cursor := Nil;
		}
		
		#~
		Checks to see if the list is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Size of list
		@return size of list
		~#
		method : public : Size() ~ Int {
			return @size;
		}
	}

	class CompareListNode<H : Compare> {
		@value : H;
		@next : CompareListNode<H>;
		@previous: CompareListNode<H>;

		New(value : H) {
			@value := value;
		}
		
		method : public : Set(value : H) ~ Nil {
			@value := value;
		}
	
		method : public : Get() ~ H {
			return @value;
		}

		method : public : SetNext(next :  CompareListNode<H>) ~ Nil {
			@next := next;
		}
	
		method : public : GetNext() ~ CompareListNode<H> {
			return @next;
		}

		method : public : SetPrevious(previous :  CompareListNode<H>) ~ Nil {
			@previous := previous;
		}
	
		method : public : GetPrevious() ~ CompareListNode<H> {
			return @previous;
		}
	}

	#~
	List of generics
	~#
	class List<H> {
		@size : Int;
		@head : ListNode<H>;
		@tail : ListNode<H>;
		@cursor : ListNode<H>;

		#~
		Default constructor 
		~#
		New() {
			@size := 0;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : native : AddBack(value : H) ~ Nil {
			node := ListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@tail->SetNext(node);
			 	node->SetPrevious(@tail);	
				@tail := node;
			};
			@size += 1;
		}
	
		#~
		Removes the last value from the list
		~#
		method : public : RemoveBack() ~ Nil {
			Forward();
			Remove();
		}

		#~
		Adds a value to the front
		@param value value to prepend 
		~#
		method : public : native : AddFront(value : H) ~ Nil {
			node := ListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@head->SetPrevious(node);
				node->SetNext(@head);
				@head := node;
				@cursor := @head;
			};
			@size += 1;
		}
		
		#~
		Removes the first value from the list
		~#
		method : public : RemoveFront() ~ Nil {
			Rewind();
			Remove();
		}

		#~
		Moves the pointer to the start of the list
		~#
		method : public : Rewind() ~ Nil {
			@cursor := @head;
		}		

		#~
		Moves the pointer to the end of the list
		~#
		method : public : Forward() ~ Nil {
			@cursor := @tail;
		}		

		#~
		Advances the pointer
		~#
		method : public : Next() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetNext();
			};
		}

		#~
		Retreats the pointer
		~#
		method : public : Previous() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetPrevious();
			};
		}

		#~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			if(@cursor <> Nil) {
				return @cursor->Get();
			};

			return Nil;
		}
				
		#~
		Inserts a value into the list based upon the pointer location
		@param value value to insert
		~#
		method : public : native : Insert(value : H) ~ Bool {
			if(@cursor <> Nil & @head <> Nil & @tail <> Nil) {
				node := ListNode->New(value)<H>;
				if(@cursor = @head & @cursor = @tail) {
			 		@head->SetNext(node);
			 		node->SetPrevious(@head);
			 		@tail := node;
			 	}
			 	else if(@cursor = @tail) {
			 		@tail->SetNext(node);
			 		node->SetPrevious(@tail);
			 		@tail := node;
			 	}
			 	else {
					@cursor->GetNext()->SetPrevious(node);
					node->SetNext(@cursor->GetNext());
			 		@cursor->SetNext(node);
			 		node->SetPrevious(@cursor);
			 	};
			 	@size += 1;
				
				return true;
			}
			else if(@head = Nil & @tail = Nil) {
				AddBack(value);
				return true;
			};
			
			return false;
		}
		
		#~
		Removes the element at the pointer position
		~#
		method : public : native : Remove() ~ Nil {
			if(@cursor <> Nil) {
				if(@cursor->GetPrevious() <> Nil) {
					@cursor->GetPrevious()->SetNext(@cursor->GetNext());
				};
				if(@cursor = @head & @cursor = @tail) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 		@tail := @cursor;
			 	}
			 	else if(@cursor = @head) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 	}
			 	else if(@cursor = @tail) {
			 		@cursor := @cursor->GetNext();
			 		@tail := @cursor;
			 	}
			 	else {
			 		@cursor := @cursor->GetNext();
			 	};
				@size -= 1;
			};
		}

		#~
		Checks to see if the pointer is at the front of the list
		@return true if pointer is at the front of the list, false otherwise
		~#
		method : public : IsFront() ~ Bool {
			return @cursor = @head;
		}		
		
		#~
		Checks to see if the pointer is at the end of the list
		@return true if pointer is at the end of the list, false otherwise
		~#
		method : public : IsBack() ~ Bool {
			return @cursor = @tail;
		}
		
		#~
		Checks to see the pointer can be advanced
		@return true if pointer can be advanced, false otherwise
		~#
		method : public : More() ~ Bool {
			return @cursor <> Nil;
		}

		#~
		Returns the first element in the list
		@return first element in the list, 0.0 if the list is empty
		~#
		method : public : Front() ~ H {
			if(@head <> Nil) {
				return @head->Get();
			};

			return Nil;
		}

		#~
		Returns the last element in the list
		@return last element in the list, 0.0 if the list is empty
		~#
		method : public : Back() ~ H {
			if(@tail <> Nil) {
				return @tail->Get();
			};

			return Nil;
		}

		#~
		Clears the list
		~#
		method : public : Empty() ~ Nil {
			@size := 0;
			@head := Nil;
			@tail := Nil;
			@cursor := Nil;
		}
		
		#~
		Checks to see if the list is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Size of list
		@return size of list
		~#
		method : public : Size() ~ Int {
			return @size;
		}
	}

	class ListNode<H> {
		@value : H;
		@next : ListNode<H>;
		@previous: ListNode<H>;

		New(value : H) {
			@value := value;
		}
		
		method : public : Set(value : H) ~ Nil {
			@value := value;
		}
	
		method : public : Get() ~ H {
			return @value;
		}

		method : public : SetNext(next :  ListNode<H>) ~ Nil {
			@next := next;
		}
	
		method : public : GetNext() ~ ListNode<H> {
			return @next;
		}

		method : public : SetPrevious(previous :  ListNode<H>) ~ Nil {
			@previous := previous;
		}
	
		method : public : GetPrevious() ~ ListNode<H> {
			return @previous;
		}
	}
	
	#~
	Growable array of generics
	~#
	class Vector<H> {
		@values : H[];
		@size : Int;
		
		#~
		Default constructor 
		~#
		New() {
			@values := H->New[8];
			@size := 0;
		}
		
		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : H[]) {
			@values := H->New[values->Size() + values->Size() / 2];
			@size := values->Size();
			Runtime->Copy(@values, 0, values, 0, @size);
 		}

		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : Vector<H>) {
			@values := values->ToArray();
			@size := values->Size();
		}

		method : Expand() ~ Nil {
			if(@size >= @values->Size()) {
				temp : H[] := H->New[@size * 2];
				Runtime->Copy(temp, 0, @values, 0, @size);
				@values := temp;
			};
		}

		#~
		Swap two values in the vector
		@param a first value
		@param b second value
		@return true if values were swapped
		~#
		method : public : Swap(a : Int, b : Int) ~ Bool {
			if(a < -1 | b < -1 | a > @size | b > @size) {
				return false;
			};
			
			temp := @values[a];
			@values[a] := @values[b];
			@values[b] := temp;
			
			return true;
		}

		#~
		Adds a vector of values to the end of the vector
		@param values values to append 
		~#
		method : public : AddBack(values : Vector<H>) ~ Nil {
			max := values->Size() + @size;
			if(max >= @values->Size()) {
				temp : H[] := H->New[max + max / 2];
				Runtime->Copy(temp, 0, @values, 0, @size);
				@values := temp;
			};
			
			temp := values->ToArray();
			Runtime->Copy(@values, @size, temp, 0, temp->Size());
			@size := max;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : AddBack(value : H) ~ Nil {
			Expand();
			@values[@size] := value;
			@size += 1;
		}

		#~
		Removes the last value
		@return value
		~#
		method : public : RemoveBack() ~ H {
			if(@size > 0) {
				@size -= 1;
				return @values[@size];
			};
	
			return Nil;
		}
		
		#~
		Removes an indexed value
		@param i index
		@return value
		~#
		method : public : Remove(i : Int) ~ H {
			if(i > -1 & i < @size) {
				temp := H->New[@values->Size()];
				Runtime->Copy(temp, 0, @values, 0, i);
				Runtime->Copy(temp, i, @values, i + 1, @size - i - 1);
				value := @values[i];
				@values := temp;
				@size -= 1;
				return value;
			};
			
			return Nil;
		}

		#~
		Gets an indexed value
		@param index index
		@return value
		~#
		method : public : Get(index : Int) ~ H {
			if(index > -1 & index < @size) {
				return @values[index];
			};

			return Nil;
		}

		#~
		Sets an indexed value
		@param value value
		@param index index
		~#
		method : public : Set(value : H, index : Int) ~ Bool {
			if(index > -1 & index < @size) {
				@values[index] := value;
				return true;
			};
			
			return false;
		}

		#~
		Clears the vector
		~#
		method : public : Empty() ~ Nil {
			@values := H->New[8];
			@size := 0;
		}
		
		#~
		Size of vector
		@return size of vector
		~#
		method : public : Size() ~ Int {
			return @size;
		}
		
		#~
		Checks to see if the vector is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Converts the vector into an object array
		@return object array
		~#
		method : public : ToArray() ~ H[] {
			array : H[] := H->New[@size];
			Runtime->Copy(array, 0, @values, 0, @size);
			return array;
		}
	}

	#~
	Growable array of comparable generics
	~#
	class CompareVector<H : Compare> {
		@values : H[];
		@size : Int;
		
		#~
		Default constructor 
		~#
		New() {
			@values := H->New[8];
			@size := 0;
		}
		
		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : H[]) {
			@values := H->New[values->Size() + values->Size() / 2];
			@size := values->Size();
			Runtime->Copy(@values, 0, values, 0, @size);
 		}

		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : Vector<H>) {
			@values := values->ToArray();
			@size := values->Size();
		}

		method : Expand() ~ Nil {
			if(@size >= @values->Size()) {
				temp : H[] := H->New[@size * 2];
				Runtime->Copy(temp, 0, @values, 0, @size);
				@values := temp;
			};
		}

		#~
		Swap two values in the vector
		@param a first value
		@param b second value
		@return true if values were swapped
		~#
		method : public : Swap(a : Int, b : Int) ~ Bool {
			if(a < -1 | b < -1 | a > @size | b > @size) {
				return false;
			};
			
			temp := @values[a];
			@values[a] := @values[b];
			@values[b] := temp;
			
			return true;
		}

		#~
		Adds a vector of values to the end of the vector
		@param values values to append 
		~#
		method : public : AddBack(values : Vector<H>) ~ Nil {
			max := values->Size() + @size;
			if(max >= @values->Size()) {
				temp : H[] := H->New[max + max / 2];
				Runtime->Copy(temp, 0, @values, 0, @size);
				@values := temp;
			};
			
			temp := values->ToArray();
			Runtime->Copy(@values, @size, temp, 0, temp->Size());
			@size := max;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : AddBack(value : H) ~ Nil {
			Expand();
			@values[@size] := value;
			@size += 1;
		}

		#~
		Removes the last value
		@return value
		~#
		method : public : RemoveBack() ~ H {
			if(@size > 0) {
				@size -= 1;
				return @values[@size];
			};
	
			return Nil;
		}
		
		#~
		Removes an indexed value
		@param i index
		@return value
		~#
		method : public : Remove(i : Int) ~ H {
			if(i > -1 & i < @size) {
				temp := H->New[@values->Size()];
				Runtime->Copy(temp, 0, @values, 0, i);
				Runtime->Copy(temp, i, @values, i + 1, @size - i - 1);
				value := @values[i];
				@values := temp;
				@size -= 1;
				return value;
			};
			
			return Nil;
		}

		#~
		Gets an indexed value
		@param index index
		@return value
		~#
		method : public : Get(index : Int) ~ H {
			if(index > -1 & index < @size) {
				return @values[index];
			};

			return Nil;
		}

		#~
		Sets an indexed value
		@param value value
		@param index index
		~#
		method : public : Set(value : H, index : Int) ~ Bool {
			if(index > -1 & index < @size) {
				@values[index] := value;
				return true;
			};
			
			return false;
		}

		#~
		Clears the vector
		~#
		method : public : Empty() ~ Nil {
			@values := H->New[8];
			@size := 0;
		}
		
		#~
		Size of vector
		@return size of vector
		~#
		method : public : Size() ~ Int {
			return @size;
		}
		
		#~
		Checks to see if the vector is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Sorts the values in the vector
		~#	
		method : public : native : Sort() ~ Nil {
			a : H[] := @values;
			b : H[] := H->New[@size];
			MergeSort(0, @size - 1, a, b);
		}
		
		method : MergeSort(low : Int, hi : Int, a : H[], b : H[]) ~ Nil {
			if(low < hi) {
				mid := (low + hi) / 2;
				MergeSort(low, mid, a, b);
				MergeSort(mid + 1, hi, a, b);
				Merge(low, mid, hi, a, b);
			};	
		}
		
		method : native : Merge(low : Int, mid : Int, hi : Int, a : H[], b : H[]) ~ Nil {
			# copy both halves of a to auxiliary array b
			for(i := low; i <= hi; i += 1;) {
				b[i] := a[i];
			};

			i := low; 
			j := mid + 1; 
			k := low;
			
			# copy back next-greatest element at each time
			while(i <= mid & j <= hi) {
				if(b[i]->Compare(b[j]) < 0 | b[i]->Compare(b[j]) = 0) {
					a[k] := b[i];
					k := k + 1;
					i += 1;
				}
				else {
					a[k] := b[j];
					k := k + 1;
					j := j + 1;
				};
			};
			
			# copy back remaining elements of first half (if any)
			while(i <= mid) {
				a[k] := b[i];
				k := k + 1;
				i += 1;
			};
		}

		#~
		Finds a given value in the vector via linear search
		@param value value to search for
		@return index of found value, -1 if not found
		~#
		method : public : Find(value : H) ~ Int {
         for(i := 0; i < @size; i += 1;) {
            if(@values[i]->Compare(value) = 0) {
               return i;
            };
         };

         return -1;
      }
		
		#~
		Performs a binary search O(log n)
		@param value value to search for
		@return index of found value, -1 if not found
		~#
		method : public : native : BinarySearch(value : H) ~ Int {
			low := 0;
			high := @size - 1;

			while(low <= high) {
				mid := (low + high) / 2;
      	
				if(@values[mid]->Compare(value) > 0) {
					high := mid - 1;
				}
				else if(@values[mid]->Compare(value) < 0) {
					low := mid + 1;
				}
				else {
					return mid;
				};
			};

			return -1;
		}
		
		#~
		Check of the given value is in the vector
		@param value value to check for
		@return true if found, false otherwise
		~#
		method : public : Has(value : H) ~ Bool {
			for(i : Int := 0; i < @size; i += 1;) {
				if(@values[i]->Compare(value) = 0) {
					return true;
				};
			};
			
			return false;
		}
		
		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filter vector
		~#
		method : public : Filter(f : (H) ~ Bool) ~ Vector<H> {
			filtered := Vector->New()<H>;
			
			for(i : Int := 0; i < @size; i += 1;) {
				if(f(@values[i])) {
					filtered->AddBack(@values[i]);
				};
			};
			
			return filtered;
		}
		
		#~
		Converts the vector into an object array
		@return object array
		~#
		method : public : ToArray() ~ H[] {
			array : H[] := H->New[@size];
			Runtime->Copy(array, 0, @values, 0, @size);
			return array;
		}
	}
	
	#~
	Balanced tree of generics
	~#
	class Map<K : Compare, V> {
		@root : TreeNode<K, V>;
		@last : TreeNode<K, V>;
		@size : Int;
		@found : Bool;

		#~
		Default constructor 
		~#
		New() {
			@root := Nil;
			@size := 0;	
		}		

		method : native : Skew(node : Collection.Generic.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node = Nil | node->GetLeft() = Nil) {
				return node;
			};
				
			if(node->GetLeft()->GetLevel() = node->GetLevel()) {
				left : TreeNode<K, V> := node->GetLeft();
				node->SetLeft(left->GetRight());
				left->SetRight(node);
				return left;
			};
			
			return node;
		}

		#~
		Size of queue
		@return size of queue
		~#
		method : public : Size() ~ Int {
			return @size;
		}
		
		#~
		Checks to see if the queue is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}

		#~
		Clears the queue
		~#
		method : public : Empty() ~ Nil {
			@root := Nil;
			@last := Nil;
			@size := 0;
			@found := false;
		}
		
		method : native : Split(node : Collection.Generic.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node = Nil | node->GetRight() = Nil | 
					node->GetRight()->GetRight() = Nil) {
				return node;
			};

			if(node->GetRight()->GetRight()->GetLevel() = node->GetLevel()) {
				right : TreeNode<K, V> := node->GetRight();
				node->SetRight(right->GetLeft());
				right->SetLeft(node);
				right->SetLevel(right->GetLevel() + 1);
				
				return right;
			};
			
			return node;
		}
		
		#~
		Searches for a value in a map
		@param key search key
		@return found value, Nil if not found
		~#
		method : public : Find(key : K) ~ V {
			return Find(key, @root);
		}
		
		#~
		Checks for a value in a map
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			return Find(key, @root) <> Nil;
		}
		
		method : Find(key : K, node : Collection.Generic.TreeNode<K, V>) ~ V {
			if(node <> Nil) {
				if(key->Compare(node->GetKey()) < 0) {
					return Find(key, node->GetLeft());
				}
				else if(key->Compare(node->GetKey()) > 0) {
					return Find(key, node->GetRight());
				}
				else {
					return node->Get();		
				};
			};
			
			return Nil;
		}
		
		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeys() ~  Collection.Generic.Vector<K> {
			vector := Vector->New()<K>;
			GetKeys(@root, vector);
			return vector;
		}
		
		method : GetKeys(node : Collection.Generic.TreeNode<K, V>, vector : Collection.Generic.Vector<K>) ~ Nil {
			if(node <> Nil) {
				# process left 
				GetKeys(node->GetLeft(), vector);
				
				key : K := node->GetKey();
				vector->AddBack(key);
				
				# process right
				GetKeys(node->GetRight(), vector);
			};
		}
		
		#~
		Gets a collection of values
		@return vector of values
		~#
		method : public : GetValues() ~  Collection.Generic.Vector<V> {
			vector := Vector->New()<V>;
			GetValues(@root, vector);
			return vector;
		}

		method : GetValues(node : Collection.Generic.TreeNode<K, V>, vector : Collection.Generic.Vector<V>) ~ Nil {
			if(node <> Nil) {
				# process left 
				GetValues(node->GetLeft(), vector);
				
				value : V := node->Get();
				vector->AddBack(value);
				
				# process right
				GetValues(node->GetRight(), vector);
			};
		}
		
		#~
		Inserts a value into the map
		@param key key
		@param value value
		~#
		method : public : Insert(key : K, value : V) ~ Nil {
			if(@root = Nil) {
				@root := Insert(key, value, Nil->As(Collection.Generic.TreeNode<K, V>));
			}
			else {
				@root := Insert(key, value, @root);
			};
		}
		
		method : Insert(key : K, value : V, node : Collection.Generic.TreeNode<K, V>) ~  Collection.Generic.TreeNode<K, V> {
			if(node = Nil) {
				node := TreeNode->New(key, value, 1)<K, V>;
				@size += 1;
			}
			else {
				if(key->Compare(node->GetKey()) < 0) {
					node->SetLeft(Insert(key, value, node->GetLeft()));
				}
				else if(key->Compare(node->GetKey()) > 0) {
					node->SetRight(Insert(key, value, node->GetRight()));
				}
				else {
					return node;		
				};
				node := Skew(node);
				node := Split(node);
			};	
			
			return node;
		}
		
		#~
		Removes a value from the map
		@param key key for value to remove
		~#
		method : public : Remove(key : K) ~ Bool {
			@found := true;
			@root := Remove(key, @root);
			if(@found) {
				@size := @size - 1;
				return true;
			};

			return false;
		}
		
		method : native : Remove(key : K, node : Collection.Generic.TreeNode<K, V>) ~  Collection.Generic.TreeNode<K, V> {
			if(node = Nil) {
				@found := false;
				return Nil;
			};

			if(key->Compare(node->GetKey()) < 0) {
				node->SetLeft(Remove(key, node->GetLeft()));
			}
			else if(key->Compare(node->GetKey()) > 0) {
				node->SetRight(Remove(key, node->GetRight()));
			}
			else {
				if(node->GetLeft() = Nil & node->GetRight() = Nil) {
					return Nil;
				}
				else if(node->GetLeft() = Nil) {
					left : K := Successor(node);
					node->SetRight(Remove(left, node->GetRight()));
					node->SetKey(left);
				} 
				else {
					left : K := Predecessor(node);
					node->SetLeft(Remove(left, node->GetLeft()));
					node->SetKey(left);
				};
				
			};
			
			# rebalanced
			node := DecreaseLevel(node);				
			node := Skew(node);
			node->SetRight(Skew(node->GetRight()));
			if(node->GetRight() <> Nil & node->GetRight()->GetRight() <> Nil) {
				node->GetRight()->SetRight(Skew(node->GetRight()->GetRight()));
			};	
			node := Split(node);								
			node->SetRight(Split(node->GetRight()));

			return node;
		}
		
		method : Predecessor(node : Collection.Generic.TreeNode<K, V>) ~ K {
			if(node->GetLeft() <> Nil) {
				left : TreeNode<K, V> := node->GetLeft();
				while(left->GetLeft() <> Nil) {
					left := left->GetLeft();
				};

				return left->GetKey();
			};

			return node->GetKey();
		}

		method : Successor(node : Collection.Generic.TreeNode<K, V>) ~ K {
			if(node->GetRight() <> Nil) {
				right : TreeNode<K, V> := node->GetRight();
				while(right->GetRight() <> Nil) {
					right := right->GetRight();
				};

				return right->GetKey();
			};

			return node->GetKey();
		}

		 method : DecreaseLevel(node : Collection.Generic.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node->GetLeft() <> Nil & node->GetRight() <> Nil) {
				left : Int := node->GetLeft()->GetLevel();
				right : Int := node->GetRight()->GetLevel();
				value : Int := Int->Min(left, right);
			
				if(value < node->GetLevel()) {
					node->SetLevel(value);
					if(value < node->GetRight()->GetLevel()) {
						node->GetRight()->SetLevel(value);
					};
				};
			};
			
			return node;
		}
		
		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filter vector
		~#
		method : public : Filter(f : (K) ~ Bool) ~ Map<K, V> {
			filtered := Map->New()<K, V>;
			
			keys := GetKeys();
			each(i : keys) {
				key := keys->Get(i);
				if(f(key)) {
					value := Find(key);
					filtered->Insert(key, value);
				};
			};
			
			return filtered;
		}
	}
	
	class TreeNode<K : Compare, V> {
		@key : K;
		@value : V;
		@left : TreeNode<K, V>;
		@right : TreeNode<K, V>;
		@level : Int;
		
		New(key : K, value : V, level : Int) {
			@key := key;
			@value := value;
			@level := level;
			@left := Nil;
			@right := Nil;
		}

		method : public : SetKey(key : K) ~ Nil {
			@key := key;
		}
		
		method : public : GetKey() ~ K {
			return @key;
		}

		method : public : Get() ~ V {
			return @value;
		}
		
		method : public : GetLevel() ~ Int {
			return @level;
		}

		method : public : SetLevel(level : Int) ~ Nil {
			@level := level;
		}

		method : public : GetLeft() ~ TreeNode<K, V> {
			return @left;
		}

		method : public : SetLeft(left : TreeNode<K, V>) ~ Nil {
			@left := left;
		}

		method : public : GetRight() ~ TreeNode<K, V> {
			return @right;
		}

		method : public : SetRight(right : TreeNode<K, V>) ~ Nil {
			@right := right;
		}
	}
}