use System.IO.Net; 
use System.IO.Filesystem;
use System.Time;
use Collection.Generic;

#~
Web client support (-lib net)
~#
bundle Web.HTTP {
	#~
	URL parser, encoder and decoder
	~#
	class Url {
		@parsed : Bool;
		@url : String;
		@scheme : String;
		@host : String;
		@port : Int;
		@frag : String;
		@query : String;
		@path : String;

		#~
		Parsed URL into components
		@param url raw URL
		~#
		New(url : String) {
			@url := url;
			@port := -1;
			@parsed := ParseUrl(url);
		}

		#~
		Determines if given URL has been parsed correctly
		@return true if parsed, false otherwise
		~#
		method : public : Parsed() ~ Bool {
			return @parsed;
		}

		#~
		Gets original URL
		@return original URL
		~#
		method : public : GetUrl() ~ String {
			return @url;
		}

		#~
		Gets scheme
		@return scheme, Nil if not present
		~#
		method : public : GetScheme() ~ String {
			if(@parsed) {
				return @scheme;
			};

			return Nil;
		}

		#~
		Gets host
		@return host, Nil if not present
		~#
		method : public : GetHost() ~ String {
			if(@parsed) {
				return @host;
			};

			return Nil;
		}

		#~
		Gets scheme
		@return scheme, Nil if not present
		~#
		method : public : GetQuery() ~ String {
			if(@parsed) {
				return @query;
			};

			return Nil;
		}
		
		#~
		Gets port
		@return port, -1 if not present
		~#
		method : public : GetPort() ~ Int {
			if(@parsed) {
				return @port;
			};

			return -1;
		}

		#~
		Gets fragment
		@return fragment, Nil if not present
		~#
		method : public : GetFragment() ~ String {
			if(@parsed) {
				return @frag;
			};

			return Nil;
		}

		#~
		Gets path
		@return path, Nil if not present
		~#
		method : public : GetPath() ~ String {
			if(@parsed) {
				return @path;
			};

			return Nil;
		}

		method : ParseUrl(url : String) ~ Bool {
# "-- url='{$url}' --"->PrintLine();
			scheme_index := url->Find(':');
			if(scheme_index < 0) {
				"--- No scheme ---"->ErrorLine();
				return false;
			};
			@scheme := url->SubString(0, scheme_index);
# "\t-- scheme='{$@scheme}' --"->PrintLine();

			scheme_index += 1;
			rest := url->SubString(scheme_index, url->Size() - scheme_index);
# "\t-- rest='{$rest}' --"->PrintLine();

			if(rest->StartsWith("//")) {
				parts := rest->SubString(2, rest->Size() - 2)->Split("/");
				if(parts->Size() = 0) {
					ParsePart(rest->SubString(2, rest->Size() - 2), 0, false);
				}
				else {
					each(i : parts) {
						ParsePart(parts[i], i, i = parts->Size() - 1);
					};
				};
			}
			else {
				@path := rest;
			};

			return true;
		}

		method : ParsePart(part : String, index : Int, last : Bool) ~ Nil {
# "\t-- part='{$part}' --"->PrintLine();
			# host and port
			if(index = 0) {
				if(part->StartsWith('[') | part->StartsWith('(')) {
					@host := part;
				}
				else {
					port_index := part->Find(':');
					if(port_index > -1) {
						@host := part->SubString(port_index);
						port_index += 1;
						port_str := part->SubString(port_index, part->Size() - port_index);
						@port := port_str->ToInt();
					}
					else {
						@host := part;
					};
				};
			}
			# path, query and fragment
			else {
				if(@path = Nil) {
					@path := "";
				};
				@path += '/';

				# query and fragment
				if(last) {
					sub_part : String;
					frag_index := part->Find('#');
					if(frag_index > -1) {
						sub_part := part->SubString(frag_index);
# "\t-- sub_part='{$sub_part}' --"->PrintLine();							
						frag_index += 1;
						@frag := part->SubString(frag_index, part->Size() - frag_index);
					}
					else {
						sub_part := part;
					};

					query_index := sub_part->Find('?');
					if(query_index > -1) {
						# add to path
						if(query_index > 0)	{
							@path += sub_part->SubString(query_index);
						};
						query_index += 1;

						@query := sub_part->SubString(query_index, sub_part->Size() - query_index);
					}
					else {
						@path += sub_part;
					};
				}
				# path
				else {
					@path += part;
				};
			};
		}

		#~
		General encoding for HTML or XML strings
		@param str string to encode 
		@return encoded string 
		~#
		function : native : Encode(str : String) ~ String {
			buffer := String->New();
			each(i : str) {
				c := str->Get(i);
				select(c) {
					label ' ': {
						buffer->Append("%20");
					}

					label ';': {
						buffer->Append("%3B");
					}

					label '=': {
						buffer->Append("%3D");
					}

					label '$': {
						buffer->Append("%26");
					}

					label ',': {
						buffer->Append("%2C");
					}

					label '<': {
						buffer->Append("%3C");
					}

					label '>': {
						buffer->Append("%3E");
					}

					label '^': {
						buffer->Append("%5E");
					}

					label '`': {
						buffer->Append("%60");
					}

					label '\\': {
						buffer->Append("%5C");
					}

					label '[': {
						buffer->Append("%5B");
					}

					label ']': {
						buffer->Append("%5D");
					}

					label '{': {
						buffer->Append("%7B");
					}

					label '}': {
						buffer->Append("%7D");
					}

					label '|': {
						buffer->Append("%7C");
					}

					label '"': {
						buffer->Append("%22");
					}

					label ':': {
						buffer->Append("%3A");
					}

					label '/': {
						buffer->Append("%2F");
					}

					label '#': {
						buffer->Append("%23");
					}

					label '?': {
						buffer->Append("%3F");
					}

					label '&': {
						buffer->Append("%24");
					}

					label '@': {
						buffer->Append("%40");
					}

					label '%': {
						buffer->Append("%25");
					}

					label '+': {
						buffer->Append("%2B");
					}

					label '~': {
						buffer->Append("%7E");
					}

					other: {
						buffer->Append(c);
					}
				};
			};
			
			return buffer;
		}

		#~
		General decoding for HTML or XML strings		
		@param str encoded string
		@return decoded string
		~#
		function : native : Decode(str : String) ~ String {
			buffer := String->New();
			each(i : str) {
				c := str->Get(i);
				if(c = '%' & i + 2 < str->Size()) {
					value := "0x";
					value->Append(str->Get(i + 1));
					value->Append(str->Get(i + 2));
					buffer->Append(value->ToInt()->As(Char));
					i += 2;
				}
				else {
					buffer->Append(c);
				};
			};

			return buffer;
		}

		#~
		String representation of URL
		@return string representation of URL
		~#
		method : public : ToString() ~ String {
			buffer := "{$@url}\n";

			if(@scheme <> Nil) {
				buffer += "\tscheme='{$@scheme}'\n";
			};

			if(@host <> Nil) {
				buffer += "\thost='{$@host}'\n";
			};

			if(@path <> Nil) {
				buffer += "\tpath='{$@path}'\n";
			};
			
			if(@port > -1) {
				buffer += "\tport='{$@port}'\n";
			};

			if(@query <> Nil) {
				buffer += "\tquery='{$@query}'\n";
			};
			
			if(@frag <> Nil) {
				buffer += "\tfragment='{$@frag}'\n";
			};
					
			return buffer;			
		}
	}

	#~
	HTTP client
	~#
	class HttpClient {
		@request_headers : Hash<String, String>;
		@response_headers : Hash<String, String>;
		@cookies_enabled : Bool;
		@cookies: Vector<String>;
		
		#~
		Default constructor 
		~#
		New() {
			@request_headers := Hash->New()<String, String>;
			@request_headers->Insert("Connection", "keep-alive");							
			@request_headers->Insert("Cache-Control", "max-age=0");
			@request_headers->Insert("User-Agent", "Mozilla/5.0 (compatible)");

			@response_headers := Hash->New()<String, String>;

			@cookies_enabled := false;
			@cookies := Vector->New()<String>;

		}
		
		#~
		Gets the HTTP request headers
		@return HTTP request headers
		~#
		method : public : GetRequestHeaders() ~ Hash<String, String> {
			return @request_headers;
		}

		#~
		Gets the HTTP response headers
		@return HTTP response headers
		~#
		method : public : GetResponseHeaders() ~ Hash<String, String> {
			return @response_headers;
		}

		#~
		Adds a HTTP request header
		@param name header name
		@param value header value
		~#
		method : public : AddHeader(name : String, value : String) ~  Nil {
			@request_headers->Insert(name->ToLower(), value);
		}
		
		#~
		Sets cookie support
		@param cookies_enabled true if cookies are enabled, false otherwise
		~#
		method : public : CookiesEnabled(cookies_enabled : Bool) ~ Nil {
			@cookies_enabled := cookies_enabled;
		}	
		
		#~
		Gets the cookies
		@return vector of cookies
		~#
		method : public : GetCookies() ~ Vector<String> {
			return @cookies;
		}	
		
		#~
		Sets a cookie
		@param cookie cookie nane and value
		~#
		method : public : SetCookie(cookie : String) ~ Nil {
			@cookies->AddBack(cookie);
		}	
		
		#~
		Performs a HTTP POST
		@param url URL
		@param data data to post
		@return vector of read strings
		~#
		method : public : Post(url : String, data : String) ~ Vector<String> {
			return Post(url, data, "text/plain");
		}

		#~
		Performs a HTTP POST
		@param url URL
		@param data data to post
		@return read strings
		~#
		function : PostAll(url : String, data : String) ~ String {
			document := "";
			
			client := HttpClient->New();
			lines := client->Post(url, data);
			if(lines = Nil) {
				return Nil;
			};

			each(i : lines) {
				document->Append(lines->Get(i));
			};

			return document;
		}
		
		#~
		Performs a HTTP POST
		@param url URL
		@param data data to post
		@param content_type content type
		@param headers key/value headers
		@return read strings
		~#
		function : PostAll(url : String, data : String, content_type : String, headers : Map<String, String>) ~ String {
			document := "";
			
			client := HttpClient->New();
			header_key_values := headers->GetKeyValues()<Pair<String, String>>;
			each(i : header_key_values) {
				key_value := header_key_values->Get(i);
				key := key_value->GetFirst();
				value := key_value->GetSecond();
				client->AddHeader(key, value);
			};

			lines := client->Post(url, data, content_type);
			if(lines = Nil) {
				return Nil;
			};

			each(i : lines) {
				document->Append(lines->Get(i));
			};

			return document;
		}

		#~
		Performs a HTTP POST
		@param url URL
		@param data data to post
		@param content_type content type
		@return vector of read strings
		~#
		method : public : Post(url : String, data : String, content_type : String) ~ Vector<String> {
			content := Vector->New()<String>;

			if(url->StartsWith("http://")) {
				url := url->SubString("http://"->Size(), url->Size() - "http://"->Size());
				address := "";
				location := "/";
				index := url->Find('/');
				port := "80";
				if(index > -1) {
				  address := url->SubString(index);
				  port_index := address->Find(':');
				  if(port_index > -1) {
				    port_index += 1;
				    port := address->SubString(port_index, address->Size() - port_index);
				    address := address->SubString(port_index - 1);
				  }
				  else {
				    location->Append(url->SubString(index + 1, url->Size() - index - 1));
				  };
				}
				else {
				  address := url;
				};
				
				socket := TCPSocket->New(address, port->ToInt());
				if(socket->IsOpen()) {
					post := "POST ";
					post->Append(location);
					post->Append(" HTTP/1.1\r\nHost: ");
					post->Append(address);
					post->Append("\r\nContent-Type: ");
					post->Append(content_type);
					post->Append("\r\nContent-Length: ");
					post->Append(data->Size()->ToString());
					post->Append("\r\n");

					request_keys := @request_headers->GetKeys()<String>;
					each(i : request_keys) {		
						request_key := request_keys->Get(i);
						request_value := @request_headers->Find(request_key);					
						post->Append(request_key);
						post->Append(": ");
						post->Append(request_value);
						post->Append("\r\n");
					};

					if(@cookies_enabled & @cookies->Size() > 0) {
						post->Append("Cookie: ");
						each(i : @cookies) {
							post->Append(@cookies->Get(i));
							if(i + 1 < @cookies->Size()) {
								post->Append("; ");
							};
						};
						post->Append("\r\n");
					};
					post->Append("\r\n");					
					post->Append(data);
					socket->WriteString(post);
					
# post->PrintLine();					
					
					status_code := 500;
					status_line := socket->ReadLine();
					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, 
							status_line->Size() - "HTTP/1."->Size() - 2);
						index := status_line->Find(' ');
						status_code := status_line->SubString(index)->ToInt();
					};
					
# status_line->PrintLine();
					
					if(status_code <> 500) {
						# get request headers
						do {
							line := socket->ReadLine();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();
								
# IO.Standard->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
								if(@cookies_enabled & name->Equals("Set-Cookie")) {
									offset := value->Find(';');
									if(offset > -1) {
										value := value->SubString(offset);
									};
									@cookies->AddBack(value);
# IO.Standard->Print("cookie=")->PrintLine(value);									
								}
								else {
									@response_headers->Insert(name->ToLower(), value);
								};
							};
						}
						while(line->Size() > 0);
# IO.Standard->Print("cookies: size=")->PrintLine(@cookies->Size());
						
						# permanently moved
						if(status_code = 301 | status_code = 302) {
							moved_location := @response_headers->Find("location");
							if(moved_location <> Nil) {
								moved_url : String;
								if(moved_location->StartsWith("http://")) {
									moved_url := moved_location;
								}
								else {
									moved_url := "http://";
									moved_url += address;
									moved_url += moved_location;
								};
								@response_headers->Empty();

# IO.Standard->Print("permanently moved: ")->PrintLine(moved_url);
								return Get(moved_url, content_type);
							};
						};

						# look for chunked blocks
						encoding : String := @response_headers->Find("transfer-encoding");
						if(encoding <> Nil & encoding->Equals("chunked")) {
							done := false;
							do {
								size_line := "0x";
								size_line->Append(socket->ReadLine());
								chunk_size := size_line->ToInt();
								line := "";
								if(chunk_size > 0) {
									for(i := 0; i < chunk_size; i += 1;) {
										line->Append(socket->ReadByte());
									};
									socket->ReadLine();
									content->AddBack(line);
								}
								else {
									done := true;
								};
							}
							while(done <> true);
						}
						else {
							length_header : String := @response_headers->Find("content-length");
							if(length_header <> Nil) {
								SocketCommon->ReadLength(length_header->ToInt(), content, socket);
							};						
						};
					};
					socket->Close();
				};
			};
			
			return content;
		}

		#~
		Performs a HTTP GET and returns results as a String
		@param url URL
		@return output as one string
		~#
		function : GetAll(url : String) ~ String {
			return GetAll(url, "text/plain", Nil);
		}

		#~
		Performs a HTTP GET and returns results as a String
		@param url URL
		@param headers key/value headers
		@return output as one string
		~#
		function : GetAll(url : String, headers : Map<String, String>) ~ String {
			return GetAll(url, "text/plain", headers);
		}
		
		#~
		Performs a HTTP GET and returns results as a String
		@param url URL
		@param content_type content type
		@param headers key/value headers
		@return output as one string
		~#
		function : GetAll(url : String, content_type : String, headers : Map<String, String>) ~ String {
			document := "";
			
			client := HttpClient->New();
			if(headers <> Nil) {
				header_key_values := headers->GetKeyValues()<Pair<String, String>>;
				each(i : header_key_values) {
					key_value := header_key_values->Get(i);
					key := key_value->GetFirst();
					value := key_value->GetSecond();
					client->AddHeader(key, value);
				};
			};

			lines := client->Get(url, content_type);
			if(lines = Nil) {
				return Nil;
			};

			each(i : lines) {
				document->Append(lines->Get(i));
			};

			return document;
		}
		
		#~
		Performs a HTTP GET
		@param url URL
		@return vector of read strings
		~#
		method : public : Get(url : String) ~ Vector<String> {
			return Get(url, "text/plain");
		}
		
		#~
		Performs a HTTP GET
		@param url URL
		@param content_type content type
		@return vector of read strings
		~#
		method : public : Get(url : String, content_type : String) ~ Vector<String> {
			content := Vector->New()<String>;
			
			if(url->StartsWith("http://")) {
				url := url->SubString("http://"->Size(), url->Size() - "http://"->Size());
				address := "";
				location := "/";
				index := url->Find('/');
				port := "80";
				if(index > -1) {
				  address := url->SubString(index);
				  port_index := address->Find(':');
				  if(port_index > -1) {
				    port_index += 1;
				    port := address->SubString(port_index, address->Size() - port_index);
				    address := address->SubString(port_index - 1);
				  }
				  else {
				    location->Append(url->SubString(index + 1, url->Size() - index - 1));
				  };
				}
				else {
				  address := url;
				};
				
				socket := TCPSocket->New(address, port->ToInt());
				if(socket->IsOpen()) {
					get := "GET ";
					get->Append(location);
					get->Append(" HTTP/1.1\r\nHost: ");
					get->Append(address);
					get->Append("\r\n");

					request_keys := @request_headers->GetKeys()<String>;
					each(i : request_keys) {		
						request_key := request_keys->Get(i);
						request_value := @request_headers->Find(request_key);					
						get->Append(request_key);
						get->Append(": ");
						get->Append(request_value);
						get->Append("\r\n");
					};

					if(@cookies_enabled & @cookies->Size() > 0) {
						get->Append("Cookie: ");
						each(i : @cookies) {
							get->Append(@cookies->Get(i));
							if(i + 1 < @cookies->Size()) {
								get->Append("; ");
							};
						};
						get->Append("\r\n");
					};					
					get->Append("\r\n");		
					
# IO.Standard->Print("Get: |")->Print(get)->PrintLine("|");
					
					socket->WriteString(get);
					
					status_code := 500;
					status_line := socket->ReadLine();
# status_line->PrintLine();					
					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, 
							status_line->Size() - "HTTP/1."->Size() - 2);
						index := status_line->Find(' ');
						status_code := status_line->SubString(index)->ToInt();
					};
# status_code->PrintLine();					
					if(status_code <> 500) {
						# get request headers
						do {
							line := socket->ReadLine();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();
								
# IO.Standard->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
								if(@cookies_enabled & name->Equals("Set-Cookie")) {
									offset := value->Find(';');
									if(offset > -1) {
										value := value->SubString(offset);
									};
									@cookies->AddBack(value);
# IO.Standard->Print("cookie=")->PrintLine(value);									
								}
								else {
									@response_headers->Insert(name->ToLower(), value);
								};
							};
						}
						while(line->Size() > 0);						
# IO.Standard->Print("cookies: size=")->PrintLine(@cookies->Size());
						
						# permanently moved
						if(status_code = 301 | status_code = 302) {
							moved_location := @response_headers->Find("location");
							if(moved_location <> Nil) {
								moved_url : String;
								if(moved_location->StartsWith("http://")) {
									moved_url := moved_location;
								}
								else {
									moved_url := "http://";
									moved_url += address;
									moved_url += moved_location;
								};
								@response_headers->Empty();

# IO.Standard->Print("permanently moved: ")->PrintLine(moved_url);
								return Get(moved_url, content_type);
							};
						};

						# look for chunked blocks
						encoding : String := @response_headers->Find("transfer-encoding");
						if(encoding <> Nil & encoding->Equals("chunked")) {
							done := false;
							do {
								size_line := "0x";
								size_line->Append(socket->ReadLine());
								chunk_size := size_line->ToInt();
								buffer := Byte->New[chunk_size];
								if(chunk_size > 0) {
									for(i := 0; i < chunk_size; i += 1;) {
										buffer[i] := socket->ReadByte();
									};
									# add line
									line := String->New(buffer);
									content->AddBack(line);
# line->PrintLine();																	
									# read '\r'
									socket->ReadByte(); 
									# read ''\n'
									socket->ReadByte();
									
								}
								else {
									# read '\r'
									socket->ReadByte(); 
									# read ''\n'
									socket->ReadByte();						
									done := true;
								};
							}
							while(done <> true);
						}
						else {
							length_header : String := @response_headers->Find("content-length");
							if(length_header <> Nil) {
								SocketCommon->ReadLength(length_header->ToInt(), content, socket);
							}
							else {
								count := 0;
								do {
									line := socket->ReadLine();
									if(line->Size() = 0) {
										count += 1;
									}
									else {
										content->AddBack(line);
										count := 0;
									};
								}
								while(count < 2);
							};					
						};
					};
					socket->Close();
				}
				else {
					return Nil;
				};
			};	
			
			return content;
		}
	}

	#~
	HTTPS client that uses a SSL secure socket
	~#
	class HttpsClient {
		@request_headers : Hash<String, String>;
		@response_headers : Hash<String, String>;
		@cookies_enabled : Bool;
		@cookies: Vector<String>;
		@cert : String;
		
		#~
		Default constructor 
		~#
		New() {
			@request_headers := Hash->New()<String, String>;
			@request_headers->Insert("Connection", "keep-alive");							
			@request_headers->Insert("Cache-Control", "max-age=0");
			@request_headers->Insert("User-Agent", "Mozilla/5.0 (compatible)");
			
			@response_headers := Hash->New()<String, String>;

			@cookies_enabled := false;
			@cookies := Vector->New()<String>;
		}
		
		#~
		Gets the HTTPS request headers
		@return HTTPS request headers
		~#
		method : public : GetRequestHeaders() ~ Hash<String, String> {
			return @request_headers;
		}

		#~
		Gets the HTTPS response headers
		@return HTTPS response headers
		~#
		method : public : GetResponseHeaders() ~ Hash<String, String> {
			return @response_headers;
		}

		#~
		Adds a HTTPS request header
		@param name header name
		@param value header value
		~#
		method : public : AddHeader(name : String, value : String) ~  Nil {
			@request_headers->Insert(name->ToLower(), value);
		}
		
		#~
		Sets cookie support
		@param cookies_enabled true if cookies are enabled, false otherwise
		~#
		method : public : CookiesEnabled(cookies_enabled : Bool) ~ Nil {
			@cookies_enabled := cookies_enabled;
		}	
		
		#~
		Gets the cookies
		@return vector of cookies
		~#
		method : public : GetCookies() ~ Vector<String> {
			return @cookies;
		}	
		
		#~
		Sets a cookie
		@param cookie cookie nane and value
		~#
		method : public : SetCookie(cookie : String) ~ Nil {
			@cookies->AddBack(cookie);
		}

		#~
		Performs a HTTPS POST
		@param url URL
		@param data data to post
		@return read strings
		~#
		function : PostAll(url : String, data : String) ~ String {
			document := "";
			
			client := HttpsClient->New();
			lines := client->Post(url, data);
			if(lines = Nil) {
				return Nil;
			};

			each(i : lines) {
				document->Append(lines->Get(i));
			};

			return document;
		}
		
		#~
		Performs a HTTPS POST
		@param url URL
		@param data data to post
		@param content_type content type
		@param headers key/value headers
		@return read strings
		~#
		function : PostAll(url : String, data : String, content_type : String, headers : Map<String, String>) ~ String {
			document := "";
			
			client := HttpsClient->New();
			header_key_values := headers->GetKeyValues()<Pair<String, String>>;
			each(i : header_key_values) {
				key_value := header_key_values->Get(i);
				key := key_value->GetFirst();
				value := key_value->GetSecond();
				client->AddHeader(key, value);
			};

			lines := client->Post(url, data, content_type);
			if(lines = Nil) {
				return Nil;
			};

			each(i : lines) {
				document->Append(lines->Get(i));
			};

			return document;
		}	
		
		#~
		Performs a HTTPS POST
		@param url URL
		@param data data to post
		@return vector of read strings
		~#
		method : public : Post(url : String, data : String) ~ Vector<String> {
			return Post(url, data, "text/plain");
		}
		
		#~
		Performs a HTTPS POST
		@param url URL
		@param content_type content type
		@param data data to post
		@return vector of read strings
		~#
		method : public : Post(url : String, data : String, content_type : String) ~ Vector<String> {
			content := Vector->New()<String>;
			
			if(url->StartsWith("https://")) {
				url := url->SubString("https://"->Size(), url->Size() - "https://"->Size());
				address := "";
				location := "/";
				index := url->Find('/');
				port := "443";
				if(index > -1) {
				  address := url->SubString(index);
				  port_index := address->Find(':');
				  if(port_index > -1) {
				    port_index += 1;
				    port := address->SubString(port_index, address->Size() - port_index);
				    address := address->SubString(port_index - 1);
				  }
				  else {
				    location->Append(url->SubString(index + 1, url->Size() - index - 1));
				  };
				}
				else {
				  address := url;
				};
				
				socket := TCPSecureSocket->New(address, port->ToInt());
				if(socket->IsOpen()) {
					post := "POST ";
					post->Append(location);
					post->Append(" HTTP/1.1\r\nHost: ");
					post->Append(address);
					post->Append("\r\nContent-Type: ");
					post->Append(content_type);
					post->Append("\r\nContent-Length: ");
					post->Append(data->Size()->ToString());
					post->Append("\r\n");

					request_keys := @request_headers->GetKeys()<String>;
					each(i : request_keys) {		
						request_key := request_keys->Get(i);
						request_value := @request_headers->Find(request_key);					
						post->Append(request_key);
						post->Append(": ");
						post->Append(request_value);
						post->Append("\r\n");
					};

					if(@cookies_enabled & @cookies->Size() > 0) {
						post->Append("Cookie: ");
						each(i : @cookies) {
							post->Append(@cookies->Get(i));
							if(i + 1 < @cookies->Size()) {
								post->Append("; ");
							};
						};
						post->Append("\r\n");
					};
					post->Append("\r\n");					
					post->Append(data);
					socket->WriteString(post);
					
# post->PrintLine();					
					
					status_code := 500;
					status_line := socket->ReadLine();
					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, 
							status_line->Size() - "HTTP/1."->Size() - 2);
						index := status_line->Find(' ');
						status_code := status_line->SubString(index)->ToInt();
					};
					
# status_line->PrintLine();
					
					if(status_code <> 500) {
						# get request headers
						do {
							line := socket->ReadLine();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();			
								@response_headers->Insert(name->ToLower(), value);
# IO.Standard->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
							};
						}
						while(line->Size() > 0);
# IO.Standard->Print("cookies: size=")->PrintLine(@cookies->Size());

						# permanently moved
						if(status_code = 301 | status_code = 302) {
							moved_location := @response_headers->Find("location");
							if(moved_location <> Nil) {
								moved_url : String;
								if(moved_location->StartsWith("https://")) {
									moved_url := moved_location;
								}
								else {
									moved_url := "https://";
									moved_url += address;
									moved_url += moved_location;
								};
								@response_headers->Empty();

# IO.Standard->Print("permanently moved: ")->PrintLine(moved_url);
								return Get(moved_url, content_type);
							};
						};

						# look for chunked blocks
						encoding : String := @response_headers->Find("transfer-encoding");
						if(encoding <> Nil & encoding->Equals("chunked")) {
							SocketCommon->ReadChunked(content, socket);
						}
						else {
							length_header : String := @response_headers->Find("content-length");
							if(length_header <> Nil) {
								SocketCommon->ReadLength(length_header->ToInt(), content, socket);
							};						
						};
					};
					socket->Close();
				};
			};
			
			return content;
		}
		
		#~
		Performs a HTTPS GET and returns results as a String
		@param url URL
		@return output as one string
		~#
		function : GetAll(url : String) ~ String {
			return GetAll(url, "text/plain", Nil);
		}

		#~
		Performs a HTTPS GET and returns results as a String
		@param url URL
		@param headers key/value headers
		@return output as one string
		~#
		function : GetAll(url : String, headers : Map<String, String>) ~ String {
			return GetAll(url, "text/plain", headers);
		}

		#~
		Performs a HTTPS GET and returns results as a String
		@param url URL
		@param content_type content type
		@param headers key/value headers
		@return output as one string
		~#
		function : GetAll(url : String, content_type : String, headers : Map<String, String>) ~ String {
			document := "";
			
			client := HttpsClient->New();
			if(headers <> Nil) {
				header_key_values := headers->GetKeyValues()<Pair<String, String>>;
				each(i : header_key_values) {
					key_value := header_key_values->Get(i);
					key := key_value->GetFirst();
					value := key_value->GetSecond();
					client->AddHeader(key, value);
				};
			};

			lines := client->Get(url, content_type);
			if(lines = Nil) {
				return Nil;
			};

			each(i : lines) {
				document->Append(lines->Get(i));
			};

			return document;
		}

		#~
		Performs a HTTPS GET
		@param url URL
		@return vector of read strings
		~#
		method : public : Get(url : String) ~ Vector<String> {
			return Get(url, "text/plain");
		}

		#~
		Gets the socket's X.509 certificate issurer name
		@return certificate issurer name
		~#
		method : public : GetIssuer() ~ String {
			return @cert;
		}
		
		#~
		Performs a HTTPS GET
		@param url URL
		@param content_type content type
		@return vector of read strings
		~#
		method : public : Get(url : String, content_type : String) ~ Vector<String> {
			content := Vector->New()<String>;
			
			if(url->StartsWith("https://")) {
				url := url->SubString("https://"->Size(), url->Size() - "https://"->Size());
				address := "";
				location := "/";
				index := url->Find('/');
				port := "443";
				if(index > -1) {
				  address := url->SubString(index);
				  port_index := address->Find(':');
				  if(port_index > -1) {
				    port_index += 1;
				    port := address->SubString(port_index, address->Size() - port_index);
				    address := address->SubString(port_index - 1);
				  }
				  else {
				    location->Append(url->SubString(index + 1, url->Size() - index - 1));
				  };
				}
				else {
				  address := url;
				};
				
				socket := TCPSecureSocket->New(address, port->ToInt());
				if(socket->IsOpen()) {
					get := "GET ";
					get->Append(location);
					get->Append(" HTTP/1.1\r\nHost: ");
					get->Append(address);
					get->Append("\r\n");

					request_keys := @request_headers->GetKeys()<String>;
					each(i : request_keys) {		
						request_key := request_keys->Get(i);
						request_value := @request_headers->Find(request_key);					
						get->Append(request_key);
						get->Append(": ");
						get->Append(request_value);
						get->Append("\r\n");
					};
					
					if(@cookies_enabled & @cookies->Size() > 0) {
						get->Append("Cookie: ");
						each(i : @cookies) {
							get->Append(@cookies->Get(i));
							if(i + 1 < @cookies->Size()) {
								get->Append("; ");
							};
						};
						get->Append("\r\n");
					};					
					get->Append("\r\n");		
					
# IO.Standard->Print("Get: |")->Print(get)->PrintLine("|");
					
					socket->WriteString(get);
					
					status_code := 500;
					status_line := socket->ReadLine();
					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, 
							status_line->Size() - "HTTP/1."->Size() - 2);
						index := status_line->Find(' ');
						status_code := status_line->SubString(index)->ToInt();
					};					
# status_code->PrintLine();

					if(status_code <> 500) {
						# get request headers
						do {
							line := socket->ReadLine();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();
# IO.Standard->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
								if(@cookies_enabled & name->Equals("Set-Cookie")) {
									offset := value->Find(';');
									if(offset > -1) {
										value := value->SubString(offset);
									};
									@cookies->AddBack(value);
# IO.Standard->Print("cookie=")->PrintLine(value);
								}
								else {
									@response_headers->Insert(name->ToLower(), value);
								};
							};
						}
						while(line->Size() > 0);						
# IO.Standard->Print("cookies: size=")->PrintLine(@cookies->Size());

						# permanently moved
						if(status_code = 301 | status_code = 302) {
							moved_location := @response_headers->Find("location");
							if(moved_location <> Nil) {
								moved_url : String;
								if(moved_location->StartsWith("https://")) {
									moved_url := moved_location;
								}
								else {
									moved_url := "https://";
									moved_url += address;
									moved_url += moved_location;
								};
								@response_headers->Empty();

# IO.Standard->Print("permanently moved: ")->PrintLine(moved_url);
								return Get(moved_url, content_type);
							};
						};

						# look for chunked blocks
						encoding : String := @response_headers->Find("transfer-encoding");
						if(encoding <> Nil & encoding->Equals("chunked")) {
							SocketCommon->ReadChunked(content, socket);
						}
						else {
							length_header : String := @response_headers->Find("content-length");
							if(length_header <> Nil) {
								SocketCommon->ReadLength(length_header->ToInt(), content, socket);
							}
							else {
								count := 0;
								do {
									line := socket->ReadLine();
									if(line->Size() = 0) {
										count += 1;
									}
									else {
										content->AddBack(line);
										count := 0;
									};
								}
								while(count < 2);
							};							
						};
						@cert := socket->GetIssuer();
					};
					socket->Close();
				}
				else {
					return Nil;
				};
			};	
			
			return content;
		}
	}

	class : private : SocketCommon {
		function : ReadChunked(content : Vector<String>, socket : System.IO.InputStream) ~ Nil {
			done := false;
			do {
				size_line := "0x";
				size_line->Append(socket->ReadLine());
				chunk_size := size_line->ToInt();
				if(chunk_size > 0) {

					total_read := 0;								
					buffer := Byte->New[8192];
					do {
						total_read += socket->ReadBuffer(0, buffer->Size(), buffer);
						content->AddBack(String->New(buffer));
						buffer->Clear();
					}
					while(total_read < chunk_size);

					# read CRLF
					socket->ReadByte(); 
					socket->ReadByte();
				}
				else {
					done := true;
				};
			}
			while(done <> true);
		}

		function : ReadLength(length : Int, content : Vector<String>, socket : System.IO.InputStream) ~ Nil {
			total_read := 0;								
			buffer := Byte->New[8192];
			do {
				total_read += socket->ReadBuffer(0, buffer->Size(), buffer);
				content->AddBack(String->New(buffer));
				buffer->Clear();
			}
			while(total_read < length);
		}
	}
	
	#~
	Downloads web content
	~#
	class WebDownloader {
		#~
		Downloads content for the given URLs
		@param urls list of URLs to download content from
		@param headers key/value headers
		@return map of URLs and content
		~#
		function : Download(urls : Vector<String>, headers : Map<String, String>) ~ Vector<Pair<String, String>> {
			group_size := 3;

			downloaders := Downloader->New[urls->Size()];
			each(i : urls) {
				downloaders[i] := Downloader->New(urls->Get(i), headers);
			};

			download_count := 0;
			while(download_count < urls->Size()) {
				group_ending := download_count + group_size;
				if(group_ending >= urls->Size()) {
					group_ending := urls->Size();
				};

				for(i := download_count; i < group_ending; i += 1;) {
					downloader := downloaders[i];
					downloader->Execute(Nil);
				};

				for(i := download_count; i < group_ending; i += 1;) {
					downloader := downloaders[i];
					downloader->Join();
				};

				download_count += group_ending;
			};

			results := Map->New()<String, String>;
			each(i : urls) {
				downloader := downloaders[i];
				results->Insert(downloader->GetUrl(), downloader->GetContent());
			};

			return results->GetKeyValues();
		}
	}

	class Downloader from System.Concurrency.Thread {
		@url : String;
		@content : String;
		@headers : Map<String, String>;

		New(url : String, headers : Map<String, String>) {
			Parent();
			@url := url;
			@headers := headers;
		}

		method : public : GetUrl() ~ String {
			return @url;
		}

		method : public : GetContent() ~ String {
			return @content;
		}

		method : public : Run(param : Base) ~ Nil {
			if(@url->StartsWith("https://")) {
				@content := HttpsClient->GetAll(@url, @headers);
			}
			else if(@url->StartsWith("http://")) {
				@content := HttpClient->GetAll(@url, @headers);
			};
		}
	}

	
}

#~
Web server support (-lib net)
~#
bundle Web.HTTP.Server {
	#~
	HTTP and HTTP web server
	~#
	class WebServer {
		@secure_server : static : TCPSecureSocketServer;
		@server : static : TCPSocketServer;
		@is_debug : static : Bool;
        
		#~
		Starts a HTTPS server that listens for requests
		@param callback class inherited from 'HttpsRequestHandler'
		@param port server port
		@param cert SSL certificate
		@param cert_key SSL certificate key
		@param cert_key_passwd SSL certificate password
		@param is_debug true for debug output, false otherwise
		~#
		function : ServeSecure(callback : Class, port : Int, cert : String, cert_key : String, cert_key_passwd : String) ~ Nil {
			ServeSecure(callback, port, cert, cert_key, cert_key_passwd, false);
		}

		#~
		Starts a HTTPS server that listens for requests
		@param callback class inherited from 'HttpsRequestHandler'
		@param port server port
		@param cert SSL certificate
		@param cert_key SSL certificate key
		@param cert_key_passwd SSL certificate password
		@param is_debug true for debug output, false otherwise
		~#
		function : ServeSecure(callback : Class, port : Int, cert : String, cert_key : String, cert_key_passwd : String, is_debug : Bool) ~ Nil {
			@secure_server := TCPSecureSocketServer->New(cert, cert_key, cert_key_passwd, port);
			@is_debug := is_debug;

	  		Runtime->SetSignal(Runtime->Signal->SIGINT, Shutdown(Int) ~ Nil);
			if(@secure_server->Listen()) {
				platform := Runtime->GetPlatform();
				host := TCPSocket->HostName();

				if(@is_debug) {
					"Running on {$host} ({$platform}) port {$port}..."->PrintLine();
				};

				while(true) {
					handler := callback->Instance(callback->GetName())->As(HttpsRequestHandler);
					handler->SetDebug(@is_debug);
					handler->Execute(@secure_server->Accept());
				};
			}
			else {
				err_msg := @secure_server->GetLastError();
				"Error: '{$err_msg}'"->ErrorLine();
			};
	  	}

	  	#~
		Starts a HTTP server that listens for requests
		@param callback class inherited from 'HttpRequestHandler'
		@param port server port
		@param is_debug true for debug output, false otherwise
		~#
	  	function : Serve(callback : Class, port : Int) ~ Nil {
	  		Serve(callback, port, false);
	  	}

	  	#~
		Starts a HTTP server that listens for requests
		@param callback class inherited from 'HttpRequestHandler'
		@param port server port
		@param is_debug true for debug output, false otherwise
		~#
	  	function : Serve(callback : Class, port : Int, is_debug : Bool) ~ Nil {
	  		@server := TCPSocketServer->New(port);
			@is_debug := is_debug;

	  		Runtime->SetSignal(Runtime->Signal->SIGINT, Shutdown(Int) ~ Nil);
			if(@server->Listen(8)) {
				platform := Runtime->GetPlatform();
				host := TCPSocket->HostName();

				if(@is_debug) {
					"Running on {$host} ({$platform}) port {$port}..."->PrintLine();
				};
                
				while(true) {
					handler := callback->Instance(callback->GetName())->As(HttpRequestHandler);
					handler->SetDebug(@is_debug);
					handler->Execute(@server->Accept());
				};
			}
			else {
				err_msg := @server->GetLastError();
				"Error: '{$err_msg}'"->ErrorLine();
			};
	  	}

		function : Shutdown(id : Int) ~ Nil {
			if(@secure_server <> Nil) {
				@secure_server->Close();
			};

			if(@server <> Nil) {
				@server->Close();
			};
            
			if(@is_debug) {
				"Shutting down..."->PrintLine();
			};
			Runtime->Exit(0);
		}
	}

	#~
	Web server request
	~#
	class Request {
		@request_url : String;
		@request_headers : Map<String, String>;
		@response_headers : Map<String, String>;
		@buffer : Byte[];

		New(request_url : String, request_headers : Map<String, String>, response_headers : Map<String, String>) {
			@request_url := request_url;
			@request_headers := request_headers;
			@response_headers := response_headers;
		}

		New(request_url : String, request_headers : Map<String, String>, response_headers : Map<String, String>, buffer : Byte[]) {
			@request_url := request_url;
			@request_headers := request_headers;
			@response_headers := response_headers;
			@buffer := buffer;
		}

		#~
		Gets the request body
		@return request body
		~#
		method : public : GetBody() ~ String {
			return @buffer->ToString();
		}

		#~
		Gets the request body bytes
		@return request body bytes
		~#
		method : public : GetBodyBytes() ~ Byte[] {
			return @buffer;
		}

		#~
		Sets the content type
		@param type content type
		~#
		method : public : SetContentType(type : String) ~ Nil {
			@response_headers->Insert("Content-Type", type);
		}

		#~
		Gets the request URL
		@return request URL
		~#
		method : public : GetUrl() ~ String {
			return @request_url;
		}

		#~
		Gets a request header
		@param name header name
		@return request header
		~#
		method : public : GetRequestHeader(name : String) ~ String {
			return @request_headers->Find(name)<String>;
		}

		#~
		Gets a response header
		@param name header name
		@return response header
		~#
		method : public : GetResponseHeader(name : String) ~ String {
			return @response_headers->Find(name)<String>;
		}

		#~
		Sets a response header
		@param name header name
		@param value header value
		~#
		method : public : SetResponseHeader(name : String, value : String) ~ Nil {
			if(value = Nil | value->IsEmpty()) {
				@response_headers->Remove(name);
			}
			else {
				@response_headers->Insert(name, value)<String>;
			};
		}

		#~
		Removed a response header
		@param name header name
		~#
		method : public : RemoveResponseHeader(name : String) ~ Nil {
			SetResponseHeader(name, Nil);
		}

		#~
		Check for a response header
		@param name header name
		@return true if header exists, false otherwise
		~#
		method : public : HasResponseHeader(name : String) ~ Bool {
			return @response_headers->Has(name);
		}
	}

	#~
	Web server response
	~#
	class Response {
		@code : Int;
		@content : Byte[];
		@reason : String;

		#~
		Constructor
		@param code status code
		~#
		New(code : Int) {
			@code := code;
		}

		#~
		Constructor
		@param code status code
		@param content content
		~#
		New(code : Int, content : String) {
			@code := code;
			@content := content->ToByteArray();
		}

		#~
		Constructor
		@param code status code
		@param content content
		~#
		New(code : Int, content : Byte[]) {
			@code := code;
			@content := content;
		}

		#~
		Get the response code
		@return response code
		~#
		method : public : GetCode() ~ Int {
			return @code;
		}

		#~
		Get the response content
		@return response content
		~#
		method : public : GetContent() ~ Byte[] {
			return @content;
		}

		method : public : SetReason(reason : String) ~ Nil {
			@reason := reason;
		}

		#~
		Get the reason string
		@return reason sting
		~#
		method : public : GetReason() ~ String {
			return @reason;
		}		

		#~
		Get the reason string
		@return reason sting
		~#
		method : public : ToString() ~ String {
			if(@content <> Nil) {
				content_size := @content->Size();
				return "code={$@code}, reason={$@reason}, content_size={$content_size}";
			};

			return "<Nil>";
		}
	}
	
	#~
	Request handler for HTTPS GET and POST requests
	~#
	class HttpsRequestHandler from System.Concurrency.Thread {
		@client : TCPSecureSocket;
		@is_debug : Bool;

		New() {
			Parent();
		}

		method : public : SetDebug(is_debug : Bool) ~ Nil {
			@is_debug := is_debug;
		}
        
		method : public : Run(param : Base) ~ Nil {
			@client := param->As(TCPSecureSocket);

			if(@client <> Nil & @client->IsOpen()) {
				# get request
				request := @client->ReadLine();
				if(@is_debug) {
					request_address := @client->GetAddress();
					"Request: '{$request}' from '{$request_address}'\n---"->PrintLine();
				};

				# parse request
				request_verb : String; request_url : String;
				if(request->Size() > 0) {
					request_parts := request->Split(" ");
					if(request_parts->Size() = 3) {
						request_verb := request_parts[0];
						request_url := request_parts[1];
					};
				};

				# verify request
				if(request_verb <> Nil & request_url <> Nil & <>request_url->IsEmpty()) {
					# get request headers
					request_headers := GetHeaders();

					# GET request
					if(request_verb->Equals("GET")) {
						# retrieve content
						if(request_url = Nil | request_url->Equals("/") | request_url->Has("..")) {
							request_url := "/index.html";
						};

						# write response
						response_headers := Map->New()<String, String>;
						response := ProcessGet(Request->New(request_url, request_headers, response_headers));
						ProcessResponse(response, response_headers);
					}
					# POST request
					else if(request_verb->Equals("POST")) {
						content_length := request_headers->Find("Content-Length");
						if(content_length <> Nil) {
							buffer := Byte->New[content_length->ToInt()];
							each(i : buffer) {
								buffer[i] := @client->ReadByte();
							};

							# retrieve content
							if(request_url = Nil | request_url->Equals("/") | request_url->Has("..")) {
								request_url := "/index.html";
							};

							# write response
							response_headers := Map->New()<String, String>;
							response := ProcessPost(Request->New(request_url, request_headers, response_headers, buffer));
							ProcessResponse(response, response_headers);
						};
					};
				};
				
				@client->Close();
			};
		}

		method : ProcessResponse(response : Response, response_headers : Map<String, String>) ~ Nil {
			if(response <> Nil) {
				if(response->GetCode() = 200) {
					response_header := "";
					key_values := response_headers->GetKeyValues()<Pair<String, String>>;
					each(i : key_values) {
						key_value := key_values->Get(i);
						key := key_value->GetFirst();
						value := key_value->GetSecond();
						response_header += "{$key}: {$value}\r\n";
					};

					content := response->GetContent();
					if(content <> Nil) {
						content_size := content->Size();
						response_header += "Content-Length: {$content_size}\r\nAccept-Ranges: bytes\r\nConnection: close\r\n";
						@client->WriteString("HTTP/1.1 200 OK\r\n{$response_header}\r\n");
						@client->WriteBuffer(content);
					}
					else {
						@client->WriteString("HTTP/1.1 200\r\n\r\n");
					};
				}
				else {
					select(response->GetCode()) {
						label 202 {
							@client->WriteString("HTTP/1.1 202 Accepted\r\n\r\n");
						}

						label 302 {
							reason := response->GetReason();
							if(reason <> Nil) {
								@client->WriteString("HTTP/1.1 302 Found\r\nLocation: {$reason}\r\nConnection: close\r\n\r\n");
							}
							else {
								@client->WriteString("HTTP/1.1 400\r\n\r\n");
							};
						}

						label 404 {
							@client->WriteString("HTTP/1.1 404 Not Found\r\n\r\n");
						}

						label 410 {
							@client->WriteString("HTTP/1.1 410 Gone\r\n\r\n");
						}

						other {
							@client->WriteString("HTTP/1.1 400\r\n\r\n");
						}
					};
				};
			};
		}
		
		#~
		Get HTTP headers
		@return HTTP headers
		~#
		method : public : GetHeaders() ~ Map<String, String> {
			headers := Map->New()<String, String>;
			
			header := @client->ReadLine();
			while(header <> Nil & header->Size() > 0) {
				if(@is_debug) {				
					"header: {$header}"->PrintLine();
				};
                
				header_parts := header->Split(": ");
				if(header_parts->Size() = 2) {
					headers->Insert(header_parts[0], header_parts[1]);
				};

				header := @client->ReadLine();
			};
			
			return headers;
		}

		#~
		Callback for GET requests
		@param request GET request
		@return GET request content
		~#
		method : virtual : ProcessGet(request : Request) ~ Response;

		#~
		Callback for POST requests
		@param request GET request
		@return content
		~#
		method : virtual : ProcessPost(request : Request) ~ Response;
	}

	#~
	Multipart encoding
	~#
	class MultipartEncoding {
		@encoded : Byte[];

		#~
		Parses multipart encoding
		@param encoded encoded bytes
		~#
		New(encoded : Byte[]) {
			@encoded := encoded;
		}
		
		#~
		Parses multipart encoding
		@return content parts
		~#
	    method : public : native : Parse() ~ Vector<MultipartContent> {
	        multipart_content := Vector->New()<MultipartContent>;

	        # read encoding string
	        marker_bytes := ReadLine(0, @encoded);
	        if(marker_bytes = Nil) {
	            return Nil;
	        };

	        encoding_size := @encoded->Size();
	        
	        # fetch all markers
	        marker_indexes := Byte->FindAll(@encoded, marker_bytes);
	        if(marker_indexes = Nil) {
	            return Nil;
	        };

	        boundry_index := 0;
	        for(i := 0; i < marker_indexes->Size() - 1; i += 1;) {
	            boundary_bytes := ReadLine(marker_indexes[i], @encoded);
	            if(boundary_bytes = Nil) {
	                return Nil;
	            };
	            boundry_index += boundary_bytes->Size();

	            # read white space
	            if(<>MatchSpace(boundry_index, @encoded)) {
	                return Nil;
	            };
	            boundry_index += 2;
	 
	            # read content headers
	            done := false;
	            headers := Map->New()<String, String>;
	            do {
	                # read content line
	                header_bytes := ReadLine(boundry_index, @encoded);
	                if(header_bytes <> Nil) {            
	                    boundry_index += header_bytes->Size();
	                    content_str := header_bytes->ToString();
	                    
	                    # parse header name/value pair
	                    content_str_index := content_str->Find(':');
	                    if(content_str_index > 0) {
	                        header_name := content_str->SubString(content_str_index);
	                        content_str_index += 2;
	                        header_value := content_str->SubString(content_str_index, content_str->Size() - content_str_index);
	                        
	                        if(<>header_name->IsEmpty() & <>header_value->IsEmpty()) {
	                            headers->Insert(header_name, header_value);
	                        };
	                    };
	                }
	                else {
	                    done := true;
	                };

	                # read white space
	                if(<>MatchSpace(boundry_index, @encoded)) {
	                    return Nil;
	                };
	                boundry_index += 2;
	            }
	            while(<>done);
	            
	            # read content
	            content_size := marker_indexes[i + 1] - boundry_index - 2;
	            
	            content_bytes := Byte->New[content_size];
	            if(Runtime->Copy(content_bytes, 0, @encoded, boundry_index, content_size)) {
	                content_str := String->New(content_bytes);
	                ", content: |{$content_str}|"->PrintLine();
	            };
	            boundry_index += content_bytes->Size();

	            # read white space
	            if(<>MatchSpace(boundry_index, @encoded)) {
	                return Nil;
	            };
	            boundry_index += 2;

	            multipart_content->AddBack(MultipartContent->New(headers, content_bytes));
	        };

			# read ending boundary
	        boundary_bytes := ReadLine(marker_indexes[marker_indexes->Size() - 1], @encoded);
	        if(boundary_bytes = Nil) {
	            return Nil;
	        };
	        boundry_index += boundary_bytes->Size();

	        # read white space
	        if(<>MatchSpace(boundry_index, @encoded)) {
	            return Nil;
	        };
	        boundry_index += 2;

	        boundary_str := boundary_bytes->ToString();
	        if(boundary_str->EndsWith("--") & encoding_size = boundry_index) {
	            return multipart_content;
	        };

	        return Nil;
	    }

	    method : native : ReadLine(offset : Int, encoded : Byte[]) ~ Byte[] {
	        i := offset;
	        if(i < encoded->Size()) {
	            done := false;
	            read := 0;
	            while(<>done & i < encoded->Size()) {
	                byte := encoded[i++];
	                if(byte = '\r') {
	                    done := true;
	                }
	                else {
	                    read += 1;
	                };
	            };

	            line := Byte->New[read];
	            if(Runtime->Copy(line, 0, encoded, offset, read)) {
	                return line;
	            };
	        };

	        return Nil;
	    }

	    method : native : MatchSpace(offset : Int, encoded : Byte[]) ~ Bool {
	        if(offset + 1 < encoded->Size()) {
	            return encoded[offset] = '\r' & encoded[offset + 1] = '\n';
	        };

	        return false;
	    }
	}

	#~
	Multipart content type
	~#
	class MultipartContent {
	    @headers : Map<String, String>;
	    @content : Byte[];

	    New(headers :  Map<String, String>, content : Byte[]) {
	        @headers := headers;
	        @content := content;
	    }

	    #~
		Get MIME content header
		@param name header name
		@return header value
		~#
	    method : public : GetHeader(name : String) ~ String {    
	        return @headers->Find(name);
	    }

	    #~
		Get MIME content header names
		@return header names
		~#
	    method : public : GetHeaderNames() ~ Vector<String> {    
	        return @headers->GetKeys()<String>;
	    }

	    #~
		Get MIME content
		@return MIME bytes
		~#
	    method : public : GetContent() ~ Byte[] {
	        return @content;
	    }
	}
	   
	#~
	Request handler for HTTP GET and POST requests
	~#
	class HttpRequestHandler from System.Concurrency.Thread {
		@client : TCPSocket;
		@is_debug : Bool;
        
		New() {
			Parent();
		}

		method : public : SetDebug(is_debug : Bool) ~ Nil {
			@is_debug := is_debug;
		}

		method : public : Run(param : Base) ~ Nil {
			@client := param->As(TCPSocket);

			if(@client <> Nil & @client->IsOpen()) {
				# get request
				request := @client->ReadLine();
				if(@is_debug) {
					request_address := @client->GetAddress();
					"Request: '{$request}' from '{$request_address}'\n---"->PrintLine();
				};

				# parse request
				request_verb : String; request_url : String;
				if(request->Size() > 0) {
					request_parts := request->Split(" ");
					if(request_parts->Size() = 3) {
						request_verb := request_parts[0];
						request_url := request_parts[1];
					};
				};

				# verify request
				if(request_verb <> Nil & request_url <> Nil & <>request_url->IsEmpty()) {
					# get request headers
					request_headers := GetHeaders();

					# GET request
					if(request_verb->Equals("GET")) {
						# retrieve content
						if(request_url = Nil | request_url->Equals("/") | request_url->Has("..")) {
							request_url := "/index.html";
						};

						# write response
						response_headers := Map->New()<String, String>;
						response := ProcessGet(Request->New(request_url, request_headers, response_headers));
						ProcessResponse(response, response_headers);
					}
					# POST request
					else if(request_verb->Equals("POST")) {
						content_length := request_headers->Find("Content-Length");
						if(content_length <> Nil) {
							buffer := Byte->New[content_length->ToInt()];
							each(i : buffer) {
								buffer[i] := @client->ReadByte();
							};

							# retrieve content
							if(request_url = Nil | request_url->Equals("/") | request_url->Has("..")) {
								request_url := "/index.html";
							};
							
							# write response
							response_headers := Map->New()<String, String>;
							response := ProcessPost(Request->New(request_url, request_headers, response_headers, buffer));
							ProcessResponse(response, response_headers);
						};
					};
				};
				
				@client->Close();
			};
		}

		method : ProcessResponse(response : Response, response_headers : Map<String, String>) ~ Nil {
			if(response <> Nil) {
				if(response->GetCode() = 200) {
					response_header := "";
					key_values := response_headers->GetKeyValues()<Pair<String, String>>;
					each(i : key_values) {
						key_value := key_values->Get(i);
						key := key_value->GetFirst();
						value := key_value->GetSecond();
						response_header += "{$key}: {$value}\r\n";
					};

					content := response->GetContent();
					if(content <> Nil) {
						content_size := content->Size();
						response_header += "Content-Length: {$content_size}\r\nAccept-Ranges: bytes\r\nConnection: close\r\n";
						@client->WriteString("HTTP/1.1 200 OK\r\n{$response_header}\r\n");
						@client->WriteBuffer(content);
					}
					else {
						@client->WriteString("HTTP/1.1 200\r\n\r\n");
					};
				}
				else {
					select(response->GetCode()) {
						label 202 {
							@client->WriteString("HTTP/1.1 202 Accepted\r\n\r\n");
						}

						label 302 {
							reason := response->GetReason();
							if(reason <> Nil) {
								@client->WriteString("HTTP/1.1 302 Found\r\nLocation: {$reason}\r\nConnection: close\r\n\r\n");
							}
							else {
								@client->WriteString("HTTP/1.1 400\r\n\r\n");
							};
						}

						label 404 {
							@client->WriteString("HTTP/1.1 404 Not Found\r\n\r\n");
						}

						label 410 {
							@client->WriteString("HTTP/1.1 410 Gone\r\n\r\n");
						}

						other {
							@client->WriteString("HTTP/1.1 400\r\n\r\n");
						}
					};
				};
			};
		}
		
		#~
		Get HTTP headers
		@return HTTP headers
		~#
		method : public : GetHeaders() ~ Map<String, String> {
			headers := Map->New()<String, String>;
			
			header := @client->ReadLine();
			while(header <> Nil & header->Size() > 0) {
				if(@is_debug) {
					"header: {$header}"->PrintLine();
				};

				header_parts := header->Split(": ");
				if(header_parts->Size() = 2) {
					headers->Insert(header_parts[0], header_parts[1]);
				};

				header := @client->ReadLine();
			};

			if(@is_debug) {				
				"----\n"->PrintLine();
			};

			return headers;
		}

		#~
		Callback for GET requests
		@param request GET request
		@return content
		~#
		method : virtual : ProcessGet(request : Request) ~ Response;

		#~
		Callback for POST requests
		@param request POST request
		@return content
		~#
		method : virtual : ProcessPost(request : Request) ~ Response;
	}
}
