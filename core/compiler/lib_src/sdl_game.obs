use Game.SDL2;
use Collection;

#~
Game wrapper for SDL2
~#
bundle Game.Framework {
	#~
	Animated sprite sheet
	~#
	class AnimatedImageSprite from ImageSprite {
		@clips : Vector;
		
		New(renderer : Renderer, file : String, clips : Vector) {
			Parent(renderer, file);
			if(@is_ok) {
				@clips := clips;
			};
		}

		New(renderer : Renderer, file : String) {
			Parent(renderer, file);
			if(@is_ok) {
				@clips := Vector->New();
			};
		}

		#~
		Renders sprite
		@param x x-position
		@param y y-position
		@param index sprite image index
		~#
		method : public : Render(x : Int, y : Int, index : Int) ~ Nil {
			if(@is_ok & index > -1 & index < @clips->Size()) {
				@clip := @clips->Get(index)->As(Rect);
				RenderAll(x, y, @clip, @angle, Nil, @flip);
			};
		}

		#~
		Renders sprite
		@param index sprite image index
		~#
		method : public : Render(index : Int) ~ Nil {
			if(@is_ok & index > -1 & index < @clips->Size()) {
				@clip := @clips->Get(index)->As(Rect);
				RenderAll(@position->GetLeft(), @position->GetTop(), @clip, @angle, Nil, @flip);
			};
		}

		#~
		Adds a clip
		~#
		method : public : AddClip(clip : Rect) ~ Nil {
			@clips->AddBack(clip);
		}

		#~
		Get number of clips used in the sprite sheet
		@return number of clips
		~#
		method : public : GetClipCount() ~ Int {
			return @clips->Size();
		}
	}

	#~
	On-screen image
	~#
	class ImageSprite from Sprite {
		@is_ok : Bool;
		@clip : Rect;
		@angle : Float;
		@flip : RendererFlip;

		New(renderer : Renderer, file : String, colorkey : Color, clip : Rect) {
			Parent(renderer);
			@clip := clip;
			@angle := 0;
			@flip := RendererFlip->SDL_FLIP_NONE;
			@is_ok := LoadImage(file, colorkey);
		}

		New(renderer : Renderer, file : String, colorkey : Color) {
			Parent(renderer);
			@angle := 0;
			@flip := RendererFlip->SDL_FLIP_NONE;
			@is_ok := LoadImage(file, colorkey);
		}

		New(renderer : Renderer, file : String) {
			Parent(renderer);
			@angle := 0;
			@flip := RendererFlip->SDL_FLIP_NONE;
			@is_ok := LoadImage(file, Nil);
		}

		#~
		Loads an image
		@param file image to load
		@return true if success, false otherwise
		~#
		method : LoadImage(file : String, colorkey : Color) ~ Bool {
			Free();

			surface := Image->Load(file);
			if(surface->IsNull()) {
				"Unable to load image '{$file}'"->ErrorLine();
				return false;
			};
			
			if(colorkey <> Nil) {
				surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(colorkey->GetR(), colorkey->GetG(), colorkey->GetB()));
			}
			else {
				surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(0, 0xFF, 0xFF));
			};

			texture := surface->CreateTexture(@renderer);
			if(texture->IsNull()) {
				"Unable to create texture!"->ErrorLine();
				return false;
			};

			@render_rect->SetW(surface->GetW());
			@render_rect->SetH(surface->GetH());
		
			surface->Free();

			@texture := texture;
			return @texture <> Nil;
		}

		#~
		Sets the image angle
		@param angle image angle
		~#
		method : public : SetAngle(angle : Float) ~ Nil {
			@angle := angle;
		}

		#~
		Gets the image angle
		@return image angle
		~#
		method : public : GetAngle() ~ Float {
			return @angle;
		}

		#~
		Sets flip of image
		@param flip direction to flip
		~#
		method : public : SetFlip(flip : RendererFlip) ~ Nil {
			@flip := flip;
		}

		#~
		Gets image flip
		@return direction to flip
		~#
		method : public : GetFlip() ~ RendererFlip {
			return @flip;
		}

		#~
		Renders an image
		@param x x-position
		@param y y-position
		~#
		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@is_ok) {
				RenderAll(x, y, Nil, @angle, Nil, @flip);
			};
		}

		#~
		Renders an image based upon position instance
		~#
		method : public : Render() ~ Nil {
			RenderAll(@position->GetLeft(), @position->GetTop(), @clip, @angle, Nil, @flip);
		}
	}

	#~
	On-screen text
	~#
	class TextSprite from Sprite {
		@font : Font;
		@is_ok : Bool;

		New(renderer : Renderer, font : Font) {
			Parent(renderer);
			@font := font;
		}

		#~
		Sets the text font
		@param font TTF
		~#
		method : public : SetFont(font : Font) ~ Nil {
			@font := font;
		}		

		#~
		Renders the set text
		@param text text to render
		@param color color of text
		~#
		method : public : RenderedText(text : String, color : Color := Nil) ~ Nil {
			if(@font <> Nil) {
				Free();

				if(color = Nil) {
					color := Color->New(32, 32, 32);
				};

				# Render text surface
				text_surface := @font->RenderTextSolid(text, color);
				if(text_surface->IsNull()) {
					"Unable to render text surface!"->ErrorLine();
					@is_ok := false;
				};

				texture := text_surface->CreateTexture(@renderer);
				@render_rect->SetW(text_surface->GetW());
				@render_rect->SetH(text_surface->GetH());
				text_surface->Free();
				
				@texture := texture;
				@is_ok := @texture <> Nil;
			}
			else {
				@is_ok := false;
			};
		}

		#~
		Renders an image
		@param x x-position
		@param y y-position
		~#
		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@is_ok) {
				RenderAll(x, y);
			};
		}
	}

	#~
	Bitmap sprite
	~#
	class Sprite implements Shape {
		@texture : Texture;
		@render_rect : Rect;
		@position : Position;
		@renderer : Renderer;

		New(renderer : Renderer) {			
			@renderer := renderer;			
			@render_rect := Rect->New();
			@position := Position->New(@render_rect);
		}
		
		#~
		Sets the current 'x' position
		@param position new position
		~#
		method : public : SetPostion(position : Position) ~ Nil {
			@position := position;
		}

		#~
		Destroys and frees sprite resources
		~#
		method : public : Free() ~ Nil {
			if(@texture <> Nil)	{
				@texture->Destroy();
				@render_rect->SetX(0);
				@render_rect->SetY(0);
			};
		}

		#~
		Sets the color
		@param red red
		@param green green
		@param blue blue
		~#
		method : public : SetColor(red : Int, green : Int, blue : Int) ~ Nil {
			@texture->SetColorMod(red, green, blue);
		}

		#~
		Sets blend mode
		@param blending blend mode
		~#
		method : public : SetBlendMode(blending : BlendMode) ~ Nil {
			@texture->SetBlendMode(blending);
		}

		#~
		Sets alpah
		@param alpha setting
		~#		
		method : public : SetAlpha(alpha : Int) ~ Nil {
			@texture->SetAlphaMod(alpha );
		}

		method : RenderAll(x : Int, y : Int, clip : Rect := Nil, angle : Float := 0.0, 
				center : Point := Nil, flip : RendererFlip := RendererFlip->SDL_FLIP_NONE) ~ Nil {
			@render_rect->SetX(x);
			@render_rect->SetY(y);
			if(clip <> Nil)	{
				@render_rect->SetW(clip->GetW());
				@render_rect->SetH(clip->GetH());
			};
			@renderer->CopyEx(@texture, clip, @render_rect, angle, center, flip);
		}

		#~
		Renders sprite
		@param clip clipping rectangle
		@param angle clipping rectangle
		@param center center point
		@param flip flip direction
		~#
		method : public : Render(clip : Rect := Nil, angle : Float := 0.0, 
				center : Point := Nil, flip : RendererFlip := RendererFlip->SDL_FLIP_NONE) ~ Nil {
			RenderAll(@position->GetLeft(), @position->GetTop(), clip, angle, center, flip);
		}

		#~
		Gets sprite width
		@return sprite width
		~#
		method : public : GetWidth() ~ Int {
			return @render_rect->GetW();
		}

		#~
		Gets sprite height
		@return sprite height
		~#
		method : public : GetHeight() ~ Int {
			return @render_rect->GetH();
		}

		#~
		Gets sprite position
		@return sprite position
		~#
		method : public : GetPosition() ~ Position {
			return @position;
		}

		#~
		Gets left position
		@return left position
		~#
		method : public : GetLeft() ~ Int {
			return @position->GetLeft();
		}

		#~
		Gets top position
		@return top position
		~#
		method : public : GetTop() ~ Int {
			return @position->GetTop();
		}

		#~
		Gets right position
		@return right position
		~#
		method : public : GetRight() ~ Int {
			return @position->GetRight();
		}

		#~
		Gets bottom position
		@return bottom position
		~#
		method : public : GetBottom() ~ Int {
			return @position->GetBottom();
		}

		#~
		Gets the center 'x' position
		@return center 'x' position
		~#
		method : public : GetCenterX() ~ Int {
			return @position->GetCenterX();
		}

		#~
		Gets the center 'y' position
		@return center 'y' position
		~#
		method : public : GetCenterY() ~ Int {
			return @position->GetCenterY();
		}

		#~
		Sets position
		@param x x-position 
		@param y y-position 
		~#
		method : public : Set(x : Int, y : Int) ~ Nil {
			@position->Set(x, y);
		}

		#~
		Sets position
		@param v2 vector position 
		~#
		method : public : Set(v2 : Vector2) ~ Nil {
			@position->Set(v2->GetX(), v2->GetY());
		}

		#~
		Sets left position
		@param x left position
		~#
		method : public : SetLeft(x : Int) ~ Nil {
			@position->SetLeft(x);
		}

		#~
		Sets top position
		@param y top position
		~#
		method : public : SetTop(y : Int) ~ Nil {
			@position->SetTop(y);
		}

		#~
		Sets right position
		@param x2 right position
		~#
		method : public : SetRight(x2 : Int) ~ Nil {
			@position->SetRight(x2);
		}
		
		#~
		Sets bottom position
		@param y2 bottom position
		~#
		method : public : SetBottom(y2 : Int) ~ Nil {
			@position->SetBottom(y2);
		}

		#~
		Sets center 'x' position
		@param x center 'x' position
		~#
		method : public : SetCenterX(x : Int) ~ Nil {
			@position->SetCenterX(x);
		}
		
		#~
		Sets center 'y' position
		@param y center 'y' position
		~#
		method : public : SetCenterY(y : Int) ~ Nil {
			@position->SetCenterY(y);
		}

		#~
		Adds increments the current 'x' position
		@param x increment to the current 'x' position
		~#
		method : public : AddX(x : Int) ~ Nil {
			@position->AddX(x);
		}

		#~
		Adds increments the current 'y' position
		@param x increment to the current 'y' position
		~#
		method : public : AddY(y : Int) ~ Nil {
			@position->AddY(y);
		}
	}

	#~
	Rectangle shape
	~#
	class Rectangle implements Shape {
		@render_rect : Rect;
		@position : Position;
		@renderer : Renderer;
		@color : Color;
		@fill : Bool;

		New(renderer : Renderer, w : Int, h : Int) {
			@renderer := renderer;
			@render_rect := Rect->New(w, h);
			@position := Position->New(@render_rect);
		}

		#~
		Sets the current 'x' position
		@param position new position
		~#
		method : public : SetPostion(position : Position) ~ Nil {
			@position := position;
		}

		method : public : Free() ~ Nil {			
		}

		#~
		Gets sprite width
		@return sprite width
		~#
		method : public : GetWidth() ~ Int {
			return @render_rect->GetW();
		}

		#~
		Gets sprite height
		@return sprite height
		~#
		method : public : GetHeight() ~ Int {
			return @render_rect->GetH();
		}

		#~
		Gets left position
		@return left position
		~#
		method : public : GetLeft() ~ Int {
			return @position->GetLeft();
		}

		#~
		Gets top position
		@return top position
		~#
		method : public : GetTop() ~ Int {
			return @position->GetTop();
		}

		#~
		Gets right position
		@return right position
		~#
		method : public : GetRight() ~ Int {
			return @position->GetRight();
		}

		#~
		Gets bottom position
		@return bottom position
		~#
		method : public : GetBottom() ~ Int {
			return @position->GetBottom();
		}

		#~
		Gets the center 'x' position
		@return center 'x' position
		~#
		method : public : GetCenterX() ~ Int {
			return @position->GetCenterX();
		}

		method : public : GetCenterY() ~ Int {
			return @position->GetCenterY();
		}

		#~
		Sets center 'y' position
		@param y center 'y' position
		~#
		method : public : SetCenterX(x : Int) ~ Nil {
			@position->SetCenterX(x);
		}
		
		#~
		Sets center 'y' position
		@param y center 'y' position
		~#
		method : public : SetCenterY(y : Int) ~ Nil {
			@position->SetCenterY(y);
		}

		#~
		Sets position
		@param x x-position 
		@param y y-position 
		~#
		method : public : Set(x : Int, y : Int) ~ Nil {
			@position->Set(x, y);
		}

		#~
		Sets position
		@param v2 vector position 
		~#
		method : public : Set(v2 : Vector2) ~ Nil {
			@position->Set(v2->GetX(), v2->GetY());
		}

		#~
		Sets left position
		@param x left position
		~#
		method : public : SetLeft(x : Int) ~ Nil {
			@position->SetLeft(x);
		}

		#~
		Sets top position
		@param y top position
		~#
		method : public : SetTop(y : Int) ~ Nil {
			@position->SetTop(y);
		}

		#~
		Sets right position
		@param x2 right position
		~#
		method : public : SetRight(x2 : Int) ~ Nil {
			@position->SetRight(x2);
		}

		#~
		Sets bottom position
		@param y2 bottom position
		~#
		method : public : SetBottom(y2 : Int) ~ Nil {
			@position->SetBottom(y2);
		}

		#~
		Adds increments the current 'x' position
		@param x increment to the current 'x' position
		~#
		method : public : AddX(x : Int) ~ Nil {
			@position->AddX(x);
		}

		#~
		Adds increments the current 'y' position
		@param x increment to the current 'y' position
		~#
		method : public : AddY(y : Int) ~ Nil {
			@position->AddY(y);
		}

		#~
		Gets sprite position
		@return sprite position
		~#
		method : public : GetPosition() ~ Position {
			return @position;
		}

		#~
		Sets rectangle color
		@param color color
		~#
		method : public : SetColor(color : Color) ~ Nil {
			@color := color;
		}

		#~
		Gets rectangle color
		@return color
		~#
		method : public : GetColor() ~ Color {
			return @color;
		}

		#~
		Sets color fill
		@param fill if true, color fills rectangle; false otherwise
		~#
		method : public : SetFill(fill : Bool) ~ Nil {
			@fill := fill;
		}

		#~
		Sets color fill
		@return if true, color fills rectangle; false otherwise
		~#
		method : public : GetFill() ~ Bool {
			return @fill;
		}

		#~
		Renders an image based upon position instance
		~#
		method : public : Render() ~ Nil {
			Render(@position->GetLeft(), @position->GetTop());
		}

		#~
		Renders an image
		@param x x-position
		@param y y-position
		~#
		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@color = Nil) {
				@color := Color->New();
			};

			@render_rect->SetX(x);
			@render_rect->SetY(y);
			@renderer->SetDrawColor(@color->GetR(), @color->GetG(), @color->GetB(), @color->GetA());

			if(@fill) {
				@renderer->FillRect(@render_rect);
			}
			else {
				@renderer->DrawRect(@render_rect);
			};
		}
	}

	#~
	Shape position
	~#
	class Position {
		@rect : Rect;
		@x : Int;
		@y : Int;

		New(rect : Rect) {
			@rect := rect;
		}

		New(x : Int, y : Int, w : Int, h : Int) {
			@x := x;
			@y := y;
			@rect := Rect->New(0, 0, w, h);
		}

		New(w : Int, h : Int) {
			@rect := Rect->New(0, 0, w, h);
		}

		method : public : GetRect() ~ Rect {
			return @rect;
		}

		# --- Sets
		method : public : Set(x : Int, y : Int) ~ Nil {
			@x := x - @rect->GetW() / 2;
			@y := y - @rect->GetH() / 2;
		}

		method : public : SetCenterX(x : Int) ~ Nil {
			@x := x - @rect->GetW() / 2;
		}
		
		method : public : SetCenterY(y : Int) ~ Nil {
			@y := y - @rect->GetH() / 2;
		}

		method : public : SetLeft(x : Int) ~ Nil {
			@x := x;
		}

		method : public : SetTop(y : Int) ~ Nil {
			@y := y;
		}

		method : public : AddX(x : Int) ~ Nil {
			@x += x;
		}

		method : public : AddY(y : Int) ~ Nil {
			@y += y;
		}

		method : public : SetRight(x2 : Int) ~ Nil {
			@x := x2 - @rect->GetW();
		}

		method : public : SetBottom(y2 : Int) ~ Nil {
			@y := y2 - @rect->GetH();
		}

		# --- Gets
		method : public : GetLeft() ~ Int {
			return @x;
		}

		method : public : GetRight() ~ Int {
			return @x + @rect->GetW();
		}

		method : public : GetCenterX() ~ Int {
			return @x + @rect->GetW() / 2;
		}

		method : public : GetTop() ~ Int {
			return @y;
		}

		method : public : GetBottom() ~ Int {
			return @y + @rect->GetH();
		}

		method : public : GetCenterY() ~ Int {
			return @y + @rect->GetH() / 2;
		}

		method : public : native : Overlaps(pos : Position) ~ Bool {
			y := GetTop();
			pos_y2 := pos->GetBottom();

			pos_y := pos->GetTop();
			y2 := GetBottom();

			pos_x := pos->GetLeft();
			x2 := GetRight();

			x := GetLeft();
			pos_x2 := pos->GetRight();
			
			return <>(y2 <= pos_y | y >= pos_y2 | x >= pos_x2 | x2 <= pos_x);
		}

#~
		method : public : Contains(x : Int, y : Int) ~ Bool {
			return false;
		}
~#		
	}

	interface Shape {
		method : public : virtual : GetWidth() ~ Int;
		method : public : virtual : GetHeight() ~ Int;
		method : public : virtual : GetPosition() ~ Position;
		method : public : virtual : Free() ~ Nil;
	}

	class GameFramework {
		@is_ok : Bool;
		@screen_width : Int;
		@screen_height : Int;
		@renderer : Renderer;

		@clear_color : Color;
		@frame_rate : Int;
		@fps : Int;
		@frame_start : Int;

		@shapes : Vector;

		@font : Font;
		@joystick : Joystick;

		@event : Event;

		@debug_msg : static : String;

		New(screen_width : Int, screen_height : Int, title : String, fps : Int, init_flags : Int) {
			@fps := fps;
			@frame_rate := 1000 / @fps;
			@shapes := Vector->New();
			
			@is_ok := Init(screen_width, screen_height, title, init_flags);
		}

		New(screen_width : Int, screen_height : Int, title : String) {
			init_flags := HardwareFlags->SDL_INIT_VIDEO->As(Int) or
				HardwareFlags->SDL_INIT_AUDIO->As(Int) or 
				HardwareFlags->SDL_INIT_JOYSTICK->As(Int);
			@fps := 60;	
			@frame_rate := 1000 / 60;
			@shapes := Vector->New();
			
			@is_ok := Init(screen_width, screen_height, title, init_flags);
		}

		function : Debug(debug_msg : String) ~ Nil {
			if(@debug_msg = Nil) {
				@debug_msg := debug_msg;
				@debug_msg->ErrorLine();
			}
			else if(<>debug_msg->Equals(@debug_msg)) {
				@debug_msg := debug_msg;
				@debug_msg->ErrorLine();
			};
		}
		
		method : Init(screen_width : Int, screen_height : Int, title : String, init_flags : Int) ~ Bool {
			success := true;

			@screen_width := screen_width;
			@screen_height := screen_height;

			if(Core->Init(init_flags) < 0) {
				"SDL could not initialize!"->ErrorLine();
				return false;
			};
			
			if(<>Hints->Set("SDL_RENDER_SCALE_QUALITY", "1")) {
				"Warning: Linear texture filtering not enabled!"->ErrorLine();
				return false;
			};

			@window := Window->New(title, WindowFlags->SDL_WINDOWPOS_UNDEFINED, 
				WindowFlags->SDL_WINDOWPOS_UNDEFINED, @screen_width, @screen_height, 
				WindowFlags->SDL_WINDOW_SHOWN);
			if(@window->IsNull()) {
				"Cannot create window!"->ErrorLine();
				return false;
			};

			@renderer := Renderer->New(@window, -1, 
				RendererFlags->SDL_RENDERER_ACCELERATED and RendererFlags->SDL_RENDERER_PRESENTVSYNC);
			if(@renderer->IsNull()) {
				"Cannot create renderer!"->ErrorLine();
				return false;
			};
			@renderer->SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);

			img_flags := ImageFlags->IMG_INIT_PNG->As(Int);
			if((Image->Init(img_flags) and img_flags) = 0) {
				"SDL image could not initialize!"->ErrorLine();
				return false;
			};

			if(Font->Init() < 0) {
				"SDL_ttf could not initialize!"->ErrorLine();
				return false;
			};

			@font := Font->New("../lib/sdl/fonts/lazy.ttf", 18);
			if(@font->IsNull()) {
				"Failed to load font!"->ErrorLine();
				return false;
			};

			if(<>Mixer->OpenAudio(44100, Mixer->Flags->MIX_DEFAULT_FORMAT, 2, 2048)) {
				"SDL mixer could not initialize!"->ErrorLine();
				return false;
			};

			if(Joystick->Number() < 1) {
				"Warning: No joysticks connected!"->ErrorLine();
			};
			@joystick := Joystick->New(0);

			@event := Event->New();
			
			return true;
		}

		method : public : IsOk() ~ Bool {
			return @is_ok;
		}		

		method : public : GetRenderer() ~ Renderer {
			return @renderer;
		}

		method : public : GetEvent() ~ Event {
			return @event;
		}

		method : public : FrameStart() ~ Nil {
			@frame_start := Timer->GetTicks();
		}

		method : public : GetFps() ~ Int {
			return @fps;
		}

		method : public : FrameEnd() ~ Nil {
			end := @frame_start - Timer->GetTicks();
			if(end < @frame_rate) {
				Timer->Delay(@frame_rate - end);
			};
		}

		method : public : SetClearColor(color : Color) ~ Nil {
			@clear_color := color;
		}

		method : public : SetFont(font : Font) ~ Nil {
			@font := font;
		}

		method : public : GetClearColor() ~ Color {
			return @clear_color;
		}

		method : public : Clear() ~ Nil {
			if(@clear_color = Nil) {
				@renderer->SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
			}
			else {
				@renderer->SetDrawColor(@clear_color->GetR(), @clear_color->GetG(), 
					@clear_color->GetB(), @clear_color->GetA());
			};
			@renderer->Clear();
		}

		method : public : Show() ~ Nil {
			@renderer->Present();
		}

		method : public : AddRectangle(w : Int, h : Int) ~ Rectangle {
			shape := Rectangle->New(@renderer, w, h);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : AddTextSprite() ~ TextSprite {
			shape := TextSprite->New(@renderer, @font);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : AddImageSprite(file : String, colorkey : Color, render_rect : Rect) ~ ImageSprite {
			shape := ImageSprite->New(@renderer, file, colorkey, render_rect);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : AddImageSprite(file : String, colorkey : Color) ~ ImageSprite {
			shape := ImageSprite->New(@renderer, file, colorkey);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : AddImageSprite(file : String) ~ ImageSprite {
			shape := ImageSprite->New(@renderer, file);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : AddAnimatedImageSprite(file : String, clips : Vector) ~ AnimatedImageSprite {
			shape := AnimatedImageSprite->New(@renderer, file, clips);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : AddAnimatedImageSprite(file : String) ~ AnimatedImageSprite {
			shape := AnimatedImageSprite->New(@renderer, file);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : RemoveSprite(shape : Shape) ~ Bool {
			found := -1;
			
			for(i := 0; i < @shapes->Size() & found < 0; i +=1;) {
				if(@shapes->Get(i) = shape) {
					found := i;
				};
			};

			if(found > -1) {
				@shapes->Remove(found);
				shape->Free();

				return true;
			};

			return false;
		}

		method : public : FreeShapes() ~ Nil {
			each(i : @shapes) {
				shape := @shapes->Get(i)->As(Shape);
				shape->Free();
			};
		}

		method : public : Quit() ~ Nil {
			each(i : @shapes) {
				shape := @shapes->Get(i)->As(Shape);
				shape->Free();
			};

			if(@event <> Nil) {
				@event->Free();
			};

			if(@joystick <> Nil) {
				@joystick->Free();
			};
			
			Image->Quit();
			Font->Quit();
			Mixer->Quit();
			Core->Quit();
		}
	}

	class Vector2 {
		@x : Float;
		@y : Float;

		New() {
			@x := 0.0;
			@y := 0.0;
		}

		New(x : Float, y : Float) {
			@x := x;
			@y := y;
		}

		method : public : GetX() ~ Float {
			return @x;
		}

		method : public : GetY() ~ Float {
			return @y;
		}

		method : public : SetX(x : Float) ~ Nil {
			@x := x;
		}

		method : public : SetY(y : Float) ~ Nil {
			@y := y;
		}

		method : public : MagnitudeSquared() ~ Float {
			return @x*@x + @y*@y;
		}

		method : public : Magnitude() ~ Float {
			return MagnitudeSquared()->SquareRoot();
		}		

		method : public : Normalize() ~ Vector2 {
			mag := Magnitude();
 			if(mag <> 0) {
   				return Div(@self, mag);
			};

			return Vector2->New();
		}

		method : public : ToString() ~ String {
			return "{$@x}, {$@y}";
		}

		method : public : AddX(rhs : Vector2) ~ Nil {
			@x += rhs->GetX();
		}

		method : public : SubX(rhs : Vector2) ~ Nil {
			@x -= rhs->GetX();
		}

		method : public : MulX(rhs : Vector2) ~ Nil {
			@x *= rhs->GetX();
		}

		method : public : DivX(rhs : Vector2) ~ Nil {
			@x /= rhs->GetX();
		}

		method : public : AddX(x : Int) ~ Nil {
			@x += x;
		}

		method : public : SubX(x : Int) ~ Nil {
			@x -= x;
		}

		method : public : MulX(x : Int) ~ Nil {
			@x *= x;
		}

		method : public : DivX(x : Int) ~ Nil {
			@x /= x;
		}

		method : public : AddY(rhs : Vector2) ~ Nil {
			@y += rhs->GetY();
		}

		method : public : SubY(rhs : Vector2) ~ Nil {
			@y -= rhs->GetY();
		}

		method : public : MulY(rhs : Vector2) ~ Nil {
			@y *= rhs->GetY();
		}

		method : public : DivY(rhs : Vector2) ~ Nil {
			@y /= rhs->GetY();
		}

		method : public : AddY(y : Int) ~ Nil {
			@y += y;
		}

		method : public : SubY(y : Int) ~ Nil {
			@y -= y;
		}

		method : public : MulY(y : Int) ~ Nil {
			@y *= y;
		}

		method : public : DivY(y : Int) ~ Nil {
			@y /= y;
		}

		method : public : Add(rhs : Vector2) ~ Nil {
			@x += rhs->GetX();
			@y += rhs->GetY();
		}

		method : public : Sub(rhs : Vector2) ~ Nil {
			@x -= rhs->GetX();
			@y -= rhs->GetY();
		}

		method : public : Mul(rhs : Vector2) ~ Nil {
			@x *= rhs->GetX();
			@y *= rhs->GetY();
		}

		method : public : Div(rhs : Vector2) ~ Nil {
			@x /= rhs->GetX();
			@y /= rhs->GetY();
		}

		method : public : Mul(v : Float) ~ Nil {
			@x *= v;
			@y *= v;
		}

		method : public : Div(v : Float) ~ Nil {
			@x /= v;
			@y /= v;
		}

		method : public : Limit(v : Float) ~ Nil {
			Limit(v, v);
		}

		method : public : Limit(x : Float, y : Float) ~ Nil {
			if(@x > x) {
				@x := x;
			};

			if(@y > y) {
				@y := y;
			};
		}

		method : public : Zero() ~ Nil {
			@x := 0.0;
			@y := 0.0;
		}
		
		function : Add(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() + rhs->GetX(), lhs->GetY() + rhs->GetY());
		}

		function : Sub(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() - rhs->GetX(), lhs->GetY() - rhs->GetY());
		}

		function : Mul(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() * rhs->GetX(), lhs->GetY() * rhs->GetY());
		}

		function : Div(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() / rhs->GetX(), lhs->GetY() / rhs->GetY());
		}

		function : Mul(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() * v, rhs->GetY() * v);
		}

		function : Div(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() / v, rhs->GetY() / v);
		}

		function : MulX(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() * v, rhs->GetY());
		}

		function : DivX(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() / v, rhs->GetY());
		}

		function : MulY(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX(), rhs->GetY() * v);
		}

		function : DivY(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX(), rhs->GetY() / v);
		}

		function : Dot(lhs : Vector2, rhs : Vector2) ~ Float {
			return lhs->GetX()*rhs->GetX() + lhs->GetY()*rhs->GetY();
		}
	}
}	