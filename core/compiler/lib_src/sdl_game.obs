#~~
Objeck 2D gaming support
Copyright (c) 2018 Randy Hollines
~~#

use Game.SDL2;
use Collection;

#~
Game wrapper for SDL2
~#
bundle Game.Framework {
	#~
	Animated sprite sheet
	~#
	class AnimatedImageSprite from ImageSprite {
		@clips : Vector;
		
		New(renderer : Renderer, file : String, clips : Vector) {
			Parent(renderer, file);
			if(@is_ok) {
				@clips := clips;
			};
		}

		New(renderer : Renderer, file : String) {
			Parent(renderer, file);
			if(@is_ok) {
				@clips := Vector->New();
			};
		}

		#~
		Renders sprite
		@param x x-position
		@param y y-position
		@param index sprite image index
		~#
		method : public : Render(x : Int, y : Int, index : Int) ~ Nil {
			if(@is_ok & index > -1 & index < @clips->Size()) {
				@clip := @clips->Get(index)->As(Rect);
				RenderAll(x, y, @clip, @angle, Nil, @flip);
			};
		}

		#~
		Renders sprite
		@param index sprite image index
		~#
		method : public : Render(index : Int) ~ Nil {
			if(@is_ok & index > -1 & index < @clips->Size()) {
				@clip := @clips->Get(index)->As(Rect);
				RenderAll(@position->GetLeft(), @position->GetTop(), @clip, @angle, Nil, @flip);
			};
		}

		#~
		Adds a clip
		@param clip clip
		~#
		method : public : AddClip(clip : Rect) ~ Nil {
			@clips->AddBack(clip);
		}

		#~
		Get number of clips used in the sprite sheet
		@return number of clips
		~#
		method : public : GetClipCount() ~ Int {
			return @clips->Size();
		}
	}

	#~
	Titled image sprite
	~#
	class TitledImageSprite {
		@texture : Texture;
		@renderer : Renderer;
		@is_ok : Bool;
		@width : Int;
		@height : Int;
		@shapes : List;

		New(renderer : Renderer, file : String) {
			@renderer := renderer;
			@shapes := List->New();

			@is_ok := LoadImage(file, Nil);
		}

		New(renderer : Renderer, file : String, colorkey : Color) {
			@renderer := renderer;
			@shapes := List->New();

			@is_ok := LoadImage(file, colorkey);
		}

		#~
		Initialization status flag
		@return true if initialized, false otherwise
		~#
		method : public : IsOk() ~ Bool {
			return @is_ok;
		}

		#~
		Destroys and frees sprite resources
		~#
		method : public : Free() ~ Nil {
			if(@texture <> Nil)	{
				@texture->Destroy();
			};
			
			@shapes->Empty();
		}

		#~
		Loads an image
		@param file image to load
		@param colorkey key color
		@return true if success, false otherwise
		~#
		method : LoadImage(file : String, colorkey : Color) ~ Bool {
			Free();
			
			surface := Image->Load(file);
			if(surface->IsNull()) {
				"Unable to load image '{$file}'!"->ErrorLine();
				return false;
			};

			if(colorkey <> Nil) {
				surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(colorkey->GetR(), colorkey->GetG(), colorkey->GetB()));
			}
			else {
				surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(0, 0xFF, 0xFF));
			};

			texture := surface->CreateTexture(@renderer);
			if(texture->IsNull()) {
				"Unable to create texture!"->ErrorLine();
				return false;
			};

			@width := surface->GetW();
			@height := surface->GetH();
			
			surface->Free();
			@texture := texture;
			return @texture <> Nil;
		}

		method : public : AddTile(x : Int, y : Int) ~ ImageSprite {
			sprite := ImageSprite->New(@renderer, @texture);
			sprite->SetPostion(Position->New(x, y, @width, @height));
			@shapes->AddBack(sprite);

			return sprite;
		}

		method : public : RemoveTile(sprite : ImageSprite) ~ Bool {
			@shapes->Rewind();
			while(@shapes->More()) {
				shape := @shapes->Get()->As(ImageSprite);
				if(sprite = shape) {
					@shapes->Remove();
					return true;
				};
				@shapes->Next();
			};

			return false;
		}

		#~
		Increments the current x-position
		@param x increment to the current x-position
		~#
		method : public : AddX(x : Int) ~ Nil {
			if(@is_ok) {	
				@shapes->Rewind();
				while(@shapes->More()) {
					shape := @shapes->Get()->As(ImageSprite);
					shape->GetPosition()->AddX(x);
					@shapes->Next();
				};
			};
		}

		#~
		Increments the current y-position
		@param y increment to the current y-position
		~#
		method : public : AddY(y : Int) ~ Nil {
			if(@is_ok) {	
				@shapes->Rewind();
				while(@shapes->More()) {
					shape := @shapes->Get()->As(ImageSprite);
					shape->GetPosition()->AddY(y);
					@shapes->Next();
				};
			};
		}

		method : public : Render() ~ Nil {
			if(@is_ok) {	
				@shapes->Rewind();
				while(@shapes->More()) {
					shape := @shapes->Get()->As(ImageSprite);
					shape->Render();
					@shapes->Next();
				};
			};
		}
	}

	#~
	On-screen image
	~#
	class ImageSprite from Sprite {
		@is_ok : Bool;
		@clip : Rect;
		@angle : Float;
		@flip : RendererFlip;

		New(renderer : Renderer, file : String, colorkey : Color, clip : Rect) {
			Parent(renderer);
			@clip := clip;
			@angle := 0.0;
			@flip := RendererFlip->SDL_FLIP_NONE;
			@is_ok := LoadImage(file, colorkey);
		}

		New(renderer : Renderer, file : String, colorkey : Color) {
			Parent(renderer);
			@angle := 0.0;
			@flip := RendererFlip->SDL_FLIP_NONE;
			@is_ok := LoadImage(file, colorkey);
		}

		New(renderer : Renderer, file : String) {
			Parent(renderer);
			@angle := 0.0;
			@flip := RendererFlip->SDL_FLIP_NONE;
			@is_ok := LoadImage(file, Nil);
		}

		New(renderer : Renderer, texture : Texture) {
			Parent(renderer);
			@texture := texture;
			@is_ok := true;
			@angle := 0.0;
			@flip := RendererFlip->SDL_FLIP_NONE;
		}

		#~
		Initialization status flag
		@return true if initialized, false otherwise
		~#
		method : public : IsOk() ~ Bool {
			return @is_ok;
		}

		#~
		Loads an image
		@param file image to load
		@param colorkey key color
		@return true if success, false otherwise
		~#
		method : LoadImage(file : String, colorkey : Color) ~ Bool {
			Free();
			
			surface := Image->Load(file);
			if(surface->IsNull()) {
				"Unable to load image '{$file}'!"->ErrorLine();
				return false;
			};

			if(colorkey <> Nil) {
				surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(colorkey->GetR(), colorkey->GetG(), colorkey->GetB()));
			}
			else {
				surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(0, 0xFF, 0xFF));
			};

			texture := surface->CreateTexture(@renderer);
			if(texture->IsNull()) {
				"Unable to create texture!"->ErrorLine();
				return false;
			};

			@render_rect->SetW(surface->GetW());
			@render_rect->SetH(surface->GetH());
			
			surface->Free();
			@texture := texture;
			return @texture <> Nil;
		}

		#~
		Sets the image angle
		@param angle image angle
		~#
		method : public : SetAngle(angle : Float) ~ Nil {
			@angle := angle;
		}

		#~
		Gets the image angle
		@return image angle
		~#
		method : public : GetAngle() ~ Float {
			return @angle;
		}

		#~
		Sets flip of image
		@param flip direction to flip
		~#
		method : public : SetFlip(flip : RendererFlip) ~ Nil {
			@flip := flip;
		}

		#~
		Gets image flip
		@return direction to flip
		~#
		method : public : GetFlip() ~ RendererFlip {
			return @flip;
		}

		#~
		Renders an image
		@param x x-position
		@param y y-position
		~#
		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@is_ok) {
				RenderAll(x, y, Nil, @angle, Nil, @flip);
			};
		}

		#~
		Renders an image based upon position instance
		~#
		method : public : Render() ~ Nil {
			RenderAll(@position->GetLeft(), @position->GetTop(), @clip, @angle, Nil, @flip);
		}
	}

	#~
	On-screen text
	~#
	class TextSprite from Sprite {
		@font : Font;
		@is_ok : Bool;

		New(renderer : Renderer, font : Font) {
			Parent(renderer);
			@font := font;
		}

		#~
		Initialization status flag
		@return true if initialized, false otherwise
		~#
		method : public : IsOk() ~ Bool {
			return @is_ok;
		}

		#~
		Sets the text font
		@param font TTF
		~#
		method : public : SetFont(font : Font) ~ Nil {
			@font := font;
		}		

		#~
		Renders the set text
		@param text text to render
		@param color color of text
		~#
		method : public : RenderedText(text : String, color : Color := Nil) ~ Nil {
			if(@font <> Nil) {
				Free();

				if(color = Nil) {
					color := Color->New(32, 32, 32);
				};

				# Render text surface
				text_surface := @font->RenderTextSolid(text, color);
				if(text_surface->IsNull()) {
					"Unable to render text surface!"->ErrorLine();
					@is_ok := false;
				};

				texture := text_surface->CreateTexture(@renderer);
				@render_rect->SetW(text_surface->GetW());
				@render_rect->SetH(text_surface->GetH());
				text_surface->Free();
				
				@texture := texture;
				@is_ok := @texture <> Nil;
			}
			else {
				@is_ok := false;
			};
		}

		#~
		Renders an image
		@param x x-position
		@param y y-position
		~#
		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@is_ok) {
				RenderAll(x, y);
			};
		}
	}

	#~
	Bitmap sprite
	~#
	class Sprite implements Shape {
		@texture : Texture;
		@render_rect : Rect;
		@position : Position;
		@renderer : Renderer;
		@scale : Float;
		@scaled : Bool;

		New(renderer : Renderer) {			
			@renderer := renderer;			
			@render_rect := Rect->New();
			@position := Position->New(@render_rect);
			@scale := 1.0;
		}
		
		#~
		Sets scaling percentage 
		@param scale scaling percentage 
		~#
		method : public : SetScale(scale : Float) ~ Nil {
			@scale := scale;
			@scaled := false;
		}

		#~
		Gets scaling percentage 
		@return scaling percentage 
		~#
		method : public : GetScale() ~ Float {
			return @scale;
		}

		#~
		Sets the current x-position
		@param position new position
		~#
		method : public : SetPostion(position : Position) ~ Nil {
			@position := position;
		}

		#~
		Destroys and frees sprite resources
		~#
		method : public : Free() ~ Nil {
			if(@texture <> Nil)	{
				@texture->Destroy();
				@render_rect->SetX(0);
				@render_rect->SetY(0);
			};
		}

		#~
		Sets the color
		@param red red
		@param green green
		@param blue blue
		~#
		method : public : SetColor(red : Int, green : Int, blue : Int) ~ Nil {
			@texture->SetColorMod(red, green, blue);
		}

		#~
		Sets blend mode
		@param blending blend mode
		~#
		method : public : SetBlendMode(blending : BlendMode) ~ Nil {
			@texture->SetBlendMode(blending);
		}

		#~
		Sets alpha
		@param alpha setting
		~#		
		method : public : SetAlpha(alpha : Int) ~ Nil {
			@texture->SetAlphaMod(alpha );
		}

		method : RenderAll(x : Int, y : Int, clip : Rect := Nil, angle : Float := 0.0, 
				center : Point := Nil, flip : RendererFlip := RendererFlip->SDL_FLIP_NONE) ~ Nil {
			@render_rect->SetX(x);
			@render_rect->SetY(y);
			
			if(<>@scaled) {
				format := IntHolder->New();
				access := IntHolder->New();
				width := IntHolder->New();
				height := IntHolder->New();
				@texture->Query(format, access, width, height);
				@render_rect->SetW(width->Get() * @scale);
				@render_rect->SetH(height->Get() * @scale);
				@scaled := true;
			};

			if(clip <> Nil)	{
				@render_rect->SetW(clip->GetW() * @scale);
				@render_rect->SetH(clip->GetH() * @scale);
			};

			@renderer->CopyEx(@texture, clip, @render_rect, angle, center, flip);
		}

		#~
		Renders sprite
		@param clip clipping rectangle
		@param angle clipping rectangle
		@param center center point
		@param flip flip direction
		~#
		method : public : Render(x : Int, y : Int, clip : Rect := Nil, angle : Float := 0.0, 
				center : Point := Nil, flip : RendererFlip := RendererFlip->SDL_FLIP_NONE) ~ Nil {
			RenderAll(x, y, clip, angle, center, flip);
		}

		#~
		Gets sprite width
		@return sprite width
		~#
		method : public : GetWidth() ~ Int {
			return @render_rect->GetW();
		}

		#~
		Gets sprite height
		@return sprite height
		~#
		method : public : GetHeight() ~ Int {
			return @render_rect->GetH();
		}

		#~
		Gets sprite position
		@return sprite position
		~#
		method : public : GetPosition() ~ Position {
			return @position;
		}

		#~
		Gets left position
		@return left position
		~#
		method : public : GetLeft() ~ Int {
			return @position->GetLeft();
		}

		#~
		Gets top position
		@return top position
		~#
		method : public : GetTop() ~ Int {
			return @position->GetTop();
		}

		#~
		Gets right position
		@return right position
		~#
		method : public : GetRight() ~ Int {
			return @position->GetRight();
		}

		#~
		Gets bottom position
		@return bottom position
		~#
		method : public : GetBottom() ~ Int {
			return @position->GetBottom();
		}

		#~
		Gets the center x-position
		@return center x-position
		~#
		method : public : GetCenterX() ~ Int {
			return @position->GetCenterX();
		}

		#~
		Gets the center y-position
		@return center y-position
		~#
		method : public : GetCenterY() ~ Int {
			return @position->GetCenterY();
		}

		#~
		Sets upper left position
		@param x x-position 
		@param y y-position 
		~#
		method : public : Set(x : Int, y : Int) ~ Nil {
			@position->Set(x, y);
		}

		#~
		Sets cener position
		@param x x-position 
		@param y y-position 
		~#
		method : public : SetCenter(x : Int, y : Int) ~ Nil {
			@position->SetCenter(x, y);
		}

		#~
		Sets position
		@param v2 vector position 
		~#
		method : public : Set(v2 : Vector2) ~ Nil {
			@position->Set(v2->GetX(), v2->GetY());
		}

		#~
		Sets left position
		@param x left position
		~#
		method : public : SetLeft(x : Int) ~ Nil {
			@position->SetLeft(x);
		}

		#~
		Sets top position
		@param y top position
		~#
		method : public : SetTop(y : Int) ~ Nil {
			@position->SetTop(y);
		}

		#~
		Sets right position
		@param x2 right position
		~#
		method : public : SetRight(x2 : Int) ~ Nil {
			@position->SetRight(x2);
		}
		
		#~
		Sets bottom position
		@param y2 bottom position
		~#
		method : public : SetBottom(y2 : Int) ~ Nil {
			@position->SetBottom(y2);
		}

		#~
		Sets center x-position
		@param x center x-position
		~#
		method : public : SetCenterX(x : Int) ~ Nil {
			@position->SetCenterX(x);
		}
		
		#~
		Sets center y-position
		@param y center y-position
		~#
		method : public : SetCenterY(y : Int) ~ Nil {
			@position->SetCenterY(y);
		}

		#~
		Increments the current x-position
		@param x increment to the current x-position
		~#
		method : public : AddX(x : Int) ~ Nil {
			@position->AddX(x);
		}

		#~
		Increments the current y-position
		@param y increment to the current y-position
		~#
		method : public : AddY(y : Int) ~ Nil {
			@position->AddY(y);
		}
	}

	#~
	Rectangle shape
	~#
	class Rectangle implements Shape {
		@render_rect : Rect;
		@position : Position;
		@renderer : Renderer;
		@color : Color;
		@fill : Bool;

		New(renderer : Renderer, w : Int, h : Int) {
			@renderer := renderer;
			@render_rect := Rect->New(w, h);
			@position := Position->New(@render_rect);
		}

		#~
		Sets the current x-position
		@param position new position
		~#
		method : public : SetPostion(position : Position) ~ Nil {
			@position := position;
		}

		method : public : Free() ~ Nil {			
		}

		#~
		Gets sprite width
		@return sprite width
		~#
		method : public : GetWidth() ~ Int {
			return @render_rect->GetW();
		}

		#~
		Gets sprite height
		@return sprite height
		~#
		method : public : GetHeight() ~ Int {
			return @render_rect->GetH();
		}

		#~
		Gets left position
		@return left position
		~#
		method : public : GetLeft() ~ Int {
			return @position->GetLeft();
		}

		#~
		Gets top position
		@return top position
		~#
		method : public : GetTop() ~ Int {
			return @position->GetTop();
		}

		#~
		Gets right position
		@return right position
		~#
		method : public : GetRight() ~ Int {
			return @position->GetRight();
		}

		#~
		Gets bottom position
		@return bottom position
		~#
		method : public : GetBottom() ~ Int {
			return @position->GetBottom();
		}

		#~
		Gets the center x-position
		@return center x-position
		~#
		method : public : GetCenterX() ~ Int {
			return @position->GetCenterX();
		}

		method : public : GetCenterY() ~ Int {
			return @position->GetCenterY();
		}

		#~
		Sets center y-position
		@param x center y-position
		~#
		method : public : SetCenterX(x : Int) ~ Nil {
			@position->SetCenterX(x);
		}
		
		#~
		Sets center y-position
		@param y center y-position
		~#
		method : public : SetCenterY(y : Int) ~ Nil {
			@position->SetCenterY(y);
		}

		#~
		Sets left upper position
		@param x x-position 
		@param y y-position 
		~#
		method : public : Set(x : Int, y : Int) ~ Nil {
			@position->Set(x, y);
		}

		#~
		Sets center position
		@param x x-position 
		@param y y-position 
		~#
		method : public : SetCenter(x : Int, y : Int) ~ Nil {
			@position->SetCenter(x, y);
		}

		#~
		Sets position
		@param v2 vector position 
		~#
		method : public : Set(v2 : Vector2) ~ Nil {
			@position->Set(v2->GetX(), v2->GetY());
		}

		#~
		Sets left position
		@param x left position
		~#
		method : public : SetLeft(x : Int) ~ Nil {
			@position->SetLeft(x);
		}

		#~
		Sets top position
		@param y top position
		~#
		method : public : SetTop(y : Int) ~ Nil {
			@position->SetTop(y);
		}

		#~
		Sets right position
		@param x2 right position
		~#
		method : public : SetRight(x2 : Int) ~ Nil {
			@position->SetRight(x2);
		}

		#~
		Sets bottom position
		@param y2 bottom position
		~#
		method : public : SetBottom(y2 : Int) ~ Nil {
			@position->SetBottom(y2);
		}

		#~
		Increments the current x-position
		@param x increment to the current x-position
		~#
		method : public : AddX(x : Int) ~ Nil {
			@position->AddX(x);
		}

		#~
		Increments the current y-position
		@param y increment to the current y-position
		~#
		method : public : AddY(y : Int) ~ Nil {
			@position->AddY(y);
		}

		#~
		Gets sprite position
		@return sprite position
		~#
		method : public : GetPosition() ~ Position {
			return @position;
		}

		#~
		Sets rectangle color
		@param color color
		~#
		method : public : SetColor(color : Color) ~ Nil {
			@color := color;
		}

		#~
		Gets rectangle color
		@return color
		~#
		method : public : GetColor() ~ Color {
			return @color;
		}

		#~
		Sets color fill
		@param fill if true, color fills rectangle; false otherwise
		~#
		method : public : SetFill(fill : Bool) ~ Nil {
			@fill := fill;
		}

		#~
		Sets color fill
		@return if true, color fills rectangle; false otherwise
		~#
		method : public : GetFill() ~ Bool {
			return @fill;
		}

		#~
		Renders an image based upon position instance
		~#
		method : public : Render() ~ Nil {
			Render(@position->GetLeft(), @position->GetTop());
		}

		#~
		Renders an image
		@param x x-position
		@param y y-position
		~#
		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@color = Nil) {
				@color := Color->New();
			};

			@render_rect->SetX(x);
			@render_rect->SetY(y);
			@renderer->SetDrawColor(@color->GetR(), @color->GetG(), @color->GetB(), @color->GetA());

			if(@fill) {
				@renderer->FillRect(@render_rect);
			}
			else {
				@renderer->DrawRect(@render_rect);
			};
		}
	}

	#~
	Shape position
	~#
	class Position {
		@rect : Rect;
		@x : Int;
		@y : Int;

		#~
		Creates a new rectangle with given size
		@param rect position
		~#
		New(rect : Rect) {
			@rect := rect;
		}

		#~
		Creates a new rectangle with given position and size
		@param x x-position
		@param y y-position
		@param w width
		@param h height
		~#
		New(x : Int, y : Int, w : Int, h : Int) {
			@x := x;
			@y := y;
			@rect := Rect->New(0, 0, w, h);
		}

		#~
		Creates a new rectangle with given size
		@param w width
		@param h height
		~#
		New(w : Int, h : Int) {
			@rect := Rect->New(0, 0, w, h);
		}

		#~
		Gets bounding size
		@return size and rectangle
		~#
		method : public : GetRect() ~ Rect {
			return @rect;
		}

		#~
		Set upper left position
		@param x x-position
		@param y y-position
		~#
		method : public : Set(x : Int, y : Int) ~ Nil {
			@x := x;
			@y := y;
		}

		#~
		Set center position
		@param x x-position
		@param y y-position
		~#
		method : public : SetCenter(x : Int, y : Int) ~ Nil {
			SetCenterX(x);
			SetCenterY(y);
		}

		#~
		Set center x-position
		@param x x-position
		~#
		method : public : SetCenterX(x : Int) ~ Nil {
			@x := x - @rect->GetW() / 2;
		}
		
		#~
		Set center y-position
		@param y y-position
		~#
		method : public : SetCenterY(y : Int) ~ Nil {
			@y := y - @rect->GetH() / 2;
		}

		#~
		Sets left position
		@param x x-position
		~#
		method : public : SetLeft(x : Int) ~ Nil {
			@x := x;
		}

		#~
		Sets top position
		@param y top position
		~#
		method : public : SetTop(y : Int) ~ Nil {
			@y := y;
		}

		#~
		Increments the current x-position
		@param x increment to the current x-position
		~#
		method : public : AddX(x : Int) ~ Nil {
			@x += x;
		}

		#~
		Increments the current y-position
		@param y increment to the current y-position
		~#
		method : public : AddY(y : Int) ~ Nil {
			@y += y;
		}

		#~
		Sets right position
		@param x2 right position
		~#
		method : public : SetRight(x2 : Int) ~ Nil {
			@x := x2 - @rect->GetW();
		}

		#~
		Sets bottom position
		@param y2 bottom position
		~#
		method : public : SetBottom(y2 : Int) ~ Nil {
			@y := y2 - @rect->GetH();
		}

		#~
		Gets left position
		@return left position
		~#
		method : public : GetLeft() ~ Int {
			return @x;
		}

		#~
		Gets right position
		@return right position
		~#
		method : public : GetRight() ~ Int {
			return @x + @rect->GetW();
		}

		#~
		Gets the center x-position
		@return center x-position
		~#
		method : public : GetCenterX() ~ Int {
			return @x + @rect->GetW() / 2;
		}

		#~
		Gets top position
		@return top position
		~#
		method : public : GetTop() ~ Int {
			return @y;
		}

		#~
		Gets bottom position
		@return bottom position
		~#
		method : public : GetBottom() ~ Int {
			return @y + @rect->GetH();
		}

		#~
		Gets the center y-position
		@return center y-position
		~#
		method : public : GetCenterY() ~ Int {
			return @y + @rect->GetH() / 2;
		}

		#~
		Determines if position overlaps rectangle
		@param pos position to test 
		@return true of overlap, false otherwise
		~#
		method : public : native : Overlaps(pos : Position) ~ Bool {
			y := GetTop();
			pos_y2 := pos->GetBottom();

			pos_y := pos->GetTop();
			y2 := GetBottom();

			pos_x := pos->GetLeft();
			x2 := GetRight();

			x := GetLeft();
			pos_x2 := pos->GetRight();
			
			return <>(y2 <= pos_y | y >= pos_y2 | x >= pos_x2 | x2 <= pos_x);
		}

		#~
		Determines if position intersect line
		@param x1 'x' start position
		@param y1 'y' start position
		@param x2 'x' end position
		@param y2 'y' end position
		@return true of intersection, false otherwise
		~#
		method : public : IntersectsLine(x1 : Int, y1 : Int, x2 : Int, y2 : Int) ~ Bool {
			return @rect->IntersectAndLine(IntHolder->New(x1), IntHolder->New(y1), IntHolder->New(x2), IntHolder->New(y2));
		}

		#~
		Determines if position a point
		@param p point
		@return true of intersection, false otherwise
		~#
		method : public : Contains(p : Point) ~ Bool {
			return @rect->PointIn(p);
		}

		#~
		Determines if position a point
		@param x x-position
		@param y y-position
		@return true of intersection, false otherwise
		~#
		method : public : Contains(x : Int, y : Int) ~ Bool {
			return @rect->PointIn(Point->New(x, y));
		}
	}

	#~
	Generic shape
	~#
	interface Shape {
		#~
		Gets sprite width
		@return sprite width
		~#
		method : public : virtual : GetWidth() ~ Int;

		#~
		Gets sprite height
		@return sprite height
		~#
		method : public : virtual : GetHeight() ~ Int;

		#~
		Gets sprite position
		@return sprite position
		~#
		method : public : virtual : GetPosition() ~ Position;

		#~
		Called by framework to free resource
		~#
		method : public : virtual : Free() ~ Nil;
	}

	#~
	Game framework
	~#
	class GameFramework {
		@is_ok : Bool;
		@screen_width : Int;
		@screen_height : Int;
		@renderer : Renderer;

		@clear_color : Color;
		@frame_rate : Int;
		@fps : Int;
		@frame_start : Int;

		@shapes : Vector;
		@tiles : Vector;

		@font : Font;
		@joystick : Joystick;

		@event : Event;

		@debug_msg : static : String;

		#~
		Initializes game framework
		@param screen_width screen width
		@param screen_height screen height
		@param title screen title
		@param fps frame per second
		@param init_flags initialization flags
		~#
		New(screen_width : Int, screen_height : Int, title : String, fps : Int, init_flags : Int) {
			@fps := fps;
			@frame_rate := 1000 / @fps;
			@shapes := Vector->New();
			@tiles := Vector->New();
						
			@is_ok := Init(screen_width, screen_height, title, init_flags);
		}

		#~
		Initializes game framework
		@param screen_width screen width
		@param screen_height screen height
		@param title screen title
		~#
		New(screen_width : Int, screen_height : Int, title : String) {
			init_flags := HardwareFlags->SDL_INIT_VIDEO or
				HardwareFlags->SDL_INIT_AUDIO or 
				HardwareFlags->SDL_INIT_JOYSTICK;
			@fps := 60;	
			@frame_rate := 1000 / @fps;
			@shapes := Vector->New();
			@tiles := Vector->New();

			@is_ok := Init(screen_width, screen_height, title, init_flags);
		}

		#~
		Prints debug message
		@param debug_msg message
		~#
		function : Debug(debug_msg : String) ~ Nil {
			if(@debug_msg = Nil) {
				@debug_msg := debug_msg;
				@debug_msg->ErrorLine();
			}
			else if(<>debug_msg->Equals(@debug_msg)) {
				@debug_msg := debug_msg;
				@debug_msg->ErrorLine();
			};
		}
		
		method : Init(screen_width : Int, screen_height : Int, title : String, init_flags : Int) ~ Bool {
			success := true;

			@screen_width := screen_width;
			@screen_height := screen_height;

			if(Core->Init(init_flags) < 0) {
				"SDL could not initialize!"->ErrorLine();
				return false;
			};
			
			if(<>Hints->Set("SDL_RENDER_SCALE_QUALITY", "1")) {
				"Warning: Linear texture filtering not enabled!"->ErrorLine();
				return false;
			};

			if(<>Hints->Set("SDL_HINT_VIDEO_HIGHDPI_DISABLED", "1")) {
				"Warning: High-DPI windows (\"Retina\" on Mac and iOS) not allowed!"->ErrorLine();
				return false;
			};

			@window := Window->New(title, WindowFlags->SDL_WINDOWPOS_UNDEFINED, 
				WindowFlags->SDL_WINDOWPOS_UNDEFINED, @screen_width, @screen_height, 
				WindowFlags->SDL_WINDOW_SHOWN);
			if(@window->IsNull()) {
				"Cannot create window!"->ErrorLine();
				return false;
			};

			@renderer := Renderer->New(@window, -1, 
				RendererFlags->SDL_RENDERER_ACCELERATED or RendererFlags->SDL_RENDERER_PRESENTVSYNC);
			if(@renderer->IsNull()) {
				"Cannot create renderer!"->ErrorLine();
				return false;
			};
			@renderer->SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);

			img_flags := ImageFlags->IMG_INIT_PNG;
			if((Image->Init(img_flags) and img_flags) = 0) {
				"SDL image could not initialize!"->ErrorLine();
				return false;
			};

			if(Font->Init() < 0) {
				"SDL_ttf could not initialize!"->ErrorLine();
				return false;
			};
			
			font_path := Runtime->GetProperty("install_dir");
			if(font_path = Nil) {
				"Failed to load font!"->ErrorLine();
				return false;
			};
			font_path += "/lib/sdl/fonts/lazy.ttf";

			@font := Font->New(font_path, 24);
			if(@font->IsNull()) {
				"Failed to load font '{$font_path}'!"->ErrorLine();
				return false;
			};

			if(<>Mixer->OpenAudio(44100, Mixer->Flags->MIX_DEFAULT_FORMAT, 2, 2048)) {
				"SDL mixer could not initialize!"->ErrorLine();
				return false;
			};

			if(Joystick->Number() < 1) {
				"Warning: No joysticks connected!"->ErrorLine();
			};
			@joystick := Joystick->New(0);
			@event := Event->New();
			
			return true;
		}

		#~
		Initialization status flag
		@return true if initialized, false otherwise
		~#
		method : public : IsOk() ~ Bool {
			return @is_ok;
		}

		method : public : SetOk(success : Bool) ~ Nil {
			if(@is_ok & <>success) {
				@is_ok := false;
			};
		}

		#~
		Gets the framework renderer
		@return framework renderer
		~#
		method : public : GetRenderer() ~ Renderer {
			return @renderer;
		}

		#~
		Gets the framework event
		@return framework event
		~#
		method : public : GetEvent() ~ Event {
			return @event;
		}

		#~
		Sets the start frame
		~#
		method : public : FrameStart() ~ Nil {
			@frame_start := Timer->GetTicks();
		}

		#~
		Gets the frame per second
		~#
		method : public : GetFps() ~ Int {
			return @fps;
		}

		#~
		Sets the end frame
		~#
		method : public : FrameEnd() ~ Nil {
			end := Timer->GetTicks() - @frame_start;
			if(end < @frame_rate) {
				
				Timer->Delay(@frame_rate - end);
			};
		}

		#~
		Sets the clear color
		@param color clear color
		~#
		method : public : SetClearColor(color : Color) ~ Nil {
			@clear_color := color;
		}

		#~
		Sets the game font
		@param font game font
		~#
		method : public : SetFont(font : Font) ~ Nil {
			@font := font;
		}
		
		#~
		Gets the clear color
		@return clear color
		~#
		method : public : GetClearColor() ~ Color {
			return @clear_color;
		}

		#~
		Clears the scene
		~#
		method : public : Clear() ~ Nil {
			if(@clear_color = Nil) {
				@renderer->SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
			}
			else {
				@renderer->SetDrawColor(@clear_color->GetR(), @clear_color->GetG(), 
					@clear_color->GetB(), @clear_color->GetA());
			};
			@renderer->Clear();
		}

		#~
		Shows the scene
		~#
		method : public : Show() ~ Nil {
			@renderer->Present();
		}

		#~
		Adds a rectangle to the framework
		@param w rectangle width
		@param h rectangle height
		@return rectangle
		~#
		method : public : AddRectangle(w : Int, h : Int) ~ Rectangle {
			shape := Rectangle->New(@renderer, w, h);
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds a text sprite to the framework
		@return text sprite
		~#
		method : public : AddTextSprite() ~ TextSprite {
			shape := TextSprite->New(@renderer, @font);
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds an image sprite to the framework
		@param file file path to image asset
		@param colorkey image color key
		@param render_rect bounding rectangle to render
		@return image sprite
		~#
		method : public : AddImageSprite(file : String, colorkey : Color, render_rect : Rect) ~ ImageSprite {
			shape := ImageSprite->New(@renderer, file, colorkey, render_rect);
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds an image sprite to the framework
		@param file file path to image asset
		@param colorkey image color key
		@return image sprite
		~#
		method : public : AddImageSprite(file : String, colorkey : Color) ~ ImageSprite {
			shape := ImageSprite->New(@renderer, file, colorkey);
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : AddTitledImageSprite(file : String) ~ TitledImageSprite {
			shape := TitledImageSprite->New(@renderer, file);
			SetOk(shape->IsOk());
			@tiles->AddBack(shape);

			return shape;
		}

		#~
		Adds an image sprite to the framework
		@param file file path to image asset
		@return image sprite
		~#
		method : public : AddImageSprite(file : String) ~ ImageSprite {
			shape := ImageSprite->New(@renderer, file);
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds an image sprite to the framework
		@param file file path to image asset
		@param clips vector of rendering rectangles
		@return animated image sprite
		~#
		method : public : AddAnimatedImageSprite(file : String, clips : Vector) ~ AnimatedImageSprite {
			shape := AnimatedImageSprite->New(@renderer, file, clips);
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds an image sprite to the framework
		@param file file path to image asset
		@return animated image sprite
		~#
		method : public : AddAnimatedImageSprite(file : String) ~ AnimatedImageSprite {
			shape := AnimatedImageSprite->New(@renderer, file);
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Remove shape from framework
		@param shape shape to remove
		@return true if successful, false otherwise
		~#
		method : public : RemoveSprite(shape : Shape) ~ Bool {
			found := -1;
			
			for(i := 0; i < @shapes->Size() & found < 0; i +=1;) {
				if(@shapes->Get(i) = shape) {
					found := i;
				};
			};

			if(found > -1) {
				@shapes->Remove(found);
				shape->Free();

				return true;
			};

			return false;
		}

		#~
		Removes all shapes
		~#
		method : public : FreeShapes() ~ Nil {
			each(i : @shapes) {
				shape := @shapes->Get(i)->As(Shape);
				shape->Free();
			};
			@shapes->Empty();

			each(i : @tiles) {
				shape := @tiles->Get(i)->As(TitledImageSprite);
				shape->Free();
			};
			@tiles->Empty();
		}

		#~
		Closes the framework
		~#
		method : public : Quit() ~ Nil {
			FreeShapes();

			if(@event <> Nil) {
				@event->Free();
			};

			if(@joystick <> Nil) {
				@joystick->Free();
			};
			
			Image->Quit();
			Font->Quit();
			Mixer->Quit();
			Core->Quit();
		}
	}

	#~
	2D floating-point vector
	~#
	class Vector2 {
		@x : Float;
		@y : Float;

		#~
		Creates a new vector
		~#
		New() {
			@x := 0.0;
			@y := 0.0;
		}

		#~
		Creates a new vector
		@param x x-position
		@param y y-position
		~#
		New(x : Float, y : Float) {
			@x := x;
			@y := y;
		}

		#~
		Gets the x-position
		@return x-position
		~#
		method : public : GetX() ~ Float {
			return @x;
		}

		#~
		Gets the y-position
		@return y-position
		~#
		method : public : GetY() ~ Float {
			return @y;
		}

		#~
		Sets the x-position
		@param x x-position
		~#
		method : public : SetX(x : Float) ~ Nil {
			@x := x;
		}

		#~
		Sets the x and y positions
		@param x x-position
		@param y y-position
		~#
		method : public : Set(x : Float, y : Float) ~ Nil {
			@x := x;
			@y := y;
		}

		#~
		Sets the y-position
		@param y y-position
		~#
		method : public : SetY(y : Float) ~ Nil {
			@y := y;
		}

		#~
		Calculates the magnitude squared
		@return magnitude squared
		~#
		method : public : MagnitudeSquared() ~ Float {
			return @x*@x + @y*@y;
		}

		#~
		Calculates the magnitude 
		@return magnitude 
		~#
		method : public : Magnitude() ~ Float {
			return MagnitudeSquared()->SquareRoot();
		}		

		#~
		Normalizes a unit vector
		~#
		method : public : Normalize() ~ Nil {
			mag := Magnitude();
 			if(mag <> 0.0) {
 				Div(mag);
 			};
 		}
 		
		#~
		String representation of vector
		@return string representation
		~#
		method : public : ToString() ~ String {
			return "{$@x}, {$@y}";
		}

		#~
		Increments the current x-position
		@param rhs increment to the current x-position
		~#
		method : public : AddX(rhs : Vector2) ~ Nil {
			@x += rhs->GetX();
		}

		#~
		Decrements the current x-position
		@param rhs decrements to the current x-position
		~#
		method : public : SubX(rhs : Vector2) ~ Nil {
			@x -= rhs->GetX();
		}

		#~
		Multiplies the current x-position
		@param rhs value to multiply to the current x-position
		~#
		method : public : MulX(rhs : Vector2) ~ Nil {
			@x *= rhs->GetX();
		}

		#~
		Divides the current x-position
		@param rhs value to divide by the current x-position
		~#
		method : public : DivX(rhs : Vector2) ~ Nil {
			@x /= rhs->GetX();
		}

		#~
		Increments the current x-position
		@param x increment to the current x-position
		~#
		method : public : AddX(x : Int) ~ Nil {
			@x += x;
		}

		#~
		Decrements the current x-position
		@param x decrements to the current x-position
		~#
		method : public : SubX(x : Int) ~ Nil {
			@x -= x;
		}

		#~
		Multiplies the current x-position
		@param x value to multiply to the current x-position
		~#
		method : public : MulX(x : Int) ~ Nil {
			@x *= x;
		}

		#~
		Divides the current x-position
		@param x value to divide by the current x-position
		~#
		method : public : DivX(x : Int) ~ Nil {
			@x /= x;
		}

		#~
		Increments the current y-position
		@param rhs increment to the current y-position
		~#
		method : public : AddY(rhs : Vector2) ~ Nil {
			@y += rhs->GetY();
		}

		#~
		Decrements the current y-position
		@param rhs decrements to the current y-position
		~#
		method : public : SubY(rhs : Vector2) ~ Nil {
			@y -= rhs->GetY();
		}

		#~
		Multiplies the current y-position
		@param rhs value to multiply to the current y-position
		~#
		method : public : MulY(rhs : Vector2) ~ Nil {
			@y *= rhs->GetY();
		}

		#~
		Divides the current y-position
		@param rhs value to divide by the current y-position
		~#
		method : public : DivY(rhs : Vector2) ~ Nil {
			@y /= rhs->GetY();
		}

		#~
		Increments the current y-position
		@param y increment to the current y-position
		~#
		method : public : AddY(y : Int) ~ Nil {
			@y += y;
		}

		#~
		Decrements the current y-position
		@param y decrements to the current y-position
		~#
		method : public : SubY(y : Int) ~ Nil {
			@y -= y;
		}

		#~
		Multiplies the current y-position
		@param y value to multiply to the current y-position
		~#
		method : public : MulY(y : Int) ~ Nil {
			@y *= y;
		}

		#~
		Divides the current y-position
		@param y value to divide by the current y-position
		~#
		method : public : DivY(y : Int) ~ Nil {
			@y /= y;
		}

		#~
		Adds to current vector
		@param rhs vector to add
		~#
		method : public : Add(rhs : Vector2) ~ Nil {
			@x += rhs->GetX();
			@y += rhs->GetY();
		}

		#~
		Subtracts from current vector
		@param rhs vector to subtract
		~#
		method : public : Sub(rhs : Vector2) ~ Nil {
			@x -= rhs->GetX();
			@y -= rhs->GetY();
		}

		#~
		Multiples current vector
		@param rhs vector to multiply
		~#
		method : public : Mul(rhs : Vector2) ~ Nil {
			@x *= rhs->GetX();
			@y *= rhs->GetY();
		}

		#~
		Divides current vector
		@param rhs vector to divide
		~#
		method : public : Div(rhs : Vector2) ~ Nil {
			@x /= rhs->GetX();
			@y /= rhs->GetY();
		}

		#~
		Multiples current vector
		@param v v to multiply by
		~#
		method : public : Mul(v : Float) ~ Nil {
			@x *= v;
			@y *= v;
		}

		#~
		Divides current vector
		@param v v to divide by
		~#
		method : public : Div(v : Float) ~ Nil {
			@x /= v;
			@y /= v;
		}

		#~
		Sets vector limit
		@param v limit
		~#
		method : public : Limit(v : Float) ~ Nil {
			Limit(v, v);
		}

		#~
		Sets vector limit
		@param x x-limit
		@param y y-limit
		~#
		method : public : Limit(x : Float, y : Float) ~ Nil {
			if(@x > x) {
				@x := x;
			};

			if(@y > y) {
				@y := y;
			};
		}

		#~
		Sets vector to zero
		~#
		method : public : Zero() ~ Nil {
			@x := 0.0;
			@y := 0.0;
		}
		
		#~
		Add two vectors
		@param lhs left vector
		@param rhs right vector
		@return new vector
		~#
		function : Add(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() + rhs->GetX(), lhs->GetY() + rhs->GetY());
		}

		#~
		Subtract two vectors
		@param lhs left vector
		@param rhs right vector
		@return new vector
		~#
		function : Sub(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() - rhs->GetX(), lhs->GetY() - rhs->GetY());
		}

		#~
		Multiplies two vectors
		@param lhs left vector
		@param rhs right vector
		@return new vector
		~#
		function : Mul(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() * rhs->GetX(), lhs->GetY() * rhs->GetY());
		}

		#~
		Divides two vectors
		@param lhs left vector
		@param rhs right vector
		@return new vector
		~#
		function : Div(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() / rhs->GetX(), lhs->GetY() / rhs->GetY());
		}

		#~
		Multiplies a vector by a value
		@param rhs vector
		@param v value to multiple by
		@return new vector
		~#
		function : Mul(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() * v, rhs->GetY() * v);
		}

		#~
		Divides a vector by a value
		@param rhs vector
		@param v value to divides by
		@return new vector
		~#
		function : Div(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() / v, rhs->GetY() / v);
		}

		#~
		Multiplies x-vector component by a value
		@param rhs vector
		@param v value to multiple by
		@return new vector
		~#
		function : MulX(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() * v, rhs->GetY());
		}

		#~
		Divides x-vector component by a value
		@param rhs vector
		@param v value to multiple by
		@return new vector
		~#
		function : DivX(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() / v, rhs->GetY());
		}

		#~
		Multiplies y-vector component by a value
		@param rhs vector
		@param v value to multiply by
		@return new vector
		~#
		function : MulY(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX(), rhs->GetY() * v);
		}

		#~
		Divides y-vector component by a value
		@param rhs vector
		@param v value to divide by
		@return new vector
		~#
		function : DivY(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX(), rhs->GetY() / v);
		}

		#~
		Calculates the dot product
		@param rhs right vector
		@param lhs left vector
		@return dot product
		~#
		function : Dot(lhs : Vector2, rhs : Vector2) ~ Float {
			return lhs->GetX()*rhs->GetX() + lhs->GetY()*rhs->GetY();
		}
	}
}	
