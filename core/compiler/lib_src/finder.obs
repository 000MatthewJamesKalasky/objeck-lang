use Data.XML;
use System.IO.File;
use Query.RegEx;
use Collection;

#~
HTTP and HTTPS client support
~#
bundle Web.HTTP {
	#~
	Reader for RSS feeds
	~#
	class RSSReader {
		@channel : RSSChannel;
		@posts : Vector;
		@is_ok : Bool;

		New(url : String) {
			xml := FetchXml(url);
			if(xml->Size() > 0) {
				parser := XmlParser->New(xml);
				if(parser->Parse()) {
					@channel := GetChannelData(parser);
					@posts := GetPosts(parser);
					@is_ok := true;
				};
			};
		}

		method : public : GetChannel() ~ RSSChannel {			
			return @channel;
		}

		method : public : GetPosts() ~ Vector {
			if(@is_ok) {
				return @posts;
			};

			return Nil;
		}

		method : public : IsOk() ~ Bool {
			return @is_ok;
		}

		method : GetChannelData(parser : XmlParser) ~ RSSChannel {
			title := GetMatch("/rss/channel/title", parser);
			description := GetMatch("/rss/channel/description", parser);
			link := GetMatch("/rss/channel/link", parser);

			if(title <> Nil & description <> Nil & link <> Nil) {
				return RSSChannel->New(title, description, link);
			};

			return Nil;
		}

		method : GetPosts(parser : XmlParser) ~ Vector {
			posts := Vector->New();

			items := parser->FindElements("/rss/channel/item");
			each(i : items) {
				item := items->Get(i)->As(XmlElement);
				title := GetContent(item->GetFirstChild("title"));
				link := GetContent(item->GetFirstChild("link"));
				description := GetContent(item->GetFirstChild("description"));
				pubDate := GetContent(item->GetFirstChild("pubDate"));

				if(title <> Nil & description <> Nil & link <> Nil & pubDate <> Nil) {
					posts->AddBack(RSSPost->New(title, description, link, pubDate));
				}
				else if(title <> Nil & description <> Nil & link <> Nil) {
					posts->AddBack(RSSPost->New(title, description, link));
				};
			};

			return posts;
		}

		method : GetMatch(path : String, parser : XmlParser) ~ String {
			matches := parser->FindElements(path);
			if(matches->Size() > 0) {			
				return GetContent(matches->Get(0)->As(XmlElement));
			};
			
			return Nil;
		}

		method : GetContent(elem : XmlElement) ~ String {
			if(elem = Nil) {
				return Nil;
			};

			cdata := elem->GetFirstChild("[cdata]");
			if(cdata <> Nil) {
				return cdata->GetContent();
			}
			else {
				return XmlElement->DecodeString(elem->GetContent());
			};	
		}

		method : FetchXml(path : String) ~ String {
			xml := "";

			if(path->StartsWith("http:")) {
				xml := HttpClient->New()->GetAll(path);
			}
			else if(path->StartsWith("https:")) {
				xml := HttpsClient->New()->GetAll(path);
			}
			else {
				xml := FileReader->ReadFile(path);
			};

			return xml;
		}
	}

	class RSSChannel {
		@title : String;
		@description : String;
		@link : String;

		New(title : String, description : String, link : String) {
			@title := title;
			@description := description;
			@link := link;
		}

		method : public : GetTitle() ~ String {
			return @title;
		}

		method : public : GetDescription() ~ String {
			return @description;
		}

		method : public : GetLink() ~ String {
			return @link;
		}
	}

	class RSSPost {
		@title : String;
		@description : String;
		@link : String;
		@date : String;

		New(title : String, description : String, link : String, date : String) {
			@title := title;
			@description := description;
			@link := link;
			@date := date;
		}

		New(title : String, description : String, link : String) {
			@title := title;
			@description := description;
			@link := link;
		}

		method : public : GetTitle() ~ String {
			return @title;
		}

		method : public : GetDescription() ~ String {
			return @description;
		}

		method : public : GetLink() ~ String {
			return @link;
		}

		method : public : GetDate() ~ String {
			return @date;
		}
	}
}

#~
Supports processing of semi-structured data
~#
bundle Query.Structured {
	#~
	Supports string data queries
	~#
	class Finder {
		@regex : RegEx;

		#~
		Default constructor
		@param expr regex expression
		~#
		New(expr : String) {
			@regex := RegEx->New(expr);
		}

		#~
		Finds matching files in a given directory
		@param path root directory to start searching
		@return matching file names
		~#
		method : public : FindFiles(path : String) ~ Vector {
			matches := Vector->New();

			if(@regex->IsOk()) {
				FindFiles(path, matches);
			};
			
			return matches;
		}

		method : FindFiles(path : String, matches : Vector) ~ Nil {
			files := Directory->List(path);
			each(i : files) {
				file := files[i];
				if(<>file->StartsWith('.')) {
					dir_path := String->New(path);
					dir_path += '/';
					dir_path += file;
					
					if(Directory->Exists(dir_path)) {
						FindFiles(dir_path, matches);
					}
					else if(File->Exists(dir_path)) {
						full_name := File->GetFullName(dir_path);
						if(@regex->MatchExact(full_name)) {
							matches->AddBack(full_name);
						};
					};
				};
			};
		}
	}
}