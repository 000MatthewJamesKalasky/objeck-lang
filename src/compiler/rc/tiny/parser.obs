use Collection;

class Parser {
	@tokens : Vector;
	@statements : Vector;
	@sym_table : StringMap;
	@var_index : Int;
	@token_index : Int;
	
	New(tokens : Vector) {
		@tokens := tokens;
		@statements := Vector->New();
		@sym_table := StringMap->New();
		@token_index := 0;
		@var_index := 0;
	}
	
	method : native : GetToken() ~ Token {
		return GetToken(@token_index);
	}
	
	method : native : GetToken(index : Int) ~ Token {
		if(index < @tokens->Size()) {
			return @tokens->Get(index)->As(Token);
		};
		
		return Token->New(Token->Type->EOS, "eos");
	}
	
	method : NextToken() ~ Nil {
		@token_index += 1;
	}
	
	method : Match(index : Int, type : Token->Type) ~ Bool {
		return GetToken(index)->GetType() = type;
	}
	
	method : Match(type : Token->Type) ~ Bool {
		return Match(@token_index, type);
	}
	
	method : public : GetStrings() ~ Vector {
		return Nil;
	}
	
	method : public : GetStatements() ~ Vector {
		return @statements;
	}
	
	method : public : native : Parse() ~ Bool {
		while(GetToken()->GetType() <> Token->Type->EOS) {
			node := Statement();
			if(node = Nil) {
				return false;
			};
			@statements->AddBack(node);
		};
		
		return true;
	}
	
	method : native : Statement() ~ ParseNode {
		node : ParseNode;
		
		select(GetToken()->GetType()) {
			label Token->Type->VAR: {
				left := Variable();
				if(left = Nil) {
					return Nil;
				};
				
				if(<>Match(Token->Type->ASGN)) {
					"*** Expected '=' ***"->PrintLine();
					return Nil;
				};
				NextToken();
				
				right := Expression();
				if(right = Nil) {
					return Nil;
				};
				
				node := ParseNode->New(ParseNode->Type->ASGN, left, right);
				if(<>Match(Token->Type->SEMI)) {
					"*** Expected ';' ***"->PrintLine();
					return Nil;
				};
				NextToken();
			}
			
			label Token->Type->WHILE: {
				node := ParseNode->New(ParseNode->Type->WHILE);
				NextToken();
				
				if(<>ConditionalStatement(node)) {
					return Nil;
				};
			}
			
			label Token->Type->IF: {
				node := ParseNode->New(ParseNode->Type->IF);
				NextToken();
				
				if(<>ConditionalStatement(node)) {
					return Nil;
				};
			}
			
			label Token->Type->PRINT: {
			}
			
			label Token->Type->PUT: {
				NextToken();
				
				if(Match(Token->Type->NUM)) {
					node := ParseNode->New(ParseNode->Type->PUTI, GetToken()->GetValue());
					NextToken();
				}
				else if(Match(Token->Type->STR_REF)) {
					node := ParseNode->New(ParseNode->Type->PUTS, GetToken()->GetValue());
					NextToken();
				}
				else if(Match(Token->Type->VAR)) {
					left := Variable();
					if(left = Nil) {
						return Nil;
					};
					node := ParseNode->New(ParseNode->Type->PUTV, GetToken()->GetValue());
					node->SetLeft(left);
				}
				else {
					left := Expression();
					if(left = Nil) {
						return Nil;
					};
					node := ParseNode->New(ParseNode->Type->PUTC);
					node->SetLeft(left);
				};
				
				if(<>Match(Token->Type->SEMI)) {
					"*** Expected ';' ***"->PrintLine();
					return Nil;
				};
				NextToken();
			}
			
			other: {
				"*** Invalid statement ***"->PrintLine();
				return Nil;
			}
		};	
		
		return node;
	}
	
	method : native : ConditionalStatement(node : ParseNode) ~ Bool {
		if(<>Match(Token->Type->OPREN)) {
			"*** Expected '(' ***"->PrintLine();
			return false;
		};
		NextToken();
		
		left := Expression();
		if(left = Nil) {
			return false;
		};
		node->SetLeft(left);
		
		if(<>Match(Token->Type->CPREN)) {
			"*** Expected ')' ***"->PrintLine();
			return false;
		};
		NextToken();
		
		if(<>Match(Token->Type->OCBRACE)) {
			"*** Expected '{' ***"->PrintLine();
			return false;
		};
		NextToken();
		
		statements := Vector->New();
		while(GetToken()->GetType() <> Token->Type->EOS & GetToken()->GetType() <> Token->Type->CCBRACE) {
			statement := Statement();
			if(statement = Nil) {
				return false;
			};
			statements->AddBack(statement);
		};
		
		if(<>Match(Token->Type->CCBRACE)) {
			"*** Expected '}' ***"->PrintLine();
			return false;
		};
		NextToken();	
		node->SetStatements(statements);	
	
		return true;
	}
	
	method : native : Expression() ~ ParseNode {
		left := Logic();
		if(left = Nil) {
			return Nil;
		};
		
		if(Match(Token->Type->OR)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->OR, left, right);
		}
		else if(Match(Token->Type->AND)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->AND, left, right);
		};
		
		return left;
	}
	
	method : native : Logic() ~ ParseNode {
		left := Term();
		if(left = Nil) {
			return Nil;
		};
		
		if(Match(Token->Type->LESS)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->LESS, left, right);
		}
		else if(Match(Token->Type->GTR)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->GTR, left, right);
		}
		else if(Match(Token->Type->LESS_EQL)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->LESS_EQL, left, right);
		}
		else if(Match(Token->Type->GTR_EQL)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->GTR_EQL, left, right);
		}
		else if(Match(Token->Type->EQL)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->EQL, left, right);
		}
		else if(Match(Token->Type->NEQL)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->NEQL, left, right);
		};
	
		return left;
	}
	
	method : native : Term() ~ ParseNode {
		left := Factor();
		if(left = Nil) {
			return Nil;
		};
		
		if(Match(Token->Type->ADD)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->ADD, left, right);
		}
		else if(Match(Token->Type->SUB)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->SUB, left, right);
		};
		
		return left;
	}
	
	method : native : Factor() ~ ParseNode {
		left := Primary();
		if(left = Nil) {
			return Nil;
		};
	
		if(Match(Token->Type->MUL)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->MUL, left, right);
		}
		else if(Match(Token->Type->DIV)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->DIV, left, right);
		}
		else if(Match(Token->Type->MOD)) {
			NextToken();
			
			right := Expression();
			if(right = Nil) {
				return Nil;
			};
			
			return ParseNode->New(ParseNode->Type->MOD, left, right);
		};
	
		return left;
	}
	
	method : native : Primary() ~ ParseNode {
		node : ParseNode;
		
		select(GetToken()->GetType()) {
			label Token->Type->OPREN: {
				NextToken();
				
				node := Expression();
				if(node = Nil) {
					return Nil;
				};
				
				if(<>Match(Token->Type->CPREN)) {
					"*** Expected ')' ***"->PrintLine();
					return Nil;
				};
				NextToken();	
			}
			
			label Token->Type->VAR: {
				node := Variable();
				if(node = Nil) {
					return Nil;
				};
			}
			
			label Token->Type->NUM: {
				node := ParseNode->New(ParseNode->Type->NUM, GetToken()->GetValue());
				NextToken();
			}
			
			other: {
				"*** Invalid expression ***"->PrintLine();
				return Nil;
			}
		};
		
		return node;
	}
	
	method : Variable() ~ ParseNode {
		node := @sym_table->Find(GetToken()->GetName())->As(ParseNode);
		if(node = Nil) {
			node := ParseNode->New(ParseNode->Type->VAR, @var_index);
			@sym_table->Insert(GetToken()->GetName(), node);
			@var_index += 1;
		};
		NextToken();

		return node;
	}
}

class ParseNode {
	@type : Type;
	@value : Int;
	@left : ParseNode;
	@right : ParseNode;
	@statements : Vector;
	
	enum Type := -64 {
		ASGN,
		WHILE,
		IF,
		PRINT,
		PUTC,
		PUTI,
		PUTS,
		PUTV,
		OR,
		AND,
		LESS,
		LESS_EQL,
		GTR,
		GTR_EQL,
		EQL,
		NEQL,
		NOT, # TODO
		ADD,
		SUB,
		MUL,
		DIV,
		MOD,
		VAR,
		NUM
	}
	
	New(type : Type, statements : Vector) {
		@type := type;
		@statements := statements;
	}
	
	New(type : Type) {
		@type := type;
	}
	
	New(type : Type, left : ParseNode, right : ParseNode) {
		@type := type;
		@left := left;
		@right := right;
	}
	
	New(type : Type, value : Int) {
		@type := type;
		@value := value;
	}
	
	method : public : GetType() ~ ParseNode->Type {
		return @type;
	}
	
	method : public : GetValue() ~ Int {
		return @value;
	}
	
	method : public : GetLeft() ~ ParseNode {
		return @left;
	}
	
	method : public : GetRight() ~ ParseNode {
		return @right;
	}

	method : public : SetLeft(left : ParseNode) ~ Nil {
		@left := left;
	}
	
	method : public : SetRight(right : ParseNode) ~ Nil {
		@right := right;
	}
	
	method : public : SetStatements(statements : Vector) ~ Nil {
		@statements := statements;
	}
	
	method : public : GetStatements() ~ Vector {
		return @statements;
	}
}
