use Collection;

class Emitter {
	@statements : Vector;
	@instructions : Vector;
	@strings : Vector;
	@code_index : Int;
	
	New(statements : Vector, strings : Vector) {
		@statements := statements;
		@strings := strings;
		@instructions := Vector->New();
		@code_index := 0;
	}
	
	method : public : Emit() ~ Nil {
		Strings();
		Statements(@statements);
		
		each(i : @instructions) {
			instruction := @instructions->Get(i)->As(Instruction);
			select(instruction->GetType()) {
				label Instruction->Type->PUTS: {
					"{$i}\tputs"->PrintLine();
				}
				
				label Instruction->Type->PUTI: {
					"{$i}\tputi"->PrintLine();
				}
				
				label Instruction->Type->PUTC: {
					"{$i}\tputc"->PrintLine();
				}
				
				label Instruction->Type->PUTV: {
					index := instruction->GetValue();
					"{$i}\tputv\t{$index}"->PrintLine();
				}
				
				label Instruction->Type->ST: {
					index := instruction->GetValue();
					"{$i}\tst\t{$index}"->PrintLine();
				}
				
				label Instruction->Type->LD: {
					index := instruction->GetValue();
					"{$i}\tld\t{$index}"->PrintLine();
				}
				
				label Instruction->Type->JZ: {
					index := instruction->GetValue();
					"{$i}\tjz\t{$index}"->PrintLine();
				}
				
				label Instruction->Type->JP: {
					index := instruction->GetValue();
					"{$i}\tjp\t{$index}"->PrintLine();
				}
				
				label Instruction->Type->PUSH: {
					value := instruction->GetValue();
					"{$i}\tpush\t{$value}"->PrintLine();
				}
				
				label Instruction->Type->LT: {
					"{$i}\tlt"->PrintLine();
				}
				
				label Instruction->Type->GT: {
					"{$i}\tgt"->PrintLine();
				}
				
				label Instruction->Type->LE: {
					"{$i}\tle"->PrintLine();
				}
				
				label Instruction->Type->GE: {
					"{$i}\tge"->PrintLine();
				}
				
				label Instruction->Type->EQ: {
					"{$i}\teq"->PrintLine();
				}
				
				label Instruction->Type->NEQ: {
					"{$i}\tneq"->PrintLine();
				}
				
				label Instruction->Type->ADD: {
					"{$i}\tadd"->PrintLine();
				}
				
				label Instruction->Type->SUB: {
					"{$i}\tsub"->PrintLine();
				}
				
				label Instruction->Type->MUL: {
					"{$i}\tmul"->PrintLine();
				}
				
				label Instruction->Type->DIV: {
					"{$i}\tdiv"->PrintLine();
				}
				
				label Instruction->Type->MOD: {
					"{$i}\tmod"->PrintLine();
				}
				
				other: {
					"*** Invalid instruction ***"->PrintLine();
				}
			};
		};
	}
	
	method : Strings() ~ Nil {
		@strings->Size()->PrintLine();
		
		each(i : @strings) {
			string := @strings->Get(i)->As(String);
			string->PrintLine();
		};
	}
	
	method : Statements(statements : Vector) ~ Bool {
		temp : Instruction;
		
		each(i : statements) {
			node := statements->Get(i)->As(ParseNode);
			select(node->GetType()) {
				label ParseNode->Type->ASGN: {
					if(<>Expression(node->GetRight())) {
						return false;
					};
					@instructions->AddBack(Instruction->New(Instruction->Type->ST, node->GetLeft()->GetValue()));
					@code_index += 1;
				}
				
				label ParseNode->Type->IF: {
					start := @code_index;
					if(<>Expression(node->GetLeft())) {
						return false;
					};
					cond_jmp := Instruction->New(Instruction->Type->JZ);
					@instructions->AddBack(cond_jmp);
					@code_index += 1;				
					if(<>Statements(node->GetStatements())) {
						return false;
					};
					cond_jmp->SetValue(@code_index);				
				}
				
				label ParseNode->Type->WHILE: {
					start := @code_index;
					if(<>Expression(node->GetLeft())) {
						return false;
					};
					cond_jmp := Instruction->New(Instruction->Type->JZ);
					@instructions->AddBack(cond_jmp);
					@code_index += 1;				
					if(<>Statements(node->GetStatements())) {
						return false;
					};
					@instructions->AddBack(Instruction->New(Instruction->Type->JP, start));
					@code_index += 1;
					cond_jmp->SetValue(@code_index);
				}
				
				label ParseNode->Type->PUTS: {
					@instructions->AddBack(Instruction->New(Instruction->Type->PUSH, node->GetValue()));
					@code_index += 1;
					
					@instructions->AddBack(Instruction->New(Instruction->Type->PUTS));
					@code_index += 1;
				}
				
				label ParseNode->Type->PUTI: {
					@instructions->AddBack(Instruction->New(Instruction->Type->PUSH, node->GetValue()));
					@code_index += 1;
					
					@instructions->AddBack(Instruction->New(Instruction->Type->PUTI));
					@code_index += 1;
				}
				
				label ParseNode->Type->PUTC: {
					Expression(node->GetLeft());
					@instructions->AddBack(Instruction->New(Instruction->Type->PUTC));
					@code_index += 1;
				}
				
				label ParseNode->Type->PUTV: {
					@instructions->AddBack(Instruction->New(Instruction->Type->LD, node->GetLeft()->GetValue()));
					@code_index += 1;
				
					@instructions->AddBack(Instruction->New(Instruction->Type->PUTV));
					@code_index += 1;
				}
				
				other: {
					"*** Invalid statement ***"->PrintLine();
					return false;
				}
			};
		};
		
		return true;
	}
	
	method : Expression(node : ParseNode) ~ Bool {
		select(node->GetType()) {
			label ParseNode->Type->VAR: {
				@instructions->AddBack(Instruction->New(Instruction->Type->LD, node->GetValue()));
				@code_index += 1;
			}
			
			label ParseNode->Type->NUM: {
				@instructions->AddBack(Instruction->New(Instruction->Type->PUSH, node->GetValue()));
				@code_index += 1;
			}
			
			label ParseNode->Type->LESS: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->LT));
				@code_index += 1;
			}
			
			label ParseNode->Type->GTR: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->GT));
				@code_index += 1;
			}
			
			label ParseNode->Type->LESS_EQL: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->LE));
				@code_index += 1;
			}
			
			label ParseNode->Type->GTR_EQL: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->GE));
				@code_index += 1;
			}
			
			label ParseNode->Type->EQL: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->EQ));
				@code_index += 1;
			}
			
			label ParseNode->Type->NEQL: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->NEQ));
				@code_index += 1;
			}
			
			label ParseNode->Type->ADD: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->ADD));
				@code_index += 1;
			}
			
			label ParseNode->Type->SUB: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->SUB));
				@code_index += 1;
			}
			
			label ParseNode->Type->MUL: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->MUL));
				@code_index += 1;
			}
			
			label ParseNode->Type->DIV: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->DIV));
				@code_index += 1;
			}
			
			label ParseNode->Type->MOD: {
				Expression(node->GetLeft());
				Expression(node->GetRight());
				@instructions->AddBack(Instruction->New(Instruction->Type->MOD));
				@code_index += 1;
			}
		};
		
		return true;
	}
}