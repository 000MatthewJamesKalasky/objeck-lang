use System.IO.File;
use Collection;

class Scanner {
	@file : String;
	@tokens : Vector;
	@strings : Vector;
	
	New(file : String) {
		@file := file;
		@tokens := Vector->New();
		@strings := Vector->New();
	}
	
	method : public : GetTokens() ~ Vector {
		return @tokens;
	}
	
	method : public : GetStrings() ~ Vector {
		return @strings;
	}
	
	method : public : native : Scan() ~ Bool {
		reserved := StringMap->New();
		reserved->Insert("while", Token->New(Token->Type->WHILE, "while"));
		reserved->Insert("if", Token->New(Token->Type->IF, "if"));
		reserved->Insert("else", Token->New(Token->Type->ELSE, "else"));
		reserved->Insert("print", Token->New(Token->Type->PRINT, "print"));
		reserved->Insert("put", Token->New(Token->Type->PUT, "put"));
		
		reader := FileReader->New(@file);
		leaving {
			reader->Close();
		};
		
		string_count := 0;
		line_num := 0;
		while(reader->IsEOF() <> true) {
			line := reader->ReadString();
			line_num += 1;
					  
			i := 0;  
			while(i < line->Size()) {  
				# skip whitespace
				while((line->Get(i) = ' ' | line->Get(i) = '\t') & i < line->Size()) {
					i += 1;
				};
				
				# parse the line
				if(i < line->Size()) {
					# variable
					if(line->Get(i)->IsChar() | line->Get(i) = '_') {
						string := "";
						while(line->Get(i)->IsChar() | line->Get(i) = '_') {
							string->Append(line->Get(i));
							i += 1;
						};
					
						token := reserved->Find(string)->As(Token);
						if(token <> Nil) {
							@tokens->AddBack(token);
						}
						else {
							@tokens->AddBack(Token->New(Token->Type->VAR, string));
						};
					}
					# number
					else if(line->Get(i)->IsDigit()) {
						number := "";
						while(line->Get(i)->IsDigit()) {
							number->Append(line->Get(i));
							i += 1;
						};						
						@tokens->AddBack(Token->New(Token->Type->NUM, "num", number->ToInt()));
					}
					# string
					else if(line->Get(i) = '"') {
						i += 1;
						string := "";
						while(line->Get(i) <> '"') {
							string->Append(line->Get(i));
							i += 1;
						};
						@strings->AddBack(string);
						
						@tokens->AddBack(Token->New(Token->Type->STR_REF, "string", string_count));						
						string_count += 1;
						i += 1;
					}
					# other
					else {
						select(line->Get(i)) {
							label ',': {
								@tokens->AddBack(Token->New(Token->Type->COMMA, "comma"));
							}
							
							label '(': {
								@tokens->AddBack(Token->New(Token->Type->OPREN, "opren"));
							}
						
							label ')': {
								@tokens->AddBack(Token->New(Token->Type->CPREN, "cpren"));
							}
				
							label '{': {
								
								@tokens->AddBack(Token->New(Token->Type->OCBRACE, "ocbrace"));
							}
				
							label '}': {
								@tokens->AddBack(Token->New(Token->Type->CCBRACE, "ccbrace"));
							}
						
							label '/': {
								@tokens->AddBack(Token->New(Token->Type->DIV, "div"));
							}
							
							label '%': {
								@tokens->AddBack(Token->New(Token->Type->MOD, "mod"));
							}

							label '*': {
								@tokens->AddBack(Token->New(Token->Type->MUL, "mul"));
							}

							label '+': {
								@tokens->AddBack(Token->New(Token->Type->ADD, "add"));
							}

							label '-': {
								@tokens->AddBack(Token->New(Token->Type->SUB, "sub"));
							}
						
							label ';': {
								@tokens->AddBack(Token->New(Token->Type->SEMI, "semi-colon"));
							}
							
							label '<': {
								if(i + 1 < line->Size() & line->Get(i + 1) = '=') {
									@tokens->AddBack(Token->New(Token->Type->LESS_EQL, "equal"));
									i += 1;
								}
								else {
									@tokens->AddBack(Token->New(Token->Type->LESS, "less"));
								};
							}
							
							label '>': {
								if(i + 1 < line->Size() & line->Get(i + 1) = '=') {
									@tokens->AddBack(Token->New(Token->Type->GTR_EQL, "equal"));
									i += 1;
								}
								else {
									@tokens->AddBack(Token->New(Token->Type->GTR, "gtr"));
								};
							}
							
							label '=': {
								if(i + 1 < line->Size() & line->Get(i + 1) = '=') {
									@tokens->AddBack(Token->New(Token->Type->EQL, "equal"));
									i += 1;
								}
								else {
									@tokens->AddBack(Token->New(Token->Type->ASGN, "asgn"));
								};
							}
							
							label '&': {
								if(i + 1 < line->Size() & line->Get(i + 1) = '&') {
									@tokens->AddBack(Token->New(Token->Type->AND, "and"));
									i += 1;
								}
								else {
									@tokens->AddBack(Token->New(Token->Type->OTHER, "OTHER"));
								};
							}
							
							label '|': {
								if(i + 1 < line->Size() & line->Get(i + 1) = '|') {
									@tokens->AddBack(Token->New(Token->Type->OR, "or"));
									i += 1;
								}
								else {
									@tokens->AddBack(Token->New(Token->Type->OTHER, "OTHER"));
								};
							}
							
							label '!': {
								if(i + 1 < line->Size() & line->Get(i + 1) = '=') {
									@tokens->AddBack(Token->New(Token->Type->NEQL, "neql"));
									i += 1;
								}
								else {
									@tokens->AddBack(Token->New(Token->Type->NOT, "not"));
								};
							}
							
							other: {
								System.IO.Console->Print("*** Invalid token: char='")->Print(line->Get(i))->PrintLine("' ***");
								System.Runtime->Exit(1);
							}
						};
						i += 1;
					};  
				};
			};
		};
		@tokens->AddBack(Token->New(Token->Type->EOS, "eos"));
		
		return true;
	}
	
	function : DumpTokens(tokens : Vector) ~ Nil {
		each(i : tokens) {
			token := tokens->Get(i)->As(Token);
			name := token->GetName();
			
			select(token->GetType()) {
				label Token->Type->VAR: {
					"var: name={$name}"->PrintLine();
				}
				
				label Token->Type->STR_REF: {
					value := token->GetValue();
					"str_ref: id={$value}"->PrintLine();
				}
				
				label Token->Type->NUM: {
					value := token->GetValue();
					"num: value={$value}"->PrintLine();
				}
				
				other : {
					name->PrintLine();
				}
			};
		};
	}
}

class Token {
	@type : Type;
	@name : String;
	@value : Int;

	enum Type := -32 {
		ASGN,
		WHILE,
		ELSE,
		IF,
		PRINT,
		PUT,
		NUM,
		STR_REF,
		VAR,
		OPREN,
		CPREN,
		OCBRACE,
		CCBRACE,
		AND,
		OR,
		DIV,
		MOD,
		MUL,
		ADD,
		SUB,
		SEMI,
		COMMA,
		LESS,
		LESS_EQL,
		GTR,
		GTR_EQL,
		EQL,
		NEQL,
		NOT,
		EOS,
		OTHER
	}
	
	New(type : Type, name : String) {
		@type := type;
		@name := name;
	}
	
	New(type : Type, name : String, value : Int) {
		@type := type;
		@value := value;
		@name := name;
	}
		
	method : public : GetType() ~ Type {
		return @type;
	}
	
	method : public : GetName() ~ String {
		return @name;
	}
	
	method : public : GetValue() ~ Int {
		return @value;
	}
}