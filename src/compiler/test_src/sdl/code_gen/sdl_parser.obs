use Collection;

bundle CodeGen {
	#~
	Parsed function
	~#
	class ParsedFunction {
		@parameters : ParsedParameters;
		@name : String;
		
		New(parameters : ParsedParameters, name : String) {
			@parameters := parameters;
			@name := name;
		}
		
		method : public : ToString() ~ String {
			return "TODO";
		}
	}
	
	#~
	Parsed function parameters
	~#
	class ParsedParameters {
		@parameters : Vector;
		
		New(parameters : Vector) {
			@parameters := parameters;
		}
	}
	
	#~
	Parsed function parameter
	~#
	class ParseParameter {
		@type : ParsedType;
		@name : String;
		
		New(type : ParsedType, name : String) {
			@type := type;
			@name := name;
		}
	}
	
	#~
	Parsed type
	~#
	class ParsedType {
		enum Type {
			INT,
			BOOL,
			CLASS,
			VOID_STAR,
			VOID
		}
		
		@type : ParsedType->Type;
		@name : String;
		@is_pointer : Bool;
		@is_reference : Bool;
		
		New(type : ParsedType->Type) {
			@type := type;
		}
		
		method : public : GetType() ~ ParsedType->Type {
			return @type;
		}
		
		method : public : SetType(type : ParsedType->Type) ~ Nil {
			@type := type;
		}
		
		method : public : SetPointer(is_pointer : Bool) ~ Nil {
			@is_pointer := is_pointer;
		}
		
		method : public : SetReference(is_reference : Bool) ~ Nil {
			@is_reference := is_reference;
		}
	}
	
	#~
	Source code parser
	~#
	class Parser {
		@tokens : Vector;
		@pos : Int;
		
		New(tokens : Vector) {
			@tokens := tokens;
			@pos := 0;
		}
		
		method : Match(type : Type) ~ Bool {
			return Match(type, 0);
		}
		
		method : Match(type : Type, offset : Int) ~ Bool {
			pos := @pos + offset;
			if(pos < @tokens->Size()) {
				return @tokens->Get(pos)->As(Token)->GetType() = type;
			};
			
			return false;
		}
		
		method : Next() ~ Nil {
			if(@pos < @tokens->Size()) {
				@pos += 1;
			};
		}
		
		method : Token() ~ Token {
			if(@pos < @tokens->Size()) {
				return @tokens->Get(@pos);
			};
			
			return @tokens->Get(@tokens->Size() - 1);
		}
		
		method : public : Parse() ~ Nil {
			while(<>Match(Type->EOS)) {
				parsed_function := ParseFunction();
				if(parsed_function <> Nil) {
					parsed_function->ToString()->PrintLine();
				};
				Next();
			};
		}
		
		method : public : ParseParameters () ~ ParsedParameters {
			parsed_parameters : ParsedParameters;
			
			if(<>Match(Type->OPRN)) {
				return Nil;
			};
			Next();

			parameters := Vector->New();
			while(<>Match(Type->EOS) & <>Match(Type->CPRN)) {
				parameter_type := ParseType();
				if(parameter_type = Nil) {
					return Nil;
				};
				
				## function name
				if(<>Match(Type->IDENT)) {
					return Nil;
				};
				parameter_name := Token()->GetValue();					
"\t\tname='{$parameter_name}'"->PrintLine();				
				Next();
				
				parameters->AddBack(ParseParameter->New(parameter_type, parameter_name));
				
				if(Match(Type->COMMA)) {
					Next();
				};
"\t\t---"->PrintLine();				
			};

			if(<>Match(Type->CPRN)) {
				return Nil;
			};
			Next();
			
			return ParsedParameters->New(parameters);
		}
		
		## handle * and & c types
		method : public : ParseType() ~ ParsedType {
			type : ParsedType;
			
			if(Match(Type->CONST_ID)) {
				Next();
			};
			
			select(Token()->GetType()) {
				label Type->UINT8_ID:
				label Type->UINT16_ID:
				label Type->UINT32_ID:
				label Type->INT_ID: {
					type := ParsedType->New(ParsedType->Type->INT);
"\t\ttype: int"->PrintLine();
				}
				
				label Type->VOID_ID: {
					type := ParsedType->New(ParsedType->Type->VOID);
"\t\ttype: void"->PrintLine();
				}
				
				label Type->IDENT: {
					type := ParsedType->New(ParsedType->Type->CLASS);
					class_name := Token()->GetValue();
"\t\ttype: class='{$class_name}'"->PrintLine();					
				}
				
				other: {
					"expected type"->PrintLine();
					Runtime->Exit(1);
				}
			};
			Next();
			
			if(Match(Type->STAR)) {
				type->SetPointer(true);
				if(type->GetType() = ParsedType->Type->VOID) {
					type->SetType(ParsedType->Type->VOID_STAR);
				};
				Next();
			}
			else if(Match(Type->AND)) {
				type->SetReference(true);
				Next();
			};

			return type;			
		}
		
		method : public : ParseFunction() ~ ParsedFunction {
			parsed_function : ParsedFunction;
			
			if(Match(Type->EXTERN_ID) & Match(Type->DECLSPEC_ID, 1)) {
"=== Start Function ==="->PrintLine();			
				Next(); 
				Next();
				
				## return type
				parsed_return := ParseType();
				if(parsed_return = Nil) {
					return Nil;
				};
				
				if(<>Match(Type->SDLCALL_ID)) {
					return Nil;
				};
				Next();
				
				## function name
				if(<>Match(Type->IDENT)) {
					return Nil;
				};
				parsed_function_name := Token()->GetValue();
"\tfunction: name='{$parsed_function_name}'"->PrintLine();				
				Next();
				
				## parameters
				parsed_parameters := ParseParameters();
				if(parsed_parameters = Nil) {
					return Nil;
				};
				
				if(<>Match(Type->SCOLON)) {
					return Nil;
				};
				Next();
"=== End Function ===\n"->PrintLine();
			};
			
			return parsed_function;
		}
	}
}	