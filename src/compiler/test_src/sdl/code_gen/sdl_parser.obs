use Collection;

bundle CodeGen {
	#~
	Parsed function
	~#
	class ParsedFunction {
		@name : String;
		@parameters : ParsedParameters;
		@rtrn_type : ParsedType;
		
		New(name : String, parameters : ParsedParameters, rtrn_type : ParsedType) {
			@name := name;
			@parameters := parameters;
			@rtrn_type := rtrn_type;
		}
		
		method : public : ToString() ~ String {
			if(@name <> Nil & @parameters <> Nil & @rtrn_type <> Nil) {
				param_count := @parameters->GetSize();
				parameters_string := "<none>";
				if(@parameters <> Nil) {
					parameters_string := @parameters->ToString();
				};
				rtrn_string := @rtrn_type->ToString();
				
				return "\n============\nfunction: name='{$@name}', params={$param_count}\n{$parameters_string}return:\n\t{$rtrn_string}";
			};
			
			return "<empty>";
		}
	}
	
	#~
	Parsed function parameters
	~#
	class ParsedParameters {
		@parameters : Vector;
		
		New(parameters : Vector) {
			@parameters := parameters;
		}
		
		method : public : GetSize() ~ Int {
			return @parameters->Size();
		}
		
		method : public : ToString() ~ String {
			buffer := "";
			
			if(@parameters->Size() > 0) {
				buffer->Append("parameters:\n");
				each(i : @parameters) {
					parameter := @parameters->Get(i)->As(ParseParameter);
					buffer->Append(parameter->ToString());
					if(i + 1 < @parameters->Size()) {
						buffer->Append("\n\t---\n");
					};
				};
				buffer->Append('\n');
			};
			
			return buffer;
		}
	}
	
	#~
	Parsed function parameter
	~#
	class ParseParameter {
		@name : String;
		@type : ParsedType;
		
		New(type : ParsedType, name : String) {
			@type := type;
			@name := name;
		}
		
		method : public : GetName() ~ String {
			return @name;
		}
		
		method : public : GetType() ~ ParsedType {
			return @type;
		}
		
		method : public : ToString() ~ String {
			buffer := "";
			
			if(@name <> Nil & @type <> Nil) {
				buffer->Append("\tname='{$@name}'\n");
				buffer->Append('\t');
				buffer->Append(@type->ToString());
			};
			
			return buffer;
		}
	}
	
	#~
	Parsed type
	~#
	class ParsedType {
		enum Type {
			INT,
			BOOL,
			CLASS,
			VOID_STAR,
			VOID
		}
		
		@type : ParsedType->Type;
		@name : String;
		@is_pointer : Bool;
		@is_reference : Bool;
		
		New(type : ParsedType->Type) {
			@type := type;
		}
		
		New(type : ParsedType->Type, name : String) {
			@type := type;
			@name := name;
		}
		
		method : public : GetType() ~ ParsedType->Type {
			return @type;
		}
		
		method : public : GetName() ~ String {
			return @name;
		}
		
		method : public : SetType(type : ParsedType->Type) ~ Nil {
			@type := type;
		}
		
		method : public : SetPointer(is_pointer : Bool) ~ Nil {
			@is_pointer := is_pointer;
		}
		
		method : public : IsPointer() ~ Bool {
			return @is_pointer;
		}
		
		method : public : SetReference(is_reference : Bool) ~ Nil {
			@is_reference := is_reference;
		}
		
		method : public : IsReference() ~ Bool {
			return @is_reference;
		}
		
		method : public : ToString() ~ String {
			buffer := "";
			
			select(@type) {
				label Type->INT: {
					buffer->Append("type=int");
				}
				
				label Type->BOOL: {
					buffer->Append("type=bool");
				}
				
				label Type->CLASS: {
					buffer->Append("type=class, name='{$@name}'");
				}
				
				label Type->VOID_STAR: {
					buffer->Append("type=nil");
				}
				
				label Type->VOID: {
					buffer->Append("type=pointer/int");
				}
			};
			
			return buffer;
		}
	}
	
	#~
	Source code parser
	~#
	class Parser {
		@tokens : Vector;
		@pos : Int;
		
		New(tokens : Vector) {
			@tokens := tokens;
			@pos := 0;
		}
		
		method : Match(type : Type) ~ Bool {
			return Match(type, 0);
		}
		
		method : Match(type : Type, offset : Int) ~ Bool {
			pos := @pos + offset;
			if(pos < @tokens->Size()) {
				return @tokens->Get(pos)->As(Token)->GetType() = type;
			};
			
			return false;
		}
		
		method : Next() ~ Nil {
			if(@pos < @tokens->Size()) {
				@pos += 1;
			};
		}
		
		method : Token() ~ Token {
			if(@pos < @tokens->Size()) {
				return @tokens->Get(@pos);
			};
			
			return @tokens->Get(@tokens->Size() - 1);
		}
		
		method : public : Parse() ~ Nil {
			while(<>Match(Type->EOS)) {
				parsed_function := ParseFunction();
				if(parsed_function <> Nil) {
					parsed_function->ToString()->PrintLine();
				};
				Next();
			};
		}
		
		method : public : ParseParameters () ~ ParsedParameters {
			parsed_parameters : ParsedParameters;
			
			if(<>Match(Type->OPRN)) {
				return Nil;
			};
			Next();

			parameters := Vector->New();
			
			if(Match(Type->VOID_ID) & Match(Type->CPRN, 1)) {
				Next();
				Next();
				
				return ParsedParameters->New(parameters);
			};
			
			while(<>Match(Type->EOS) & <>Match(Type->CPRN)) {
				parameter_type := ParseType();
				if(parameter_type = Nil) {
					return Nil;
				};
				
				## function name
				if(<>Match(Type->IDENT)) {
					return Nil;
				};
				parameter_name := Token()->GetValue();					
				Next();
				
				parameters->AddBack(ParseParameter->New(parameter_type, parameter_name));
				
				if(Match(Type->COMMA)) {
					Next();
				};
			};

			if(<>Match(Type->CPRN)) {
				return Nil;
			};
			Next();
			
			return ParsedParameters->New(parameters);
		}
		
		## handle * and & c types
		method : public : ParseType() ~ ParsedType {
			type : ParsedType;
			
			if(Match(Type->CONST_ID)) {
				Next();
			};
			
			select(Token()->GetType()) {
				label Type->UINT8_ID:
				label Type->UINT16_ID:
				label Type->UINT32_ID:
				label Type->INT_ID: {
					type := ParsedType->New(ParsedType->Type->INT);
				}
				
				label Type->VOID_ID: {
					type := ParsedType->New(ParsedType->Type->VOID);
				}
				
				label Type->IDENT: {
					class_name := Token()->GetValue();
					type := ParsedType->New(ParsedType->Type->CLASS, class_name);
				}
				
				other: {
					"expected type"->PrintLine();
					Runtime->Exit(1);
				}
			};
			Next();
			
			if(Match(Type->STAR)) {
				type->SetPointer(true);
				if(type->GetType() = ParsedType->Type->VOID) {
					type->SetType(ParsedType->Type->VOID_STAR);
				};
				Next();
			}
			else if(Match(Type->AND)) {
				type->SetReference(true);
				Next();
			};

			return type;			
		}
		
		method : public : ParseFunction() ~ ParsedFunction {
			parsed_function : ParsedFunction;
			
			if(Match(Type->EXTERN_ID) & Match(Type->DECLSPEC_ID, 1)) {
				Next(); 
				Next();
				
				## return type
				parsed_return := ParseType();
				if(parsed_return = Nil) {
					return Nil;
				};
				
				if(<>Match(Type->SDLCALL_ID)) {
					return Nil;
				};
				Next();
				
				## function name
				if(<>Match(Type->IDENT)) {
					return Nil;
				};
				parsed_function_name := Token()->GetValue();
				Next();
				
				## parameters
				parsed_parameters := ParseParameters();
				if(parsed_parameters = Nil) {
					return Nil;
				};
				
				if(<>Match(Type->SCOLON)) {
					return Nil;
				};
				Next();
				
				parsed_function := ParsedFunction->New(parsed_function_name, parsed_parameters, parsed_return);
			};
			
			return parsed_function;
		}
	}
}	