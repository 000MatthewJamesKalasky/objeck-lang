use Collection;

bundle CodeGen {
	class ParsedFunction {
	}
	
	class ParsedType {
		enum Type {
			INT,
			BOOL,
			CLASS
		}
		
		@type : ParsedType->Type;
		@name : String;
		@is_pointer : Bool;
		@is_reference : Bool;
		
		New(type : ParsedType->Type) {
			@type := type;
		}
		
		method : public : SetPointer(is_pointer : Bool) ~ Nil {
			@is_pointer := is_pointer;
		}
		
		method : public : SetReference(is_reference : Bool) ~ Nil {
			@is_reference := is_reference;
		}
	}
	
	class Parser {
		@tokens : Vector;
		@pos : Int;
		
		New(tokens : Vector) {
			@tokens := tokens;
			@pos := 0;
		}
		
		method : Match(type : Type) ~ Bool {
			return Match(type, 0);
		}
		
		method : Match(type : Type, offset : Int) ~ Bool {
			pos := @pos + offset;
			if(pos < @tokens->Size()) {
				return @tokens->Get(pos)->As(Token)->GetType() = type;
			};
			
			return false;
		}
		
		method : Next() ~ Nil {
			if(@pos < @tokens->Size()) {
				@pos += 1;
			};
		}
		
		method : Token() ~ Token {
			if(@pos < @tokens->Size()) {
				return @tokens->Get(@pos);
			};
			
			return @tokens->Get(@tokens->Size() - 1);
		}
		
		method : public : Parse() ~ Nil {
			while(<>Match(Type->EOS)) {
				if(Match(Type->EXTERN_ID) & Match(Type->DECLSPEC_ID, 1)) {
					Next(); Next();
					rtrn_type := ParseType();
					if(rtrn_type = Nil) {
						return;
					};
					
					if(<>Match(Type->SDLCALL_ID)) {
						return;
					};
					Next();
					
					if(<>Match(Type->IDENT)) {
						return;
					};
Token()->GetValue()->PrintLine();					
					Next();
							
"Okay"->PrintLine();
"---"->PrintLine();
				};
				Next();
				
				
			
#~		
				select(Token()->GetType()) {
					label Type->CHAR_ID:
					label Type->INT_ID: 
					label Type->FLOAT_ID:
					label Type->BOOL_ID: {
						Next();
					}
					
					other: {
						"expected type"->PrintLine();
						Runtime->Exit(1);
					}	
				};
				
				IO.Console->Print("mapping: name=")->PrintLine(name);
			};
		
			Next();
			
			if(Match(Type->CLASSES_ID) = false) {
				"expected ''CLASSES'"->PrintLine();
				Runtime->Exit(1);
			};
			Next();
~#
			};
		}
		
		# handle * and & c types
		method : public : ParseType() ~ ParsedType {
			type : ParsedType;
		
			select(Token()->GetType()) {
				label Type->INT_ID: {
					type := ParsedType->New(ParsedType->Type->INT);
"int"->PrintLine();
				}
				
				label Type->IDENT: {
					type := ParsedType->New(ParsedType->Type->CLASS);
Token()->GetValue()->PrintLine();
				}
				
				other: {
					"expected type"->PrintLine();
					Runtime->Exit(1);
				}
			};
			Next();
			
			if(Match(Type->STAR)) {
				type->SetPointer(true);
				Next();
			}
			else if(Match(Type->AND)) {
				type->SetReference(true);
				Next();
			};
			
			return type;			
		}
		
		# 
		method : public : ParseFunction() ~ ParsedFunction {
			return Nil;
		}
	}
}	