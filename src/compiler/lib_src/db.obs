use Collection;

bundle TinyDB {
	class Table {
		@name : String;
		@keys : IntMap;
		@column_names : String[];
		@head : Row;
		@tail : Row;
		@count : Int;
		
		New(name : String, column_names : String[]) {
			@name := name;
			@column_names := String->New[column_names->Size() + 1];
			@column_names[0] := "pk";
			each(i : column_names) {
				@column_names[i + 1] := column_names[i];
			};
			@keys := IntMap->New();
		}
		
		method : public : Where(conds : Vector) ~ Vector {
			matches := Vector->New();
			
			row := @head;
			while(row <> Nil) {
				each(j : conds) {
					cond := conds->Get(j)->As(Conditional);
					left := row->Get(cond->GetIndex());
					if(left <> Nil) {
						right := cond->GetValue();
						select(cond->GetQualifier()) {
							label Conditional->Qualifier->EQUAL: {
								if(left->Compare(right) = 0) {
									matches->AddBack(row);
								};			
							}
							
							label Conditional->Qualifier->NOT_EQUAL: {
								if(left->Compare(right) <> 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->GREATER: {
								if(left->Compare(right) > 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->LESS: {
								if(left->Compare(right) < 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->GREATER_EQUAL: {
								if(left->Compare(right) >= 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->LESS_EQUAL: {
								if(left->Compare(right) <= 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->LIKE: {
							}
						};
					};
				};
				row := row->Next();
			};
			
			return matches;
		}
		
		method : public : native : Insert() ~ Row {
			pk := IntHolder->New(@count);
			values := Compare->New[@column_names->Size()];
			values[0] := pk;
			row := Row->New(@self, values);
			@keys->Insert(pk->Get(), row);
			@count += 1;
			
			if(@head = Nil) {
				@head := row;
				@tail := row;
			}
			else {
				@tail->Next(row);
				row->Prev(@tail);
				@tail := row;
			};
			
			return row;
		}
		
		method : public : Delete(pk : Int) ~ Bool {
			row := @keys->Find(pk)->As(Row);
			if(row <> Nil) {
				if(row = @head) {
					@head := row->Next();
					row->Next(Nil);
					@head->Prev(Nil);
				}
				else if(row = @tail) {
					@tail := row->Prev();
					row->Prev(Nil);
					@tail->Next(Nil);
				}
				else {
					row->Prev()->Next(row->Next());
					row->Next()->Prev(row->Prev());
					row->Next(Nil);
					row->Prev(Nil);					
				};
				
				@keys->Remove(pk);
				return true;
			};
			
			return false;
		}
		
		method : public : Size() ~ Int {
			return @count;
		}
		
		method : public : ToString() ~ String {
			buffer := "";
			
			row := @head;
			while(row <> Nil) {
				buffer += row->ToString();
				buffer += "\r\n";
				row := row->Next();
			};
			
			return buffer;
		}
	}
	
	class Conditional {
		@index : Int;
		@qualifier : Conditional->Qualifier;
		@value : Compare;
		
		enum Qualifier {
			EQUAL,
			NOT_EQUAL,
			GREATER,
			LESS,
			GREATER_EQUAL,
			LESS_EQUAL,
			LIKE
		}
		
		New(index : Int, qualifier : Conditional->Qualifier, value : Compare) {
			@index := index;
			@qualifier := qualifier;
			@value := value;
		}
		
		method : public : GetQualifier() ~ Qualifier {
			return @qualifier;
		}
		
		method : public : GetValue() ~ Compare {
			return @value;
		}
		
		method : public : GetIndex() ~ Int {
			return @index;
		}
	}
	
	class Row {
		@values : Compare[];
		@table : Table;
		@next : Row;
		@prev : Row;
		
		New(table : Table, values : Compare[]) {
			@table := table;
			@values := values;
		}
		
		method : public : Get(i : Int) ~ Compare {
			if(i < 0 | i >= @values->Size()) {
				return Nil;
			};
			
			return @values[i];
		}
		
		method : public : Set(i : Int, value : Compare) ~ Bool {
			if(i < 0 | i >= @values->Size()) {
				return false;
			};
			
			@values[i] := value;
			return true;
		}
		
		method : public : Next() ~ Row {
			return @next;
		}
		
		method : public : Next(next : Row) ~ Nil {
			@next := next;
		}
		
		method : public : Prev() ~ Row {
			return @prev;
		}
		
		method : public : Prev(prev : Row) ~ Nil {
			@prev := prev;
		}
		
		method : public : Size() ~ Int {
			return @values->Size();
		}
		
		method : public : Select(indices : Vector) ~ Vector {
			return Nil;
		}
		
		method : public : ToString() ~ String {
			buffer := "";

			each(i : @values) {
				value := @values[i];
				
				if(value <> Nil) {
					if(value->TypeOf(IntHolder)) {
						buffer += value->As(IntHolder)->Get()->ToString();
					}
					else if(value->TypeOf(FloatHolder)) {
						buffer += value->As(FloatHolder)->Get()->ToString();
					}
					else if(value->TypeOf(String)) {
						buffer += value->As(String);
					}
					else {
						buffer += value->GetClass()->GetName();
					};
				}
				else {
						buffer += "<Nil>";
				};	
					
				if(i + 1 < @values->Size()) {
					buffer += ", ";
				};
			};
			
			return buffer;
		}
	}
	
	class Query {
		method : public : native : Parse(line : String) ~ Nil {
      reserved := StringMap->New();
      reserved->Insert("select", "keyword: select");
      reserved->Insert("from", "keyword: from");
      reserved->Insert("where", "keyword: where");
      reserved->Insert("insert", "keyword: insert");
      reserved->Insert("into", "keyword: into");
      reserved->Insert("values", "keyword: values");
      reserved->Insert("like", "keyword: like");
			
			i := 0;
			while(i < line->Size()) {    
				# skip whitespace
				while((line->Get(i) = ' ' | line->Get(i) = '\t') & i < line->Size()) {
					i += 1;
				};
				
				# parse the line
				if(i < line->Size()) {
					# word
					if(line->Get(i)->IsChar() = true) {
						string := "";
						while(line->Get(i)->IsChar() = true | line->Get(i) = '.') {
							string->Append(line->Get(i));
							i += 1;
						};
					
						result := reserved->Find(string)->As(String);
						if(result <> Nil) {
							result->PrintLine();
						}
						else {
							"string/var:'{$string}'"->PrintLine();
						};
					}
					# number
					else if(line->Get(i)->IsDigit() = true) {
						number := "";
						is_dec := false;
						while(line->Get(i)->IsDigit() = true | line->Get(i) = '.') {
							if(line->Get(i) = '.') {
								is_dec := true;
							};
							number->Append(line->Get(i));
							i += 1;
						};

						if(is_dec) {
							"decimal '{$number}'"->PrintLine();
						}
						else {
							"integer '{$number}'"->PrintLine();
						};
					}
					# other
					else {
						select(line->Get(i)) {
							label '(': {
								"opren"->PrintLine();
							}
							
							label ')': {
								"cpren"->PrintLine();
							}

							label '/': {
								"div"->PrintLine();
							}

							label '*': {
								"mul"->PrintLine();
							}

							label '+': {
								"add"->PrintLine();
							}

							label '-': {
								"sub"->PrintLine();
							}
							
							label ',': {
								"comma"->PrintLine();
							}
	#~              
							other: {
								Console->Print("char='")->Print(line->Get(i))->PrintLine("'");
							}
	~#
						};
						i += 1;
					};
				};
			};
		}
	}
}
