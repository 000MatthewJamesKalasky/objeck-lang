use Collection;

bundle TinyDB {
	class Table {
		@name : String;
		@keys : IntMap;
		@column_names : String[];
		@column_map : StringMap;
		@head : Row;
		@tail : Row;
		@count : Int;
		
		New(name : String, column_names : String[]) {
			@column_map := StringMap->New();
			@keys := IntMap->New();
		
			@name := name;
			@column_names := String->New[column_names->Size() + 1];
			@column_names[0] := "pk";
			each(i : column_names) {
				@column_names[i + 1] := column_names[i];
				@column_map->Insert(@column_names[i + 1], IntHolder->New(i + 1));
			};
		}
		
		method : public : GetName() ~ String {
			return @name;
		}
		
		method : public : native : GetIndex(n : String) ~ Int {
			found := @column_map->Find(n);
			if(found <> Nil) {
				return found->As(IntHolder)->Get();
			};
			
			return -1;
		}
		
		method : public : native : All() ~ Vector {
			matches := Vector->New();
			
			row := @head;
			while(row <> Nil) {
				matches->AddBack(row);
				row := row->Next();
			};
			
			return matches;
		}
		
		method : public : native : Where(conds : Vector) ~ Vector {
			matches := Vector->New();
			
			row := @head;
			while(row <> Nil) {
				each(j : conds) {
					cond := conds->Get(j)->As(Conditional);
					left := row->Get(cond->GetIndex());
					if(left <> Nil) {
						right := cond->GetValue();
						select(cond->GetQualifier()) {
							label Conditional->Qualifier->EQUAL: {
								if(left->Compare(right) = 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->NOT_EQUAL: {
								if(left->Compare(right) <> 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->GREATER: {
								if(left->Compare(right) > 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->LESS: {
								if(left->Compare(right) < 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->GREATER_EQUAL: {
								if(left->Compare(right) >= 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->LESS_EQUAL: {
								if(left->Compare(right) <= 0) {
									matches->AddBack(row);
								};
							}
							
							label Conditional->Qualifier->LIKE: {
							}
						};
					};
				};
				row := row->Next();
			};
			
			return matches;
		}
		
		method : public : native : Insert() ~ Row {
			pk := IntHolder->New(@count);
			values := Compare->New[@column_names->Size()];
			values[0] := pk;
			row := Row->New(@self, values);
			@keys->Insert(pk->Get(), row);
			@count += 1;
			
			if(@head = Nil) {
				@head := row;
				@tail := row;
			}
			else {
				@tail->Next(row);
				row->Prev(@tail);
				@tail := row;
			};
			
			return row;
		}
		
		method : public : native : Delete(pk : Int) ~ Bool {
			row := @keys->Find(pk)->As(Row);
			if(row <> Nil) {
				if(row = @head) {
					@head := row->Next();
					row->Next(Nil);
					@head->Prev(Nil);
				}
				else if(row = @tail) {
					@tail := row->Prev();
					row->Prev(Nil);
					@tail->Next(Nil);
				}
				else {
					row->Prev()->Next(row->Next());
					row->Next()->Prev(row->Prev());
					row->Next(Nil);
					row->Prev(Nil);					
				};
				
				@keys->Remove(pk);
				return true;
			};
			
			return false;
		}
		
		method : public : Size() ~ Int {
			return @count;
		}
		
		method : public : ToString() ~ String {
			buffer := "";
			
			row := @head;
			while(row <> Nil) {
				buffer += row->ToString();
				buffer += "\r\n";
				row := row->Next();
			};
			
			return buffer;
		}
	}
	
	class Conditional {
		@index : Int;
		@qualifier : Conditional->Qualifier;
		@value : Compare;
		
		enum Qualifier {
			EQUAL,
			NOT_EQUAL,
			GREATER,
			LESS,
			GREATER_EQUAL,
			LESS_EQUAL,
			LIKE
		}
		
		New(index : Int, qualifier : Conditional->Qualifier, value : Compare) {
			@index := index;
			@qualifier := qualifier;
			@value := value;
		}
		
		method : public : GetQualifier() ~ Qualifier {
			return @qualifier;
		}
		
		method : public : GetValue() ~ Compare {
			return @value;
		}
		
		method : public : GetIndex() ~ Int {
			return @index;
		}
	}
	
	class Row {
		@values : Compare[];
		@table : Table;
		@next : Row;
		@prev : Row;
		
		New(table : Table, values : Compare[]) {
			@table := table;
			@values := values;
		}
		
		method : public : Get(n : String) ~ Compare {
			return Get(@table->GetIndex(n));
		}
		
		method : public : Set(n : String, value : Compare) ~ Bool {
			return Set(@table->GetIndex(n), value);
		}
		
		method : public : Get(i : Int) ~ Compare {
			if(i < 0 | i >= @values->Size()) {
				return Nil;
			};
			
			return @values[i];
		}
		
		method : public : Set(i : Int, value : Compare) ~ Bool {
			if(i < 0 | i >= @values->Size()) {
				return false;
			};
			
			@values[i] := value;
			return true;
		}
		
		method : public : Next() ~ Row {
			return @next;
		}
		
		method : public : Next(next : Row) ~ Nil {
			@next := next;
		}
		
		method : public : Prev() ~ Row {
			return @prev;
		}
		
		method : public : Prev(prev : Row) ~ Nil {
			@prev := prev;
		}
		
		method : public : Size() ~ Int {
			return @values->Size();
		}
		
		method : public : Select(indices : Vector) ~ Vector {
			return Nil;
		}
		
		method : public : ToString() ~ String {
			buffer := "";

			each(i : @values) {
				value := @values[i];
				
				if(value <> Nil) {
					if(value->TypeOf(IntHolder)) {
						buffer += value->As(IntHolder)->Get()->ToString();
					}
					else if(value->TypeOf(FloatHolder)) {
						buffer += value->As(FloatHolder)->Get()->ToString();
					}
					else if(value->TypeOf(String)) {
						buffer += value->As(String);
					}
					else {
						buffer += value->GetClass()->GetName();
					};
				}
				else {
						buffer += "<Nil>";
				};	
					
				if(i + 1 < @values->Size()) {
					buffer += ", ";
				};
			};
			
			return buffer;
		}
	}
	
	class Query {
		@parser : Parser;
		@terms : Term;
		@table : Table;
		
		New(line : String, table : Table) {
			@table := table;
			@parser := Parser->New(line);
		}
		
		method : public : Query() ~ Nil {
			@terms := @parser->Parse();
			if(@terms <> Nil) {
				if(@terms->GetType() = Token->Type->FROM) {
					ProcessFrom(@terms);
				};
			};
		}
		
		method : public : ProcessFrom(term : Term) ~ Nil {
			values := term->GetValues();
			if(values->Size() > 0) {
				name := values->Get(0)->As(String);
				if(@table->GetName()->Equals(name)) {
name->PrintLine();
					if(term->GetLeft() <> Nil) {
"-- select --"->PrintLine();
					}
					else {
						ProcessWhere(term->GetRight());			
					};
				};
			};
		}
		
		method : public : ProcessWhere(term : Term) ~ Nil {
"Where"	-> PrintLine();
		}
	}
	
	class Parser {
		@line : String;
		@tokens : Vector;
		@tokens_index : Int;
		@cur_token : Token;
		
		New(line : String) {
			@line := line;
		}
		
		method : public : Parse() ~ Term {
			@tokens := Scan();
			if(@tokens = Nil) {
				return Nil;
			};
			
			NextToken();
			return ParseTerms();
		}
		
		method : ParseTerms() ~ Term {
			term : Term;
			left : Term;
			
			if(TokenType() = Token->Type->SELECT) {
				NextToken();
				left := ParseSelect();
				if(left = Nil) {
					return Nil;
				};
			};
			
			if(TokenType() = Token->Type->FROM) {
				NextToken();
				term := ParseFrom();
				if(term = Nil) {
					return Nil;
				};
				
				if(left <> Nil) {
					term->SetLeft(left);
				};
			};
			
			return term;	
		}

		method : ParseSelect() ~ Term {
"oper=select"->PrintLine();
			term := Term->New(Token->Type->SELECT);

			if(TokenType() = Token->Type->STAR) {
"value=<all>"->PrintLine();
				NextToken();
			}
			else if(TokenType() = Token->Type->REF) {
				while(TokenType() = Token->Type->REF) {
					value := TokenValue()->As(String);
"value={$value}"->PrintLine();
					term->AddValue(value);
					NextToken();

					if(TokenType() = Token->Type->COMMA) {
						NextToken();
					};
				};
			}
			else {
				return Nil;
			};
			
			return term;
		}

		method : ParseFrom() ~ Term {
"oper=from"->PrintLine();
			term := Term->New(Token->Type->FROM);
			while(TokenType() = Token->Type->REF) {
				value := TokenValue()->As(String);
"value={$value}"->PrintLine();
				term->AddValue(value);
				NextToken();

				if(TokenType() = Token->Type->COMMA) {
					NextToken();
				};
			};

			right : Term;
			if(TokenType() = Token->Type->WHERE) {
				NextToken();
				right := ParseWhere();
				if(right = Nil) {
					return Nil;
				};
				term->SetRight(right);
			};
			
			return term;
		}
		
		method : ParseWhere() ~ Term {
"oper=where"->PrintLine();
			term := Term->New(Token->Type->WHERE);
			
			right := ParseLogic();
			if(right = Nil) {
				return Nil;
			};
			term->SetRight(right);

			return term;
		}
		
		method : ParseLogic() ~ Term {
			term := Term->New(Token->Type->REF);

			left : Term; 			
			if(TokenType() = Token->Type->REF | 
					TokenType() = Token->Type->INT | 
					TokenType() = Token->Type->FLOAT) {
				left := ParseTerm();
				if(left = Nil) {
					return Nil;
				};
				term->SetLeft(left);
			};

			select(TokenType()) {
				label Token->Type->AND: {
"logic=and"->PrintLine();
					NextToken();
				}

				label Token->Type->OR: {
"logic=or"->PrintLine();
					NextToken();
				}
				
				other: {
					return term;
				}
			};

			right : Term;			
			if(TokenType() = Token->Type->REF | 
					TokenType() = Token->Type->INT | 
					TokenType() = Token->Type->FLOAT) {
				right := ParseTerm();
				if(right = Nil) {
					return Nil;
				};
				term->SetRight(right);
			};
				
			return term;
		}
		
		method : ParseTerm() ~ Term {
			term := Term->New(Token->Type->REF);

			left : Term; 			
			if(TokenType() = Token->Type->REF) {
				value := TokenValue()->As(String);
"ref={$value}"->PrintLine();
				NextToken();
			}
			else if(TokenType() = Token->Type->INT) {
				value := TokenValue()->As(IntHolder)->Get();
"int={$value}"->PrintLine();
			}
			else if(TokenType() = Token->Type->FLOAT) {
				value := TokenValue()->As(FloatHolder)->Get();
"float={$value}"->PrintLine();
			}
			else {
				return Nil;
			};

			select(TokenType()) {
				label Token->Type->EQUAL: {
"qual=="->PrintLine();
					NextToken();
				}

				label Token->Type->NOT_EQUAL: {
"qual=<>"->PrintLine();
					NextToken();
				}

				label Token->Type->LESS_EQUAL: {
"qual=<="->PrintLine();
					NextToken();
				}

				label Token->Type->LESS: {
"qual=<"->PrintLine();
					NextToken();
				}

				label Token->Type->GREATER_EQUAL: {
"qual=>="->PrintLine();
					NextToken();
				}

				label Token->Type->GREATER: {
"qual=>"->PrintLine();
					NextToken();
				}

				other: {
					return left;
				}
			};

			right : Term;			
			if(TokenType() = Token->Type->REF) {
				value := TokenValue()->As(String);
"ref={$value}"->PrintLine();
				NextToken();
			}
			else if(TokenType() = Token->Type->INT) {
				value := TokenValue()->As(IntHolder)->Get();
"int={$value}"->PrintLine();
			}
			else if(TokenType() = Token->Type->FLOAT) {
				value := TokenValue()->As(FloatHolder)->Get();
"float={$value}"->PrintLine();
			}
			else {
				return Nil;
			};
			
			return term;
		}
		
		method : NextToken() ~ Bool {
			if(@tokens_index < @tokens->Size()) {
				@cur_token := @tokens->Get(@tokens_index);
				@tokens_index += 1;
				return true;
			};
			
			@cur_token := Nil;
			return false;
		}
		
		method : TokenType() ~ Token->Type {
			if(@cur_token <> Nil) {
				return @cur_token->GetType();
			};
			
			return Token->Type->EOS;
		}
		
		method : TokenValue() ~ Compare {
			if(@cur_token <> Nil) {
				return @cur_token->GetValue();
			};
			
			return "";
		}
		
		method : native : Scan() ~ Vector {		
			reserved := StringMap->New();
			reserved->Insert("select", Token->New(Token->Type->SELECT));
			reserved->Insert("update", Token->New(Token->Type->UPDATE));
			reserved->Insert("from", Token->New(Token->Type->FROM));
			reserved->Insert("where", Token->New(Token->Type->WHERE));
			reserved->Insert("insert", Token->New(Token->Type->INSERT));
			reserved->Insert("into", Token->New(Token->Type->INTO));
			reserved->Insert("values", Token->New(Token->Type->VALUES));
			reserved->Insert("like", Token->New(Token->Type->LIKE));
			reserved->Insert("between", Token->New(Token->Type->BETWEEN));
			reserved->Insert("in", Token->New(Token->Type->IN));
			reserved->Insert("and", Token->New(Token->Type->AND));
			reserved->Insert("or", Token->New(Token->Type->OR));
			
			i := 0;
			tokens := Vector->New();
			while(i < @line->Size()) {    
				# skip whitespace
				while((@line->Get(i) = ' ' | @line->Get(i) = '\t') & i < @line->Size()) {
					i += 1;
				};
				
				# parse the @line
				if(i < @line->Size()) {
					# word
					if(@line->Get(i)->IsChar() = true) {
						string := "";
						while(@line->Get(i)->IsChar() = true | @line->Get(i) = '.') {
							string->Append(@line->Get(i));
							i += 1;
						};
					
						result := reserved->Find(string->ToLower())->As(Token);
						if(result <> Nil) {
							tokens->AddBack(result);
						}
						else {
							tokens->AddBack(Token->New(string));
						};
					}
					# number
					else if(@line->Get(i)->IsDigit() = true) {
						number := "";
						is_dec := 0;
						while(@line->Get(i)->IsDigit() = true | @line->Get(i) = '.') {
							if(@line->Get(i) = '.') {
								is_dec += 1;
							};
							number->Append(@line->Get(i));
							i += 1;
						};

						if(is_dec = 1) {
							tokens->AddBack(Token->New(number->ToFloat()));
						}
						else if(is_dec = 0) {
							tokens->AddBack(Token->New(number->ToInt()));
						}
						else {
							return Nil;
						};
					}
					# other
					else {
						select(@line->Get(i)) {
							label '(': {
								tokens->AddBack(Token->New(Token->Type->FOPEN));
							}
							
							label ')': {
								tokens->AddBack(Token->New(Token->Type->FCLOSE));
							}

							label '*': {
								tokens->AddBack(Token->New(Token->Type->STAR));
							}

							label ',': {
								tokens->AddBack(Token->New(Token->Type->COMMA));
							}
							
							label ';': {
								tokens->AddBack(Token->New(Token->Type->SEMI_COLON));
							}
							
							label '=': {
								tokens->AddBack(Token->New(Token->Type->EQUAL));
							}
							
							label '\'': {
								tokens->AddBack(Token->New(Token->Type->QUOTE));
							}
							
							label '<': {
								if(@line->Get(i + 1) = '>') {
									i += 1;
									tokens->AddBack(Token->New(Token->Type->NOT_EQUAL));
								}
								else if(@line->Get(i + 1) = '=') {
									i += 1;
									tokens->AddBack(Token->New(Token->Type->LESS_EQUAL));
								}
								else {
									tokens->AddBack(Token->New(Token->Type->LESS));
								};
							}
							
							label '>': {
								if(@line->Get(i + 1) = '=') {
									i += 1;
									tokens->AddBack(Token->New(Token->Type->GREATER_EQUAL));
								}
								else {
									tokens->AddBack(Token->New(Token->Type->GREATER));
								};
							}
              
							other: {
								return Nil;
							}
						};
						i += 1;
					};
				};
			};			
			tokens->AddBack(Token->New(Token->Type->EOS));

			return tokens;
		}
	}
	
	class Term {
		@type : Token->Type;
		@left : Term;
		@right : Term;
		@values : Vector;
		
		New(type : Token->Type) {
			@type := type;
			@values := Vector->New();
		}
		
		method : public : GetType() ~ Token->Type {
			return @type;
		}
		
		method : public : AddValue(value : Compare) ~ Nil {
			@values->AddBack(value);
		}
		
		method : public : GetValues() ~ Vector {
			return @values;
		}
		
		method : public : SetLeft(left : Term) ~ Nil {
			@left := left;
		}
		
		method : public : GetLeft() ~ Term {
			return @left;
		}
		
		method : public : SetRight(right : Term) ~ Nil {
			@right := right;
		}
		
		method : public : GetRight() ~ Term {
			return @right;
		}
	}
	
	class Token {
		@type : Type;
		@value : Compare;
		
		enum Type {
			SELECT,
			UPDATE,
			FROM,
			WHERE,
			INSERT,
			INTO,
			VALUES,
			LIKE,
			BETWEEN,
			IN,
			AND,
			OR,
			FOPEN,
			FCLOSE,
			STAR,
			COMMA,
			SEMI_COLON,
			EQUAL,
			QUOTE,
			NOT_EQUAL,
			LESS_EQUAL,
			LESS,
			GREATER_EQUAL,
			GREATER,
			REF,
			INT,
			FLOAT,
			EOS
		}
		
		New(value : String) {
			@type := Type->REF;
			@value := value;
		}
		
		New(type : Type) {
			@type := type;
			@value := "";
		}
		
		New(value : Int) {
			@type := Type->INT;
			@value := IntHolder->New(value);
		}
		
		New(value : Float) {
			@type := Type->FLOAT;
			@value := FloatHolder->New(value);
		}
		
		method : public : GetType() ~ Type {
			return @type;
		}
		
		method : public : GetValue() ~ Compare {
			return @value;
		}

		method : public : ToString() ~ String {
			buffer := "";

			select(@type) {
				label Type->SELECT: {
					buffer += "SELECT";
				}

				label Type->UPDATE: {
					buffer += "UPDATE";
				}

				label Type->FROM: {
					buffer += "FROM";
				}

				label Type->WHERE: {
					buffer += "WHERE";
				}

				label Type->INSERT: {
					buffer += "INSERT";
				}

				label Type->INTO: {
					buffer += "INTO";
				}

				label Type->VALUES: {
					buffer += "VALUES";
				}

				label Type->LIKE: {
					buffer += "LIKE";
				}

				label Type->BETWEEN: {
					buffer += "BETWEEN";
				}

				label Type->IN: {
					buffer += "IN";
				}

				label Type->AND: {
					buffer += "AND";
				}

				label Type->OR: {
					buffer += "OR";
				}

				label Type->FOPEN: {
					buffer += "FOPEN";
				}

				label Type->FCLOSE: {
					buffer += "FCLOSE";
				}

				label Type->STAR: {
					buffer += "STAR";
				}

				label Type->COMMA: {
					buffer += "COMMA";
				}

				label Type->SEMI_COLON: {
					buffer += "SEMI_COLON";
				}

				label Type->EQUAL: {
					buffer += "EQUAL";
				}

				label Type->QUOTE: {
					buffer += "QUOTE";
				}

				label Type->NOT_EQUAL: {
					buffer += "NOT_EQUAL";
				}

				label Type->LESS_EQUAL: {
					buffer += "LESS_EQUAL";
				}

				label Type->LESS: {
					buffer += "LESS";
				}

				label Type->GREATER_EQUAL: {
					buffer += "GREATER_EQUAL";
				}

				label Type->GREATER: {
					buffer += "GREATER";
				}

				label Type->REF: {
					buffer += "REF, value='";
					buffer += @value->As(String);
					buffer += '"';
				}

				label Type->INT: {
					buffer += "INT, value=";
					buffer += @value->As(IntHolder)->Get();
				}

				label Type->FLOAT: {
					buffer += "FLOAT, value=";
					f := @value->As(FloatHolder);
					buffer += f->Get();
				}

				label Type->EOS: {
					buffer += "EOS";
				}
			};

			return buffer;
		}
	}
}
