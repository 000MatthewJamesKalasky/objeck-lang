use Collection;

bundle CSV {
	class CsvRow {
		@id : Int;
		@columns : CompareVector;
		
		New(id : Int, columns : CompareVector) {
			@id := id;
			@columns := columns;
		}
		
		method : public : Id() ~ Int {
			return @id;
		}
		
		method : public : Size() ~ Int {
			return @columns->Size();
		}
		
		method : public : Get(index : Int) ~ String {
			if(index < @columns->Size()) {
				return @columns->Get(index)->As(String);
			};
			
			return Nil;
		}
		
		method : public : ToString() ~ String {
			buffer := "";
			
			each(i : @columns) {
				buffer->Append(@columns->Get(i)->As(String));
				if(i + 1 < @columns->Size()) {
					buffer->Append("|");
				};
			};
			
			return buffer;
		}
	}
	
	class CsvTable {
		@data : Vector;
		@is_parsed : Bool;
		@header_names : StringHash;
		
		New(data : String, delim : String) {
			@is_parsed := true;
			rows := data->Split(delim);
			if(rows->Size() > 1) {			
				@data := ParseColumns(rows);
				if(@data = Nil) {
					@is_parsed := false;
				};
			}
			else {
				@is_parsed := false;
			};
			
			if(@is_parsed) {
				@header_names := StringHash->New();
				headers := @data->Get(0)->As(CsvRow);
				each(i : headers) {
					@header_names->Insert(headers->Get(i)->As(String), IntHolder->New(i));
				};
			};
		}
		
		New(data : Vector, headers : StringHash) {
			@is_parsed := true;
			@data := data;
		}
		
		method : GetHeaders() ~ StringHash {
			return @header_names;
		}
		
		method : public : RowSize() ~ Int {
			return @data->Size();
		}
		
		method : public : native : ParseColumns(rows : String[]) ~ Vector {
			parsed_rows := Vector->New();
			each(i : rows) {
				parsed_rows->AddBack(CsvRow->New(i, ParseRow(rows[i]->ReplaceAll("\"\"", "ˑ"))));
			};

			if(rows->Size() <> parsed_rows->Size()) {		
# IO.Console->Print("rows: parsed = ")->Print(rows->Size())->Print(", size = ")->PrintLine(parsed_rows->Size());				
				return Nil;
			};
			
			column_size := parsed_rows->Get(0)->As(CsvRow)->Size();
			each(i : parsed_rows) {
				parsed_row := parsed_rows->Get(i)->As(CsvRow);
				if(parsed_row->Size() <> column_size) {
# IO.Console->Print("columns: parsed = ")->Print(parsed_row->Size())->Print(", size = ")->PrintLine(column_size);
					return Nil;
				};
			};
			
			return parsed_rows;
		}
		
		method : public : native : ParseRow(row : String) ~ CompareVector {
			columns := CompareVector->New();
			
			index := 0;
			while(index < row->Size()) {
				if(row->Get(index) = '"') {
					index += 1;
					start := index;
					while(index < row->Size() & row->Get(index) <> '"') {
						index += 1;
					};
					token := row->SubString(start, index - start);
					index += 1;
					if(token <> Nil) {
						columns->AddBack(token->ReplaceAll("ˑ", "\"\""));
					};
# IO.Console->Print("quoted = |")->Print(token->ReplaceAll("ˑ", "\"\""))->PrintLine("|");
				}
				else {
					start := index;
					while(index < row->Size() & row->Get(index) <> ',') {
						index += 1;
					};
					token := row->SubString(start, index - start);
					if(token <> Nil) {
						columns->AddBack(token->ReplaceAll("ˑ", "\"\""));
					};
# IO.Console->Print("normal = |")->Print(token->ReplaceAll("ˑ", "\"\""))->PrintLine("|");					
				};
			
				if(row->Get(index) = ',') {
					index += 1;
					if(index = row->Size()) {
						columns->AddBack("");
# "normal = ||"->PrintLine();						
					};
				};
			};
					
			return columns;
		}
		
		method : public : Get(index : Int) ~ CsvRow {
			if(<>@is_parsed) {
				return Nil;
			};
			
			return @data->Get(index)->As(CsvRow);
		}
		
		method : public : Size() ~ Int {
			return @data->Size();
		}
		
		method : public : ColumnSize() ~ Int {
			if(<>@is_parsed) {
				return 0;
			};
			
			return @data->Get(0)->As(CsvRow)->Size();
		}
		
		method : public : Search(name : String, value : String) ~ CsvTable {
			index := @header_names->Find(name)->As(IntHolder);
			if(index <> Nil) {
				return Search(index->Get(), value);
			};
			
			return Nil;
		}
		
		method : public : Search(index : Int, value : String) ~ CsvTable {
			if(index >= ColumnSize()) {
				return Nil;
			};
			
			found := Vector->New();
			found->AddBack(@data->Get(0));
			
			for(i := 1; i < @data->Size(); i +=1;) {
				row := @data->Get(i)->As(CsvRow);
				if(row->Get(index)->Equals(value)) {
					found->AddBack(row);
				};
			};
			
			return CsvTable->New(found, GetHeaders());
		}
		
		method : public : UniqueValues(name : String) ~ CompareVector {
			index := @header_names->Find(name)->As(IntHolder);
			if(index <> Nil) {
				return UniqueValues(index->Get());
			};
			
			return Nil;
		}
		
		method : public : UniqueValues(index : Int) ~ CompareVector {
			if(index >= ColumnSize()) {
				return Nil;
			};
			
			found := CompareVector->New();
			uniques := StringSet->New();
			for(i := 1; i < @data->Size(); i +=1;) {
				value := @data->Get(i)->As(CsvRow)->Get(index);
				if(<>uniques->Has(value)) {
					found->AddBack(value);
					uniques->Insert(value);
				};
			};
			
			return found;
		}
	}
}