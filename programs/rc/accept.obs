#~
<s> -> <expr>
<expr> -> ( + <operands> ) | ( * <operands> ) | <id>
<operands> -> <expr> <operands> | <id>
<id> -> <integer>
~#

use Collection.Generic;

class Lisp {
	@is_debug : Bool;
	@stack : Stack<Value>;

	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			lisp := Lisp->New(true);
			lisp->Execute(args[0]);
		};

#		lisp->Execute(["(+ (* 3 3) 10)"]);
#		lisp->Execute(["234", "(+ 20)", "(+ 1 234)", "(+ 2 10 200)", "(* (+ 1 2) (+ 1 3))", "(* (+ 1 2) (+ 1 3) (* 2 3))"]);
#		lisp->Execute(["123"]);
	}

	New(is_debug : Bool) {
		@is_debug := true;
		@stack := Stack->New()<Value>;
	}

	method : public : Execute(inputs : String[]) ~ Nil {
		each(i : inputs) {
			Execute(inputs[i]);
		};
	}

	method : public : Execute(input : String) ~ Nil {
		input->PrintLine();
		tokens := System.Utility.Parser->Tokenize(input)<String>;
		if(@is_debug) {
			each(j : tokens) {
				token := tokens->Get(j);
				"{$j}: '{$token}'"->PrintLine();
			};
		};

		accept := IsExpr(tokens, 0, tokens->Size() - 1);
		"Accepted: {$accept}\n---"->PrintLine();
		if(accept) {
			each(j : @stack) {
				@stack->Pop()->ToString()->PrintLine();
			};
		};
	}

	method : IsExpr(tokens : Vector<String>, start : Int, end : Int) ~ Bool {
		if(@is_debug) {
			"=IsExpr: {$start}, {$end}"->PrintLine();
		};

		if(start > end) {
			return false;
		}
		else if(tokens->Get(start)->Equals("(") & tokens->Get(end)->Equals(")")) {
			count := -1;

			# operations
			if(tokens->Get(start + 1)->Equals("+")) {
				count := IsOperands(tokens, start + 2, end - 1);
				for(i := 1; i < count; i += 1;) {
					value := @stack->Pop()->ToInt() + @stack->Pop()->ToInt();
					@stack->Push(Value->New(value->ToString()));
				};
			}
			else if(tokens->Get(start + 1)->Equals("-")) {
				count := IsOperands(tokens, start + 2, end - 1);
				if(count = 1) {
					value := @stack->Pop()->ToInt();
					@stack->Push(Value->New("-{$value}"));
				}
				else {
					for(i := 1; i < count; i += 1;) {
						value := @stack->Pop()->ToInt() - @stack->Pop()->ToInt();
						@stack->Push(Value->New(value->ToString()));
					};
				};
			}
			else if(tokens->Get(start + 1)->Equals("/")) {
				count := IsOperands(tokens, start + 2, end - 1);
				for(i := 1; i < count; i += 1;) {
					value := @stack->Pop()->ToInt() / @stack->Pop()->ToInt();
					@stack->Push(Value->New(value->ToString()));
				};
			}
			else if(tokens->Get(start + 1)->Equals("*")) {
				count := IsOperands(tokens, start + 2, end - 1);
				for(i := 1; i < count; i += 1;) {
					value := @stack->Pop()->ToInt() * @stack->Pop()->ToInt();
					@stack->Push(Value->New(value->ToString()));
				};
			}
			# list
			else if(tokens->Get(start + 1)->Equals("list")) {
				if(@is_debug) {
					"=list: {$start}, {$end}"->PrintLine();
				};

				count := IsOperands(tokens, start + 2, end - 1);
				list := Value->New();
				for(i := 0; i < count; i += 1;) {
					list->Add(@stack->Pop());
				};
				@stack->Push(list);
			}
			else if(tokens->Get(start + 1)->Equals("car")) {
				if(@is_debug) {
					"=car: {$start}, {$end}"->PrintLine();
				};

				count := IsOperands(tokens, start + 2, end - 1);
				if(count = 1) {
					list := @stack->Pop();
					if(list->GetType() = Value->Type->LIST) {
						size := list->Size();
						if(size > 0) {
							@stack->Push(list->GetNext());
						}
						else {
							"*** Error 'car' list must contain at least 1 element ***"->ErrorLine();
						};
					}
					else {
						"*** Error 'car' accept only accepts a list ***"->ErrorLine();
					};
				}
				else {
					"*** Error 'car' accepts 1 argument ***"->ErrorLine();
				};
			}
			else if(tokens->Get(start + 1)->Equals("length")) {
				if(@is_debug) {
					"=length: {$start}, {$end}"->PrintLine();
				};

				count := IsOperands(tokens, start + 2, end - 1);
				if(count = 1) {
					list := @stack->Pop();
					if(list->GetType() = Value->Type->LIST) {
						size := list->Size();
						@stack->Push(Value->New(size->ToString()));
					}
					else {
						"*** Error 'length' accept only accepts a list ***"->ErrorLine();
					};
				}
				else {
					"*** Error 'length' accepts 1 argument ***"->ErrorLine();
				};
			}
			else {
				return IsId(tokens, start + 1, end + 1);
			};
				
			return count > -1;
			
		}
		else {
			return IsId(tokens, start, end);
		};
	}

	method : IsOperands(tokens : Vector<String>, start : Int, end : Int) ~ Int {
		count := 0;

		if(@is_debug) {
			"=IsOperands: {$start}, {$end}"->PrintLine();
		};

		if(tokens->Get(start)->Equals("(")) {
			offset := start;

			while(offset < end) {
				offset := start;
				while(<>tokens->Get(offset)->Equals(")")) {
					offset += 1;
				};

				if(<>IsExpr(tokens, start, offset)) {
					return -1;
				};
				count += 1;

				start := offset + 1;
			};
		}
		else {
			while(start <= end) {
				if(tokens->Get(start)->Equals("(")) {
					offset := start;
					while(offset < end) {
						offset := start;
						while(<>tokens->Get(offset)->Equals(")")) {
							offset += 1;
						};

						if(<>IsExpr(tokens, start, offset)) {
							return -1;
						};
				
						start := offset + 1;
					};
				}
				else if(<>IsId(tokens, start, end)) {
					return -1;
				};
				start += 1;

				count += 1;
			};
		};

		return count;
	}

	method : IsId(tokens : Vector<String>, start : Int, end : Int) ~ Bool {
		if(@is_debug) {
			"=IsId: {$start}, {$end}"->PrintLine();
		};

		return IsInteger(tokens, start, end);
	}

	method : IsInteger(tokens : Vector<String>, start : Int, end : Int) ~ Bool {
		value := tokens->Get(start);
		if(@is_debug) {
			"=IsInteger: {$start}, {$end}: value='{$value}'"->PrintLine();
		};

		each(i : value) {
			if(<>value->Get(i)->IsDigit()) {
				return false;
			};
		};
		@stack->Push(Value->New(value));

		return true;
	}
}

class Value {
	@type : Type;
	@atom : String;
	@next : Value;

	enum Type {
		ATOM,
		LIST,
		STRING
	}

	New() {
		@type := Type->LIST;
	}

	New(atom : String, type : Type := Type->ATOM) {
		@atom := atom;
		@type := type;
	}

	method : public : GetType() ~ Value->Type {	
		return @type;
	}

	method : public : Size() ~ Int {
		size := 0;

		temp := @self->GetNext();
		while(temp <> Nil) {
			size += 1;
			temp := temp->GetNext();
		};

		return size;
	}

	method : public : GetNext() ~ Value {
		return @next;
	}

	method : SetNext(value : Value) ~ Nil {
		@next := value;
	}

	method : public : Add(value : Value) ~ Nil {
		if(@next = Nil) {
			@next := value;
		}
		else {
			temp := @next;
			value->SetNext(@next);
			@next := value;
		};
	}

	method : public : ToInt() ~ Int {
		if(@atom <> Nil) {
			return @atom->ToInt();
		};

		return 0;
	}

	method : public : ToString() ~ String {
		if(@type = Type->STRING) {
			return "\"{$@atom}\"";
		}
		else if(@type = Type->ATOM) {
			return @atom;
		}
		else {
			buffer := "(";

			temp := @self->GetNext();
			while(temp <> Nil) {
				buffer += temp->ToString();
				temp := temp->GetNext();
				if(temp <> Nil) {
					buffer += ", ";
				};
			};
			buffer += ")";

			return buffer;
		};
	}
}