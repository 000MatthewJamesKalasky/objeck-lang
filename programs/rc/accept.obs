#~
<s> -> <expr>
<expr> -> ( + <operands> ) | ( * <operands> ) | <id>
<operands> -> <expr> <operands> | <id>
<id> -> <integer>
~#

use Collection.Generic;

class Lisp {
	@is_debug : Bool;
	@stack : Stack<String>;

	function : Main(args : String[]) ~ Nil {
		lisp := Lisp->New(true);
		lisp->Execute(["(* (+ 1 2) (+ 3 4 5))"]);
#		lisp->Execute(["234", "(+ 20)", "(+ 1 234)", "(+ 2 10 200)", "(* (+ 1 2) (+ 1 3))", "(* (+ 1 2) (+ 1 3) (* 2 3))"]);
#		lisp->Execute(["123"]);
	}

	New(is_debug : Bool) {
		@is_debug := true;
		@stack := Stack->New()<String>;
	}

	method : public : Execute(inputs : String[]) ~ Nil {
		each(i : inputs) {
			inputs[i]->PrintLine();
			tokens := Tokenize(inputs[i]);
			if(@is_debug) {
				each(j : tokens) {
					token := tokens->Get(j);
					"{$j}: '{$token}'"->PrintLine();
				};
			};

			accept := IsExpr(tokens, 0, tokens->Size() - 1);
			"Accepted: {$accept}\n---"->PrintLine();
			if(accept) {				
				each(j : @stack) {
					@stack->Pop()->PrintLine();
				};
			};
		};
	}

	method : IsExpr(tokens : Vector<String>, start : Int, end : Int) ~ Bool {
		if(@is_debug) {
			"=IsExpr: {$start}, {$end}"->PrintLine();
		};

		if(start > end) {
			return false;
		}
		else if(tokens->Get(start)->Equals("(") & tokens->Get(end)->Equals(")")) {
			count := -1;

			if(tokens->Get(start + 1)->Equals("+")) {
				count := IsOperands(tokens, start + 2, end - 1);
				for(i := 1; i < count; i += 1;) {
					value := @stack->Pop()->ToInt() + @stack->Pop()->ToInt();
					@stack->Push(value->ToString());
				};
			}
			else if(tokens->Get(start + 1)->Equals("*")) {
				count := IsOperands(tokens, start + 2, end - 1);
				for(i := 1; i < count; i += 1;) {
					value := @stack->Pop()->ToInt() * @stack->Pop()->ToInt();
					@stack->Push(value->ToString());
				};
			};
						
			return count > -1;
			
		}
		else {
			return IsId(tokens, start, end);
		};
	}

	method : IsOperands(tokens : Vector<String>, start : Int, end : Int) ~ Int {
		count := 0;

		if(@is_debug) {
			"=IsOperands: {$start}, {$end}"->PrintLine();
		};

		if(tokens->Get(start)->Equals("(")) {
			offset := start;

			while(offset < end) {
				offset := start;
				while(<>tokens->Get(offset)->Equals(")")) {
					offset += 1;
				};

				if(<>IsExpr(tokens, start, offset)) {
					return -1;
				};
				count += 1;

				start := offset + 1;
			};
		}
		else {
			while(start <= end) {
				if(<>IsId(tokens, start, end)) {
					return -1;
				};
				count += 1;

				start += 1;
			};
		};

		return count;
	}

	method : IsId(tokens : Vector<String>, start : Int, end : Int) ~ Bool {
		if(@is_debug) {
			"=IsId: {$start}, {$end}"->PrintLine();
		};

		return IsInteger(tokens, start, end);
	}

	method : IsInteger(tokens : Vector<String>, start : Int, end : Int) ~ Bool {
		value := tokens->Get(start);
		if(@is_debug) {
			"=IsInteger: {$start}, {$end}: value='{$value}'"->PrintLine();
		};

		each(i : value) {
			if(<>value->Get(i)->IsDigit()) {
				return false;
			};
			@stack->Push(value);
		};


		return true;
	}

	function : Tokenize(input : String) ~ Vector<String> {
		tokens := Vector->New()<String>;

		each(i : input) {
			# identifier
			if(input->Get(i)->IsChar()) {
				start := i;
				while(input->Get(i)->IsChar() | input->Get(i) = '_') {
					i += 1;
				};
				tokens->AddBack(input->SubString(start, i - start));
				i -= 1;
			}
			# number
			else if(input->Get(i)->IsDigit()) {
				start := i;
				while(input->Get(i)->IsDigit() | input->Get(i) = '.') {
					i += 1;
				};
				tokens->AddBack(input->SubString(start, i - start));
				i -= 1;
			}
			# other
			else {
				value := input->Get(i);
				if(value <> ' ' & value <> '\t' & value <> '\r' & value <> '\n') {
					tokens->AddBack(value->ToString());
				};
			};
		};

		return tokens;
	}
}