use Collection.Generic;

class MiniLisp {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			parser := Parser->New(args[0]);
			root := parser->Parse();
			if(root <> Nil) {
				evaluator := Evaluator->New(root);
				evaluator->Evaluate();
			};
		};
	}
}

#--- Evaluator ---

class Evaluator {
	@root : Node;
	@stack : Stack<Token>;
	@debug : Bool;

	New(root : Node) {
		@root := root;
		@stack := Stack->New()<Token>;
		@debug := true;
	}

	method : public : Evaluate() ~ Nil {
		Evaluate(@root);
		if(@debug) {
			"--- Results ---"->PrintLine();
			each(i : @stack) {
				value := @stack->Pop()->ToString();
				"{$i}: {$value}"->PrintLine();
			};
		};
	}

	method : Evaluate(node : Node) ~ Nil {
		select(node->GetType()) {
			label Token->Type->INT {
				@stack->Push(node->GetToken());
			}

			label Token->Type->ADD {
				children := node->GetChildren();
				for(i := children->Size() - 1; i >= 0; i -= 1;) {
					Evaluate(children->Get(i));
				};

				left := @stack->Pop();
				for(i := 1;	 i < children->Size(); i += 1;) {
					right := @stack->Pop();
					left->SetInt(left->GetInt() + right->GetInt());
				};
				@stack->Push(left);
			}

			label Token->Type->MUL {
				children := node->GetChildren();
				for(i := children->Size() - 1; i >= 0; i -= 1;) {
					Evaluate(children->Get(i));
				};

				left := @stack->Pop();
				for(i := 1;	 i < children->Size(); i += 1;) {
					right := @stack->Pop();
					left->SetInt(left->GetInt() * right->GetInt());
				};
				@stack->Push(left);
			}

			label Token->Type->SUB {
				children := node->GetChildren();
				for(i := children->Size() - 1; i >= 0; i -= 1;) {
					Evaluate(children->Get(i));
				};

				left := @stack->Pop();
				if(children->Size() = 1) {
					left->SetInt(left->GetInt() * -1);
				}
				else {
					for(i := 1;	 i < children->Size(); i += 1;) {
						right := @stack->Pop();
						left->SetInt(left->GetInt() - right->GetInt());
					};
				};
				@stack->Push(left);
			}

			label Token->Type->DIV {
				children := node->GetChildren();
				for(i := children->Size() - 1; i >= 0; i -= 1;) {
					Evaluate(children->Get(i));
				};

				left := @stack->Pop();
				if(children->Size() = 1) {
					left->SetReal(1.0 / left->GetInt()->ToFloat());
				}
				else {
					for(i := 1;	 i < children->Size(); i += 1;) {
						right := @stack->Pop();
						left->SetInt(left->GetInt() - right->GetInt());
					};
				};
				@stack->Push(left);
			}
		};
	}
}

#--- Parser ---

class Parser {
	@tokens : Vector<Token>;
	@token_pos : Int;
	@level : Int;
	@error : Bool;
	@debug : Bool;
	
	New(input : String) {
		@tokens := Scanner->Scan(input)<Token>;
		@debug := true;
	}

	method : public : Parse() ~ Node {
		if(@debug) {
			"--- Tokens ---"->PrintLine();
			each(i : @tokens) {
				value := @tokens->Get(i);
				"{$i}: {$value}"->PrintLine();
			};
			"--- Expressions ---"->PrintLine();
		};

		root := Expression(0);
		if(@debug) {
			if(root <> Nil) {
				"--- Tree ---"->PrintLine();
				root->ToString()->PrintLine();
			};
		};

		return root;
	}

	method : public : Expression(depth : Int) ~ Node {
		node : Node;
		length := @tokens->Size();

		if(@debug) {
			"=Expression: pos=({$@token_pos},{$length}); depth={$depth}"->PrintLine();
		};

		if(@token_pos < length) {
			if(@tokens->Get(@token_pos)->GetType() = Token->Type->OPRN) {
				@token_pos += 1;
				@level += 1;
				
				if(@token_pos + 2 < length) {
					select(@tokens->Get(@token_pos)->GetType()) {
						label Token->Type->ADD:
						label Token->Type->SUB:
						label Token->Type->MUL:
						label Token->Type->DIV: {
							node := Node->New(@tokens->Get(@token_pos));
							@token_pos += 1;

							cur_level := @level;
							do {
								child := Expression(depth + 1);
								if(@error) {
									return Nil;
								};

								if(child <> Nil) {
									node->AddChild(child);
								};
							}
							while(cur_level <= @level);
						}

						label Token->Type->WRITE: {

						}

						other: {
							@error := true;
							"*** Error: unknown operation ***"->ErrorLine();
							return Nil;
						}
					};
				}
				else {
					@error := true;
					"*** Error: operation requires at least 1 operand ***"->ErrorLine();
					return Nil;
				};
			}
			else if(@tokens->Get(@token_pos)->GetType() = Token->Type->CPRN) {
				@token_pos += 1;
				@level -= 1;
			}
			else if(@tokens->Get(@token_pos)->GetType() = Token->Type->INT) {
				node := Node->New(@tokens->Get(@token_pos));
				@token_pos += 1;
			}
			else {
				@error := true;
				"*** Error: unknown token ***"->ErrorLine();
				@token_pos += 1;
				return Nil;
			};
		}
		else {
			@error := true;
			"*** Error: expected token ***"->ErrorLine();
			@token_pos += 1;
			return Nil;
		};

		return node;
	}

	function : Show(msg : String, depth : Int) ~ Nil {
		each(i : depth) {
			"   "->Print();
		};
		msg->PrintLine();
	}
}

class Node {
	@token : Token;
	@children : Vector<Node>;

	New(token : Token) {
		@token := token;
	}

	method : public : GetToken() ~ Token {
		return @token;
	}

	method : public : GetType() ~ Token->Type {
		return @token->GetType();
	}

	method : public : AddChild(node : Node) ~ Nil {
		if(@children = Nil) {
			@children := Vector->New()<Node>;
		};

		@children->AddBack(node);
	}

	method : public : GetChildren() ~ Vector<Node> {
		return @children;
	}

	method : public : ToString() ~ String {
		return ToString(0);
	}

	method : public : ToString(level : Int) ~ String {
		buffer := "";

		each(l : level) {
			buffer += "  ";
		};
		buffer += "[";

		buffer += @token->ToString();
		if(@children <> Nil) {
			each(i : @children) {
				buffer += '\n';
				buffer += @children->Get(i)->ToString(level + 1);
			};
			
		};
		buffer += "]";

		return buffer;
	}
}

#--- Scanner ---

class Scanner {
	function : Scan(input : String) ~ Vector<Token> {
		tokens := Vector->New()<Token>;

		each(i : input) {
			while(input->Get(i) = ' ' | input->Get(i) = '\r' | input->Get(i) = '\n' | input->Get(i) = '\t') {
				i += 1;
			};

			if(input->Get(i)->IsChar()) {
				start := i;
				while(input->Get(i)->IsChar() | input->Get(i) = '_') {
					i += 1;
				};
				tokens->AddBack(Token->New(Token->Type->IDENT, input->SubString(start, i - start)));
				i -= 1;
			}
			else if(input->Get(i)->IsDigit()) {
				is_real := false;

				start := i;
				while(input->Get(i)->IsDigit() | input->Get(i) = '.') {
					if(input->Get(i) = '.') {
						is_real := true;
					};
					i += 1;
				};

				value := input->SubString(start, i - start);
				if(is_real) {
					tokens->AddBack(Token->New(value->ToFloat()));
				}
				else {
					tokens->AddBack(Token->New(value->ToInt()));
				};
				i -= 1;
			}
			else {
				select(input->Get(i)) {
					label '(' {
						tokens->AddBack(Token->New(Token->Type->OPRN));
					}

					label ')' {
						tokens->AddBack(Token->New(Token->Type->CPRN));
					}

					label '+' {
						tokens->AddBack(Token->New(Token->Type->ADD));
					}

					label '-' {
						tokens->AddBack(Token->New(Token->Type->SUB));
					}

					label '*' {
						tokens->AddBack(Token->New(Token->Type->MUL));
					}

					label '/' {
						tokens->AddBack(Token->New(Token->Type->DIV));
					}

					other {
						tokens->AddBack(Token->New(Token->Type->OTHER));
					}
				};
			};
		};

		return tokens;
	}
}

class Token {
	@type : Type;
	@ident : String;
	@int : Int;
	@real : Float;

	enum Type {
		WRITE,
		OPRN,
		CPRN,
		ADD,
		SUB,
		MUL,
		DIV,
		IDENT,
		INT,
		REAL,
		OTHER
	}

	New(type : Token->Type) {
		@type := type;
	}

	New(type : Token->Type, ident : String) {
		@type := type;
		@ident := ident;
	}

	New(int : Int) {
		@type := Type->INT;
		@int := int;
	}

	New(real : Float) {
		@type := Type->REAL;
		@real := real;
	}

	method : public : GetType() ~ Token->Type {
		return @type;
	}

	method : public : GetIdent() ~ String {
		return @ident;
	}

	method : public : GetInt() ~ Int {
		return @int;
	}

	method : public : SetInt(int : Int) ~ Nil {
		@type := Type->INT;
		@int := int;
	}

	method : public : GetReal() ~ Float {
		return @real;
	}

	method : public : SetReal(real : Float) ~ Nil {
		@type := Type->REAL;
		@real := real;
	}

	method : public : ToString() ~ String {
		select(@type) {
			label Type->OPRN {
				return ")";
			}

			label Type->CPRN {
				return ")";
			}
			
			label Type->ADD {
				return "+";
			}
			
			label Type->SUB {
				return "-";
			}

			label Type->MUL {
				return "*";
			}
			
			label Type->DIV {
				return "/";
			}
			
			label Type->IDENT {
				return @ident;
			}
			
			label Type->INT {
				return @int->ToString();
			}
			
			label Type->REAL {
				return @real->ToString();
			}

			other {
				return "?";
			}
		};
	}
}