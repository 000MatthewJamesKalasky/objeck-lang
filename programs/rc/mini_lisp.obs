use Collection.Generic;

class MiniLisp {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			parser := Parser->New(args[0]);
			root := parser->Parse();
			if(root <> Nil) {
				evaluator := Evaluator->New(root);
				evaluator->Evaluate();
			};
		};
	}
}

#--- Evaluator ---

class Evaluator {
	@root : Node;
	@stack : Stack<Value>;
	@debug : Bool;

	New(root : Node) {
		@root := root;
		@stack := Stack->New()<Value>;
		@debug := true;

		Value->Init();
	}

	method : public : Evaluate() ~ Nil {
		Evaluate(@root);
		if(@debug) {
			"--- Results ---"->PrintLine();
			each(i : @stack) {
				value := @stack->Pop()->ToString();
				"{$i} => {$value}"->PrintLine();
			};
		};
	}

	method : Evaluate(node : Node) ~ Nil {
		select(node->GetType()) {
			label Node->Type->LIST {				
				children := node->GetChildren();
				each(i : children) {
					Evaluate(children->Get(i));
				};

				left := Value->New(Value->Type->LIST);
				each(i : children) {
					left->Append(@stack->Pop());
				};
				@stack->Push(left);
			}

			label Node->Type->EMPTY_LIST {
				@stack->Push(Value->New(Value->Type->LIST));
			}

			label Node->Type->INT_LIT {
				@stack->Push(Value->New(node->GetIntValue()));
			}

			label Node->Type->ADD {
				children := node->GetChildren();
				reverse(i : children) {
					Evaluate(children->Get(i));
				};

				left := @stack->Pop();
				for(i := 1;	 i < children->Size(); i += 1;) {
					right := @stack->Pop();
					left->SetIntValue(left->GetIntValue() + right->GetIntValue());
				};
				@stack->Push(left);
			}

			label Node->Type->MUL {
				children := node->GetChildren();
				reverse(i : children) {
					Evaluate(children->Get(i));
				};

				left := @stack->Pop();
				reverse(i : children) {
					right := @stack->Pop();
					left->SetIntValue(left->GetIntValue() * right->GetIntValue());
				};
				@stack->Push(left);
			}

			label Node->Type->SUB {
				children := node->GetChildren();
				reverse(i : children) {
					Evaluate(children->Get(i));
				};

				left := @stack->Pop();
				if(children->Size() = 1) {
					left->SetIntValue(left->GetIntValue() * -1);
				}
				else {
					for(i := 1;	 i < children->Size(); i += 1;) {
						right := @stack->Pop();
						left->SetIntValue(left->GetIntValue() - right->GetIntValue());
					};
				};
				@stack->Push(left);
			}

			label Node->Type->DIV {
				children := node->GetChildren();
				for(i := children->Size() - 1; i >= 0; i -= 1;) {
					Evaluate(children->Get(i));
				};

				left := @stack->Pop();
				if(children->Size() = 1) {
					left->SetRealValue(1.0 / left->GetIntValue()->ToFloat());
				}
				else {
					for(i := 1;	 i < children->Size(); i += 1;) {
						right := @stack->Pop();
						left->SetIntValue(left->GetIntValue() - right->GetIntValue());
					};
				};
				@stack->Push(left);
			}
		};
	}
}

class Value {
	@type : Type;
	@nil_value : static : Value;
	@empty_list_value : static : Value;
	@car : Value;
	@int_value : Int;
	@real_value : Float;
	@str_value : String;

	enum Type {
		LIST,
		NIL_TYPE,
		INT_TYPE,
		REAL_TYPE,
		STRING_TYPE
	}

	function : Init() ~ Nil {
		@nil_value := Value->New(Value->Type->NIL_TYPE);
		@empty_list_value := Value->New(Value->Type->LIST);
	}

	New(int_value : Int) {
		@type := Value->Type->INT_TYPE;
		@int_value := int_value;
	}

	New(real_value : Float) {
		@type := Value->Type->REAL_TYPE;
		@real_value := real_value;
	}

	New(type : Value->Type) {
		@type := type;

		if(@type = Value->Type->LIST) {
			@car := @empty_list_value;
		};
	}

	# list operations
	method : public : GetCar() ~ Value {
		if(@car = @empty_list_value) {
			return @empty_list_value;
		};

		return @car;
	}

	method : SetCar(value : Value) ~ Nil {
		@car := value;
	}

	method : public : GetCdr() ~ Value {
		if(@car = @empty_list_value) {
			return @empty_list_value;
		};

		if(@car->GetCar() = @empty_list_value) {
			return @empty_list_value;
		};

		return @car->GetCar();
	}

	method : public : Append(value : Value) ~ Nil {
		temp := @car;
		value->SetCar(@car);
		@car := value;
	}	

	# atom operations
	method : public : GetIntValue() ~ Int {
		return @int_value;
	}

	method : public : SetIntValue(int_value : Int) ~ Nil {
		@type := Value->Type->INT_TYPE;
		@int_value := int_value;
	}

	method : public : GetRealValue() ~ Float {
		return @real_value;
	}

	method : public : SetRealValue(real_value : Float) ~ Nil {
		@type := Value->Type->REAL_TYPE;
		@real_value := real_value;
	}

	# other
	method : public : ToString() ~ String {
		buffer := "";

		select(@type) {
			label Value->Type->INT_TYPE {
				buffer += @int_value->ToString();
			}

			label Value->Type->REAL_TYPE {
				buffer += @real_value->ToString();
			}

			label Value->Type->STRING_TYPE {
				buffer += @str_value;
			}

			label Value->Type->LIST {
				if(@car = @empty_list_value) {
					buffer += "NIL";
				}
				else {
					buffer += "(";
					
					temp := @car;
					while(temp <> @empty_list_value) {
						buffer += temp->ToString();
						temp := temp->GetCar();
						if(temp <> @empty_list_value) {
							buffer += ", ";
						};
					};

					buffer += ")";
				};
			}

			label Value->Type->NIL_TYPE {
				buffer += "NIL";
			}
		};

		return buffer;
	}
}

#--- Parser ---

class Parser {
	@tokens : Vector<Token>;
	@token_pos : Int;
	@level : Int;
	@error : Bool;
	@debug : Bool;
	
	New(input : String) {
		scanner := Scanner->New();
		@tokens := scanner->Scan(input);
		@debug := true;
	}

	method : public : Parse() ~ Node {
		if(@debug) {
			"--- Tokens ---"->PrintLine();
			each(i : @tokens) {
				value := @tokens->Get(i);
				"{$i}: {$value}"->PrintLine();
			};
			"--- Expressions ---"->PrintLine();
		};

		root := Expression(0);
		if(@debug) {
			if(root <> Nil) {
				"--- Tree ---"->PrintLine();
				root->ToString()->PrintLine();
			};
		};

		return root;
	}

	method : public : Expression(depth : Int) ~ Node {
		node : Node;
		length := @tokens->Size();

		if(@debug) {
			"=Expression: pos=({$@token_pos},{$length}); depth={$depth}"->PrintLine();
		};

		if(@token_pos < length) {
			if(@tokens->Get(@token_pos)->GetType() = Token->Type->OPRN) {
				@token_pos += 1;
				@level += 1;
				
				if(@token_pos + 2 < length) {
					select(@tokens->Get(@token_pos)->GetType()) {
						label Token->Type->ADD:
						label Token->Type->SUB:
						label Token->Type->MUL:
						label Token->Type->DIV: {
							node := Node->New(@tokens->Get(@token_pos)->GetType());
							if(<>Operands(node, depth)) {
								return Nil;
							};
						}

						label Token->Type->LIST_KEYWORD: {
							node := Node->New(Node->Type->LIST);
							if(<>Operands(node, depth)) {
								return Nil;
							};
						}

						label Token->Type->CONS_KEYWORD: {
							node := Node->New(Node->Type->PAIR);
							if(<>Operands(node, depth)) {
								return Nil;
							};

							if(node->GetChildren()->Size() <> 2) {
								@error := true;
								"*** 'cons' operation takes 2 operands ***"->ErrorLine();
								return Nil;
							};
						}

						label Token->Type->WRITE_KEYWORD: {

						}

						other: {
							@error := true;
							"*** Error: unknown operation ***"->ErrorLine();
							return Nil;
						}
					};
				}
				else if(@token_pos < length) {
					if(@tokens->Get(@token_pos)->GetType() = Token->Type->CPRN) {
						node := Node->New(Node->Type->EMPTY_LIST);
					};
				}
				else {
					@error := true;
					"*** Error: operation requires at least 1 operand ***"->ErrorLine();
					return Nil;
				};
			}
			else if(@tokens->Get(@token_pos)->GetType() = Token->Type->CPRN) {
				@token_pos += 1;
				@level -= 1;
			}
			else if(@tokens->Get(@token_pos)->GetType() = Token->Type->INT_LIT) {
				node := Node->New(@tokens->Get(@token_pos)->GetIntValue());
				@token_pos += 1;
			}
			else {
				@error := true;
				"*** Error: unknown token ***"->ErrorLine();
				@token_pos += 1;
				return Nil;
			};
		}
		else {
			@error := true;
			"*** Error: expected token ***"->ErrorLine();
			@token_pos += 1;
			return Nil;
		};

		return node;
	}

	method : Operands(node : Node, depth : Int) ~ Bool {
		@token_pos += 1;

		cur_level := @level;
		do {
			child := Expression(depth + 1);
			if(@error) {
				return false;
			};

			if(child <> Nil) {
				node->AddChild(child);
			};
		}
		while(cur_level <= @level);

		return true;
	}

	function : Show(msg : String, depth : Int) ~ Nil {
		each(i : depth) {
			"   "->Print();
		};
		msg->PrintLine();
	}
}

class Node {
	@type : Node->Type;
	@int_value : Int;
	@real_value : Float;
	@str_value : String;
	@children : Vector<Node>;

	enum Type {
		ADD,
		SUB,
		MUL,
		DIV,
		PAIR,
		LIST,
		EMPTY_LIST,
		INT_LIT,
		REAL_LIT,
		STRING_LIT
	}

	New(int_value : Int) {
		@type := Node->Type->INT_LIT;
		@int_value := int_value;
	}

	New(real_value : Float) {
		@type := Node->Type->REAL_LIT;
		@real_value := real_value;
	}

	New(str_value : String) {
		@type := Node->Type->STRING_LIT;
		@str_value := str_value;
	}

	New(type : Node->Type) {
		@type := type;
	}

	New(type : Token->Type) {
		select(type) {
			label Token->Type->ADD {
				@type := Node->Type->ADD;
			}

			label Token->Type->SUB {
				@type := Node->Type->SUB;
			}
			
			label Token->Type->MUL {
				@type := Node->Type->MUL;
			}
			
			label Token->Type->DIV {
				@type := Node->Type->DIV;
			}
		};
	}

	method : public : GetType() ~ Node->Type {
		return @type;
	}

	method : public : GetIntValue() ~ Int {
		return @int_value;
	}

	method : public : GetRealValue() ~ Float {
		return @real_value;
	}

	method : public : AddChild(node : Node) ~ Nil {
		if(@children = Nil) {
			@children := Vector->New()<Node>;
		};

		@children->AddBack(node);
	}

	method : public : GetChildren() ~ Vector<Node> {
		return @children;
	}

	method : public : ToString() ~ String {
		return ToString(0);
	}

	method : public : ToString(level : Int) ~ String {
		buffer := "";

		each(l : level) {
			buffer += "  ";
		};
		buffer += "[";

		select(@type) {
			label Node->Type->ADD {
				buffer += "+";
			}

			label Node->Type->LIST {
				buffer += "list";
			}

			label Node->Type->EMPTY_LIST {
				buffer += "empty_list";
			}

			label Node->Type->SUB {
				buffer += "-";
			}

			label Node->Type->MUL {
				buffer += "*";
			}

			label Node->Type->DIV {
				buffer += "/";
			}

			label Node->Type->INT_LIT {
				buffer += @int_value->ToString();
			}

			label Node->Type->REAL_LIT {
				buffer += @real_value->ToString();
			}

			label Node->Type->STRING_LIT {
				buffer += @str_value;
			}
		};

		if(@children <> Nil) {
			each(i : @children) {
				buffer += '\n';
				buffer += @children->Get(i)->ToString(level + 1);
			};
			
		};
		buffer += "]";

		return buffer;
	}
}

#--- Scanner ---

class Scanner {
	@keywords : Hash<String, Token->Type>;

	New() {
		@keywords := Hash->New()<String, Token->Type>;

		@keywords->Insert("write", Token->Type->WRITE_KEYWORD);
		@keywords->Insert("list", Token->Type->LIST_KEYWORD);
		@keywords->Insert("cons", Token->Type->CONS_KEYWORD);
	}

	method : public : Scan(input : String) ~ Vector<Token> {
		tokens := Vector->New()<Token>;

		each(i : input) {
			while(input->Get(i) = ' ' | input->Get(i) = '\r' | input->Get(i) = '\n' | input->Get(i) = '\t') {
				i += 1;
			};

			if(input->Get(i)->IsChar()) {
				start := i;
				while(input->Get(i)->IsChar() | input->Get(i) = '_') {
					i += 1;
				};
				ident := input->SubString(start, i - start);

				found := @keywords->Find(ident);
				if(found = Nil) {
					tokens->AddBack(Token->New(Token->Type->STR_LIT, ident));
				}
				else {
					tokens->AddBack(Token->New(found));
				};

				i -= 1;
			}
			else if(input->Get(i)->IsDigit()) {
				is_real := false;

				start := i;
				while(input->Get(i)->IsDigit() | input->Get(i) = '.') {
					if(input->Get(i) = '.') {
						is_real := true;
					};
					i += 1;
				};

				value := input->SubString(start, i - start);
				if(is_real) {
					tokens->AddBack(Token->New(value->ToFloat()));
				}
				else {
					tokens->AddBack(Token->New(value->ToInt()));
				};
				i -= 1;
			}
			else {
				select(input->Get(i)) {
					label '(' {
						tokens->AddBack(Token->New(Token->Type->OPRN));
					}

					label ')' {
						tokens->AddBack(Token->New(Token->Type->CPRN));
					}

					label '+' {
						tokens->AddBack(Token->New(Token->Type->ADD));
					}

					label '-' {
						tokens->AddBack(Token->New(Token->Type->SUB));
					}

					label '*' {
						tokens->AddBack(Token->New(Token->Type->MUL));
					}

					label '/' {
						tokens->AddBack(Token->New(Token->Type->DIV));
					}

					other {
						tokens->AddBack(Token->New(Token->Type->OTHER));
					}
				};
			};
		};

		return tokens;
	}
}

class Token {
	@type : Token->Type;
	@str_value : String;
	@int_value : Int;
	@real_value : Float;

	enum Type {
		WRITE_KEYWORD,
		LIST_KEYWORD,
		CONS_KEYWORD,
		STR_LIT,
		INT_LIT,
		REAL_LIT,
		OPRN,
		CPRN,
		ADD,
		SUB,
		MUL,
		DIV,
		OTHER
	}

	New(type : Token->Type) {
		@type := type;
	}

	New(type : Token->Type, ident : String) {
		@type := type;
		@ident := ident;
	}

	New(int_value : Int) {
		@type := Type->INT_LIT;
		@int_value := int_value;
	}

	New(real_value : Float) {
		@type := Type->REAL_LIT;
		@real_value := real_value;
	}

	method : public : GetType() ~ Token->Type {
		return @type;
	}

	method : public : GetStringValue() ~ String {
		return @str_value;
	}

	method : public : GetIntValue() ~ Int {
		return @int_value;
	}

	method : public : GetRealValue() ~ Float {
		return @real_value;
	}

	method : public : ToString() ~ String {
		select(@type) {
			label Type->OPRN {
				return "(";
			}

			label Type->CPRN {
				return ")";
			}
			
			label Type->ADD {
				return "+";
			}
			
			label Type->SUB {
				return "-";
			}

			label Type->MUL {
				return "*";
			}
			
			label Type->DIV {
				return "/";
			}

			label Type->WRITE_KEYWORD {
				return "write";
			}

			label Type->LIST_KEYWORD {
				return "list";
			}

			label Type->STR_LIT {
				return @str_value;
			}
			
			label Type->INT_LIT {
				return @int_value->ToString();
			}
			
			label Type->REAL_LIT {
				return @real_value->ToString();
			}

			other {
				return "?";
			}
		};
	}
}