class TicTacToe {
	@board : Char[,];
	@opening : Bool;

	enum Status {
		PLAYING,
		TIE,
		PLAYER_WIN,
		CPU_WIN,
		INVALID_MOVE,
		QUIT
	}

	function : Main(args : String[]) ~ Nil {
		cpu_score := 0;
		player_score := 0;

		players_turn := true;
		for(i :=0; i < 5; i += 1;) {
			game := TicTacToe->New();
			result := game->Play(players_turn);
			players_turn := players_turn ? false : true;
			if(result = Status->PLAYER_WIN) {
				player_score += 1;
				"\n=> Player Wins!"->PrintLine();
			}
			else if(result = Status->CPU_WIN) {
				cpu_score += 1;
				"\n=> CPU Wins!"->PrintLine();
			}
			else if(result = Status->TIE) {							
				"\n=> Tie."->PrintLine();
			}
			else {
				break;
			};
		};

		"\nHuman={$player_score}, CPU={$cpu_score}"->PrintLine();
	}

	New() {
		@board := Char->New[3, 3];
		for(index := 0; index < 9; index += 1;) {
			j := index / 3;
			i := index % 3;
			@board[i, j] := '1' + index; 
		};

		@opening := true;
	}

	method : Play(players_turn : Bool) ~ Status {
		"\n*** NEW ***\n"->PrintLine();
		Draw();

		playing := true;
		do {
			status : Status;
			if(players_turn) { 
				status := PlayerMove();
				players_turn := false;
			}
			else {
				status := CpuMove();
				players_turn := true;
			};

			if(status = Status->INVALID_MOVE) {
				"\n=> Invalid Move"->PrintLine();
			}
			else if(status = Status->PLAYER_WIN) {
				return Status->PLAYER_WIN;
			}
			else if(status = Status->CPU_WIN) {
				return Status->CPU_WIN;
			}
			else if(status = Status->TIE) {
				return Status->TIE;
			}
			else if(status = Status->QUIT) {
				playing := false;
			};

			Draw();
		}
		while(playing);

		return Status->QUIT;
	}					

	method : PlayerMove() ~ Status {
		move := System.IO.Console->ReadString();
		if(move->Size() = 0) {
			return Status->INVALID_MOVE;
		};

		option := move->Get(0);
		if(option = 'q') {
			return Status->QUIT;
		};


		if(LegalMove(option, 'X')) {
			if(CheckWinner(@board, 'X')) {
				return Status->PLAYER_WIN;
			}
			else if(CheckTie()) {
				return Status->TIE;
			}
			else {
				return Status->PLAYING;
			};
		}
		else {
			return Status->INVALID_MOVE;
		};
	}

	method : CpuMove() ~ Status {
		BestMove(CopyBoard());
		
		if(CheckWinner(@board, 'O')) {
			return Status->CPU_WIN;
		}
		else if(CheckTie()) {
			return Status->TIE;
		}
		else {
			return Status->PLAYING;
		};

#~
		move := (Int->Random(8) + '1')->As(Char);
		while(<>CheckTie() & <>LegalMove(move, 'O')) {
			move := (Int->Random(8) + '1')->As(Char);
		};		
~#		
	}

	method : Minimax(board : Char[,], depth : Int, is_max : Bool) ~ Int {
    	score := Evaluate(board); 
  		if(score = 10 | score = -10) {
        	return score; 
  		};

  		if(CheckTie()) {
  			return 0;
  		};

		if(is_max) { 
        	best := -1000; # empty 
        	for(i := 0; i < 3; i += 1;) { 
				for(j := 0; j < 3; j += 1;) {
					if(board[i,j] <> 'X' & board[i,j] <>'O') { 
						test := board[i,j];
# "-- 2: {$test} ---"->PrintLine();

						board[i,j] := 'O'; 	  
						best := Int->Max(best, Minimax(board, depth + 1, is_max ? false : true)); 
						board[i,j] := test; 
					}; 
				};
			};

			return best;
		}
		else {
			best := 1000; # empty 
        	for(i := 0; i < 3; i += 1;) { 
				for(j := 0; j < 3; j += 1;) {
					if(board[i,j] <> 'X' & board[i,j] <>'O') { 
						test := board[i,j];
# "-- 1: {$test} ---"->PrintLine();
						board[i,j] := 'X'; 	  
						best := Int->Min(best, Minimax(board, depth + 1, is_max ? false : true)); 
						board[i,j] := test; 
					}; 
				};
			};

			return best;
		};
    }

    method : BestMove(board : Char[,]) ~ Nil {
    	best := -1000; # empty 
    	best_i := -1;
    	best_j := -1;
"### In: {$best_i}, {$best_j} ####"->PrintLine();

    	for(i := 0; i < 3; i += 1;) { 
			for(j := 0; j < 3; j += 1;) {
				if(board[i,j] <> 'X' & board[i,j] <> 'O') { 
					test := board[i,j];
					board[i,j] := 'O';	  
					move := Int->Max(best, Minimax(board, 0, false)); 
					board[i,j] := test;
# "-- 0: {$test} ---"->PrintLine();
					if(move > best) { 
						best_i := i;
    					best_j := j;
						best := move;
					};
                };
			};
		};

		@board[best_i, best_j] := 'O';

"### Out: {$best}: {$best_i}, {$best_j} ####"->PrintLine();
    }

    method : Evaluate(board : Char[,]) ~ Int {
    	if(CheckWinner(board, 'O')) {
    		return 10;
    	}
    	else if(CheckWinner(board, 'X')) {
    		return -10;
    	}
    	else {
    		return 0;
    	};
    }

    method : CopyBoard() ~ Char[,] {
    	board := Char->New[3, 3];

    	for(i := 0; i < 3; i += 1;) { 
			for(j := 0; j < 3; j += 1;) {
				board[i,j] := @board[i,j];
			};
		};

		return board;
    }

	method : LegalMove(move : Char, player: Char) ~ Bool {
		if(move >= '1' & move <= '9') {
			index := (move - '1')->As(Int);
			j := index / 3; i := index % 3;

			if(@board[i, j] = 'X' | @board[i, j] = 'O') {
				return false;
			};

			@board[i, j] := player;
			return true;
		}
		else {
			return false;
		};
	}

	method : CheckWinner(board : Char[,], player : Char) ~ Bool {
		# --- diagonal --- 
		check := 0;
		for(i := 0; i < 3; i += 1;) {
			if(board[i, i] = player) {
				check += 1;
			};
		};

		if(check = 3) {
			return true;
		};

		check := 0;
		j := 2;
		for(i := 0; i < 3; i += 1;) {
			if(board[i, j] = player) {
				check += 1;
			};
			j -= 1;
		};

		if(check = 3) {
			return true;
		};

		# --- vertical ---
		for(i := 0; i < 3; i += 1;) {
			check := 0;
			for(j := 0; j < 3; j += 1;) {
				if(board[i, j] = player) {
					check += 1;
				};
			};

			if(check = 3) {
				return true;
			};
		};

		# --- horizontal --- 
		for(j := 0; j < 3; j += 1;) {
			check := 0;
			for(i := 0; i < 3; i += 1;) {
				if(board[i, j] = player) {
					check += 1;
				};
			};

			if(check = 3) {
				return true;
			};
		};

		return false;
	}

	method : CheckTie() ~ Bool {
		for(i := 0; i < 3; i += 1;) {
			for(j := 0; j < 3; j += 1;) {
				if(@board[i, j] <> 'X' & @board[i, j] <> 'O') {
					return false;
				};
			}; 
		};

		return true;
	}

	method : Draw() ~ Nil {
		a1 := @board[0, 0]; a2 := @board[1, 0]; a3 := @board[2, 0];
		b1 := @board[0, 1]; b2 := @board[1, 1]; b3 := @board[2, 1];
		c1 := @board[0, 2]; c2 := @board[1, 2]; c3 := @board[2, 2];

		"==========="->PrintLine();
		" {$a1} | {$a2} | {$a3} "->PrintLine();
		"---|---|---"->PrintLine();
		" {$b1} | {$b2} | {$b3} "->PrintLine();
		"---|---|---"->PrintLine();
		" {$c1} | {$c2} | {$c3} "->PrintLine();
		"==========="->PrintLine();
	}
}