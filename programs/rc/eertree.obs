use Collection.Generic;

class Eertree {
	function : Main(args : String[]) ~ Nil {
		tree := GetEertree("eertree");
		tree->Size()->PrintLine();
	}

	function : GetEertree(s : String) ~ Vector<Node> {
		tree := Vector->New()<Node>;
		tree->AddBack(Node->New(0, Nil, 1));
		tree->AddBack(Node->New(-1, Nil, 1));
		suffix := 1;
		
		n : Int; k : Int;
		for(i := 0; i < s->Size(); ++i;) {
			c := s->Get(i);

			done := false;
			for (j := suffix; <>done; j := tree->Get(j)->GetSuffix();) {			
                k := tree->Get(j)->GetLength();
                b := i - k - 1;
                if (b >= 0 & s->Get(b) = c) {
					n := j;        	
                    done := true;
                };
            };
            continue := false;
            if (tree->Get(n)->GetEdges()->Has(c)) {
                suffix := tree->Get(n)->GetEdges()->Find(c)->Get();
                continue := true;
            };

            if(<>continue) {           	
           		suffix := tree->Size();
	            tree->AddBack(Node->New(k + 2));
				tree->Get(n)->GetEdges()->Insert(c, suffix);
	            if (tree->Get(suffix)->GetLength() = 1) {
	                tree->Get(suffix)->SetSuffix(0);
	                continue := true;
	            };

	            if(<>continue) {
	            	done := false;
					while (<>done) {
						n := tree->Get(n)->GetSuffix();
						b := i - tree->Get(n)->GetLength() - 1;
						if (b >= 0 & s->Get(b) = c) {
						    done := true;
						};
					};
					tree->Get(suffix)->SetSuffix(tree->Get(n)->GetEdges()->Find(c)->Get());
				};					
			};
		};

		return tree;
    }

    function : SubPalindromes(tree : Vector<Node>) ~ Vector<String> {
		s := Vector->New()<String>;
		SubPalindromesChildren(0, "", tree, s);

		keys := tree->Get(1)->GetEdges()->GetKeys()<CharHolder>;
		each(k : keys) {
			key := keys->Get(k);
			value : IntHolder := tree->Get(1)->GetEdges()->Find(key);


		};
#~		
		for (Map.Entry<Character, Integer> cm : tree.get(1).edges.entrySet()) {
			ct := String.valueOf(cm.getKey());
			s->Add(ct);
			SubPalindromesChildren(cm.getValue(), ct, tree, s);
		};
~#
		return s;
    }

    function : SubPalindromesChildren(n : Int, p : String, tree : Vector<Node>, s : Vector<String>)  ~ Nil {
    }
}

class Node {
    @length : Int;
    @edges : Map<CharHolder, IntHolder>;
    @suffix : Int;

    New(length : Int, edges : Map<CharHolder, IntHolder>, suffix : Int) {
    	@length := length;
        @edges := edges <> Nil ? edges : Map->New()<CharHolder, IntHolder>;
        @suffix := suffix;
    }

    New(length : Int) {
        @length := length;
        @edges := Map->New()<CharHolder, IntHolder>;
    }

    method : public : GetLength() ~ Int {
    	return @length;
    }

    method : public : GetSuffix() ~ Int {
    	return @suffix;
    }

    method : public : SetSuffix(suffix : Int) ~ Nil {
    	@suffix := suffix;
    }

    method : public : GetEdges() ~ Map<CharHolder, IntHolder> {
    	return @edges;
    }
}