class Foo {
	function : Main(args : String[]) ~ Nil {
		arrayA := ['s', 'p','a','c','e'];
		arrayB := [' ', 'd','o','g',' '];
		arrayC := ['c', 'a','t'];

		a := Stringy->New(arrayA);
		b := Stringy->New(arrayB);
		c := Stringy->New(arrayC);
		
		a->PrintLine();
		a->Append(b);
		a->Append(arrayA, 1, 3);
		a->PrintLine();
		a->Size()->PrintLine();
	}
}

class Stringy {
	@string : Char[];
	@max : Int;
	@pos : Int;

	#~
	Default constructor
	~#
	New() {
		Parent();

		@max := 5;
		@pos := 0;
		@string := Char->New[@max];
	}

	#~
	Copy constructor
	@param string string copy
	~#
	New(string : Stringy) {
		Parent();

		chars := string->InteralArray();
		@max := @pos := string->Size();
		@string := Char->New[@max];

		Runtime->Copy(@string, 0, chars, 0, @max);
	}

	#~
	Copy constructor
	@param bytes array to copy
	~#
	New(chars : Char[]) {
		Parent();

		@max := @pos := chars->Size();
		@string := Char->New[@max];

		Runtime->Copy(@string, 0, chars, 0, @max);
	}

	#~
	Copy constructor
	@param array array to copy
	@param offset offset into array index
	@param length number of characters to copy
	~#
	New(chars : Char[], offset : Int, length : Int) {
		Parent();

		space := offset + length; size := chars->Size();
		if(offset < 0 | offset > size | space < 0 | space > size) {
			@max := 5;
			@pos := 0;
			@string := Char->New[@max];
		}
		else {
			@string := Char->New[length];
			Runtime->Copy(@string, 0, chars, offset, length)->PrintLine();
			@max := @pos := length;
		};
	}

	#~
	Copy constructor
	@param bytes array to copy
	~#
	New(bytes : Byte[]) {
		Parent();

		chars := bytes->ToUnicode();
		@max := @pos := chars->Size();
		@string := Char->New[@max];

		Runtime->Copy(@string, 0, chars, 0, @max);
	}

	#~
	Copy constructor
	@param array array to copy
	@param offset offset into array index
	@param length number of bytes to copy
	~#
	New(bytes : Byte[], offset : Int, length : Int) {
		Parent();

		chars := bytes->ToUnicode();
		space := offset + length; 
		size := chars->Size();
		if(offset < 0 | offset > size | space < 0 | space > size) {
			@max := 5;
			@pos := 0;
			@string := Char->New[@max];
		}
		else {
			@string := Char->New[length];
			Runtime->Copy(@string, 0, chars, offset, length)->PrintLine();
			@max := @pos := length;
		};
	}
	
	method : Resize(amount : Int) ~ Nil {
		if(amount + @pos > @max) {
			max := @max * 2;
			temp := Char->New[max];
			Runtime->Copy(temp, 0, @string, 0, @max);

			@string := temp;
			@max := max;
		};
	}

	#~
	Appends a boolean value
	@param b boolean value
	~#
	method : public : Append(b : Bool) ~ Nil {
		if(b) {
			Append("true"->ToCharArray());
		}
		else {
			Append("false"->ToCharArray());
		};
	}

	#~
	Appends a integer value
	@param j integer value
	~#
	method : public : Append(j : Int) ~ Nil {
		Append(j->ToString()->ToCharArray());
	}

	#~
	Appends a float value
	@param f float value
	~#
	method : public : Append(f : Float) ~ Nil {
		Append(f->ToString()->ToCharArray());
	}

	#~
	Appends a string
	@param str string object
	~#
	method : public : Append(str : Stringy) ~ Nil {
		Append(str->ToCharArray());
	}

	#~
	Appends a character array
	@param chars character array
	~#
	method : public : Append(chars : Char[]) ~ Nil {
		length := chars->Size();
		Resize(length);
		Runtime->Copy(@string, @pos, chars, 0, length);
		@pos += length;
	}

	#~
	Appends a portion of character chars
	@param chars chars to be copied
	@param offset offset chars index offset
	@param length number of characters to copy
	~#
	method : public : Append(chars : Char[], offset : Int, length : Int) ~ Bool {
		space := offset + length; 
		size := chars->Size();

		if(offset < 0 | offset > size | space < 0 | space > size) {
			return false;
		};

		Resize(space);
		Runtime->Copy(@string, @pos, chars, offset, length);
		@pos += length;

		return true;
	}

	#~
	Appends a character bytes
	@param bytes bytes to be copied
	~#
	method : public : Append(bytes : Byte[]) ~ Nil {
		chars := bytes->ToUnicode();
		length := chars->Size();
		Resize(length);
		Runtime->Copy(@string, @pos, chars, 0, length);
		@pos += length;
	}

	#~
	Appends a portion of byte bytes
	@param bytes bytes to be copied
	@param offset offset bytes index offset
	@param length number of characters to copy
	~#
	method : public : Append(bytes : Byte[], offset : Int, length : Int) ~ Bool {
		space := offset + length; 
		chars := bytes->ToUnicode();
		size := chars->Size();

		if(offset < 0 | offset > size | space < 0 | space > size) {
			return false;
		};

		Resize(space);
		Runtime->Copy(@string, @pos, chars, offset, length);
		@pos += length;

		return true;
	}





	method : public : Append(char : Char) ~ Nil {
		Resize(1);

		@string[@pos] := char;
		@pos += 1;
	}

	method : public : SubString(length : Int) ~ Stringy {
		return SubString(0, length);
	}

	method : public : SubString(offset : Int, length : Int) ~ Stringy {
		return Stringy->New(@string, offset, length);
	}

	method : public : Delete(offset : Int, length : Int) ~ Bool {
		space := offset + length;
		if(offset < 0 | offset > @pos | space < 0 | space > @pos) {
			return false;
		};

		max := @max - length;
		temp := Char->New[max];
		Runtime->Copy(temp, 0, @string, 0, offset);
		Runtime->Copy(temp, offset, @string, space, @max - space);

		@string := temp;	
		@max := @pos := max;

		return true;
	}

	#~
	Returns a character array representation of the Stringy
	@return character array
	~#
	method : public : ToCharArray() ~ Char[] {
		temp := Char->New[@pos];
		Runtime->Copy(temp, 0, @string, 0, @pos);
		return temp;
	}

	#~
	Returns a byte array representation of the Stringy
	@return byte array
	~#
	method : public : ToByteArray() ~ Byte[] {
		temp := Byte->New[@pos];
		bytes :=  @string->ToBytes();
		Runtime->Copy(temp, 0, bytes, 0, @pos);
		return temp;
	}

	method : InteralArray() ~ Char[] {
		return @string;
	}

	#~
	Returns rather the string is empty
	@return true if empty, false otherwise 
	~#
	method : public : IsEmpty() ~ Bool {
		return @pos = 0 ? true : false; 			
	}

	#~
	Returns character at the given index
	@param index index offset
	@return character at index
	~#
	method : public : Get(index : Int) ~ Char {
		if(index > -1 & index < @pos) {
			return @string[index];
		};

		return '\0';
	}

	#~
	Searches for the first occurrence of a string
	@param find string to search for
	@return index of first occurrence, -1 otherwise
	~#
	method : public : Find(find : Stringy) ~ Int {
		return Find(0, find);
	}

	#~
	Searches for the first occurrence of a string
	@param offset search index offset
	@param find string to search for
	@return index of first occurrence, -1 otherwise
	~#
	method : public : native : Find(offset : Int, find : Stringy) ~ Int {
		size := find->Size();
		if(size > 0 & offset < @pos) {
			found := Find(offset, find->Get(0));
			while(found > -1) {
				match := true;
				i := found;	j : Int;
				for(j := 0; match & j < size & i < @pos; j += 1;) {
					if(find->Get(j) <> @string[i]) {
						match := false;
					};
					i += 1;
				};

				if(match & j = size) {
					return found;
				};
				
				found := Find(found + 1, find->Get(0));
			};

			return -1;
		};

		return -1;
	}



	#~
	Searches for the first occurrence of a character
	@param char character to search for
	@return index of first occurrence, -1 otherwise
	~#
	method : public : Find(char : Char) ~ Int {
		return Find(0, char);
	}
	
	#~
	Searches for the first occurrence of a character
	@param offset search offset
	@param char character to search for
	@return index of first occurrence, -1 otherwise
	~#
	method : public : Find(offset : Int, char : Char) ~ Int {
		if(offset < @pos & offset > -1) {
			each(j : @pos) {
				if(@string[j] = char) {
					return j;
				};
			};
		};

		return -1;
	}

	#~
	Parses the string into an integer
	@return integer value
	~#
	method : public : ToInt() ~ Int {
		return ToInt(10);
	}

	#~
	Parses the string into an integer
	@param base base radix 
	@return integer value
	~#
	method : public : ToInt(base : Int) ~ Int {
#		S2I;
return 0;
	}

	#~
	Parses the string into a float
	@return float value
	~#
	method : public : ToFloat() ~ Float {
#		S2F;
return 0;
	}

	#~
	Checks if the string starts with the given character
	@param c character to compare
	@return true if starts with character, false otherwise
	~#
	method : public : native : StartsWith(c : Char) ~ Bool {
		sc : Char := Get(0);
		return sc <> '\0' & c = sc;
	}
	
	#~
	Checks if the string ends with the given character
	@param c character to compare
	@return true if ends with character, false otherwise
	~#
	method : public : native : EndsWith(c : Char) ~ Bool {
		if(@pos > 0) {
			sc := @string[@pos - 1];
			return sc <> '\0' & c = sc;
		};
		
		return false;
	}

	#~
	Checks if the string starts with the given string
	@param s string to check for
	@return true if starts with string, false otherwise
	~#
	method : public : native : StartsWith(s : Stringy) ~ Bool {
		size := s->Size();
		if(size <= @pos) {
			for(i := 0; i < size; i += 1;) {
				if(s->Get(i) <> @string[i]) {
					return false;
				};
			};

			return true;
		};

		return false;
	}

	#~
	Checks if the string ends with the given character
	@param s string to check for
	@return true if ends with character, false otherwise
	~#
	method : public : native : EndsWith(s : Stringy) ~ Bool {
		if(s->Size() <= @pos) {
			i := s->Size() - 1;
			j := @pos - 1;
			while(i > -1) {
				if(s->Get(i) <> @string[j]) {
					return false;
				};
				i := i - 1;
				j := j - 1;
			};

			return true;
		};

		return false;
	}
	
	#~
	Reverses a string
	@return reversed string 
	~#
	method : public : native : Reverse() ~ Stringy {
		tmp : Char[] := Char->New[@max];
		i := 0; j := @pos - 1;
		while(j > -1) {
			tmp[i] := @string[j];
			j -= 1;	i += 1;
		};
		
		return Stringy->New(tmp);
	}
	
	#~
	Removes all leading and ending white space
	@return trimmed string
	~#
	method : public : native : Trim() ~ Stringy {
		if(@pos = 0) {
			return Stringy->New();
		};

		start := 0;
		c := @string[start];
		while(start < @pos & (c = ' ' | c = '\t' | c = '\r' | c = '\n' | c = 0xa0 | c = 0x1680 | 
				c >= 0x2000 & c <= 0x200a | c >= 0x000a & c <= 0x000d | c = 0x202f | 
				c = 0x205f | c = 0x3000 | c = 0x0085 | c = 0x2029)) {
			start += 1;
			c := @string[start];
		};

		end := @pos;
		do {
			end -= 1;
		}
		while(end > -1 & (@string[end] = ' ' | @string[end] = '\t' | @string[end] = '\r' | @string[end] = '\n' |
			@string[end] = 0xa0 | @string[end] = 0x1680 | @string[end] >= 0x2000 & @string[end] <= 0x200a | 
			@string[end] >= 0x000a & @string[end] <= 0x000d | @string[end] = 0x202f | @string[end] = 0x205f | 
			@string[end] = 0x3000 | @string[end] = 0x0085 | @string[end] = 0x2029));

		if(end < start) {
			return Stringy->New();
		};

		return Stringy->New(@string, start, end - start + 1);
	}
	
	#~
	Splits a string based upon delimiter
	@param delim splitting delimiter
	@return array of split sub strings 
	~#
	method : public : native : Split(delim : Stringy) ~ Stringy[] {
		delim_size := delim->Size();
		if(delim->Size() = 0 | @pos = 0) {
			return Nil;
		};
		
		# first-pass count tokens
		count := 0;
		start_index := 0;
		found_index := -1;
		delim_index := 0;
		
		for(i : Int := 0; i < @pos; i += 1;) {
			if(found_index = -1 & delim->Get(0) = @string[i]) {
				found_index := i;
			};
			
			if(found_index > -1) {
				if(delim_index < delim_size & delim->Get(delim_index) = @string[i]) {
					delim_index += 1;
				}
				else if(delim_index = delim_size) {
					count += 1;
					start_index := found_index + delim_size;
					found_index := -1;
					delim_index := 0;
				}
				else {
					found_index := -1;
					delim_index := 0;
				};
			};
		};
		
		if(start_index <> 0) {
			count += 1;
			SubString(start_index, @pos - start_index);
		};
		
		# second-pass parse tokens
		parsed_strings : Stringy[] := Stringy->New[count];
		count := 0;
		start_index := 0;
		found_index := -1;
		delim_index := 0;
		
		for(i : Int := 0; i < @pos; i += 1;) {
			if(found_index = -1 & delim->Get(0) = @string[i]) {
				found_index := i;
			};
			
			if(found_index > -1) {
				if(delim_index < delim_size & delim->Get(delim_index) = @string[i]) {
					delim_index += 1;
				}
				else if(delim_index = delim_size) {
					parsed_strings[count] := SubString(start_index, found_index - start_index);
					count += 1;
					
					start_index := found_index + delim_size;
					found_index := -1;
					delim_index := 0;
				}
				else {
					found_index := -1;
					delim_index := 0;
				};
			};
		};
		
		if(start_index <> 0) {
			parsed_strings[count] := SubString(start_index, @pos - start_index);
			count += 1;
		};
		
		return parsed_strings;
	}
	
	#~
	Transforms a to upper case
	@return upper case string
	~#
	method : public : native : ToUpper() ~ Stringy {
		array : Char[] := Char->New[@pos];
		for(i : Int := 0; i < @pos; i += 1;) {
			c := @string[i];
			if(c > 96 & c < 123) {
				c := c - 32;
			};
			array[i] := c;
		};
		
		return Stringy->New(array);
	}
	
	#~
	Transforms a to lower case
	@return lower case string
	~#
	method : public : native : ToLower() ~ Stringy {
		array : Char[] := Char->New[@pos];
		for(i : Int := 0; i < @pos; i += 1;) {
			c := @string[i];
			if(c > 64 & c < 91) {
				c := c + 32;
			};
			array[i] := c;
		};
		
		return Stringy->New(array);
	}


	method : public : Size() ~ Int {
		return @pos;
	}

	method : public : PrintLine() ~ Nil {
		@string->PrintLine();
	}

	method : public : Print() ~ Nil {
		@string->Print();
	}
}