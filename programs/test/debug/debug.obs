class Foo {
	function : Main(args : String[]) ~ Nil {
		arrayA := ['s', 'p','a','c','e'];
		arrayB := [' ', 'd','o','g',' '];
		arrayC := ['c', 'a','t'];

		a := Stringy->New(arrayA);
		b := Stringy->New(arrayB);
		c := Stringy->New(arrayC);
		
		a->PrintLine();
		a->Append(b);
		a->Append(arrayA, 1, 3);
		a->PrintLine();
		a->Size()->PrintLine();
	}
}

class Stringy {
	@string : Char[];
	@max : Int;
	@pos : Int;

	#~
	Default constructor
	~#
	New() {
		Parent();

		@max := 5;
		@pos := 0;
		@string := Char->New[@max];
	}

	#~
	Copy constructor
	@param string string copy
	~#
	New(string : Stringy) {
		Parent();

		chars := string->InteralArray();
		@max := @pos := string->Size();
		@string := Char->New[@max];

		Runtime->Copy(@string, 0, chars, 0, @max);
	}

	#~
	Copy constructor
	@param bytes array to copy
	~#
	New(chars : Char[]) {
		Parent();

		@max := @pos := chars->Size();
		@string := Char->New[@max];

		Runtime->Copy(@string, 0, chars, 0, @max);
	}

	#~
	Copy constructor
	@param array array to copy
	@param offset offset into array index
	@param length number of characters to copy
	~#
	New(chars : Char[], offset : Int, length : Int) {
		Parent();

		space := offset + length; size := chars->Size();
		if(offset < 0 | offset > size | space < 0 | space > size) {
			@max := 5;
			@pos := 0;
			@string := Char->New[@max];
		}
		else {
			@string := Char->New[length];
			Runtime->Copy(@string, 0, chars, offset, length)->PrintLine();
			@max := @pos := length;
		};
	}

	#~
	Copy constructor
	@param bytes array to copy
	~#
	New(bytes : Byte[]) {
		Parent();

		chars := bytes->ToUnicode();
		@max := @pos := chars->Size();
		@string := Char->New[@max];

		Runtime->Copy(@string, 0, chars, 0, @max);
	}

	#~
	Copy constructor
	@param array array to copy
	@param offset offset into array index
	@param length number of bytes to copy
	~#
	New(bytes : Byte[], offset : Int, length : Int) {
		Parent();

		chars := bytes->ToUnicode();
		space := offset + length; 
		size := chars->Size();
		if(offset < 0 | offset > size | space < 0 | space > size) {
			@max := 5;
			@pos := 0;
			@string := Char->New[@max];
		}
		else {
			@string := Char->New[length];
			Runtime->Copy(@string, 0, chars, offset, length)->PrintLine();
			@max := @pos := length;
		};
	}
	
	method : Resize(amount : Int) ~ Nil {
		if(amount + @pos > @max) {
			max := @max * 2;
			temp := Char->New[max];
			Runtime->Copy(temp, 0, @string, 0, @max);

			@string := temp;
			@max := max;
		};
	}

	#~
	Appends a boolean value
	@param b boolean value
	~#
	method : public : Append(b : Bool) ~ Nil {
		if(b) {
			Append("true"->ToCharArray());
		}
		else {
			Append("false"->ToCharArray());
		};
	}

	#~
	Appends a integer value
	@param j integer value
	~#
	method : public : Append(j : Int) ~ Nil {
		Append(j->ToString()->ToCharArray());
	}

	#~
	Appends a float value
	@param f float value
	~#
	method : public : Append(f : Float) ~ Nil {
		Append(f->ToString()->ToCharArray());
	}

	#~
	Appends a string
	@param str string object
	~#
	method : public : Append(str : Stringy) ~ Nil {
		Append(str->ToCharArray());
	}

	#~
	Appends a character array
	@param chars character array
	~#
	method : public : Append(chars : Char[]) ~ Nil {
		length := chars->Size();
		Resize(length);
		Runtime->Copy(@string, @pos, chars, 0, length);
		@pos += length;
	}

	#~
	Appends a portion of character chars
	@param chars chars to be copied
	@param offset offset chars index offset
	@param length number of characters to copy
	~#
	method : public : Append(chars : Char[], offset : Int, length : Int) ~ Bool {
		space := offset + length; 
		size := chars->Size();

		if(offset < 0 | offset > size | space < 0 | space > size) {
			return false;
		};

		Resize(space);
		Runtime->Copy(@string, @pos, chars, offset, length);
		@pos += length;

		return true;
	}

	#~
	Appends a character bytes
	@param bytes bytes to be copied
	~#
	method : public : Append(bytes : Byte[]) ~ Nil {
		chars := bytes->ToUnicode();
		length := chars->Size();
		Resize(length);
		Runtime->Copy(@string, @pos, chars, 0, length);
		@pos += length;
	}

	#~
	Appends a portion of byte bytes
	@param bytes bytes to be copied
	@param offset offset bytes index offset
	@param length number of characters to copy
	~#
	method : public : Append(bytes : Byte[], offset : Int, length : Int) ~ Bool {
		space := offset + length; 
		chars := bytes->ToUnicode();
		size := chars->Size();

		if(offset < 0 | offset > size | space < 0 | space > size) {
			return false;
		};

		Resize(space);
		Runtime->Copy(@string, @pos, chars, offset, length);
		@pos += length;

		return true;
	}





	method : public : Append(char : Char) ~ Nil {
		Resize(1);

		@string[@pos] := char;
		@pos += 1;
	}

	method : public : SubString(length : Int) ~ Stringy {
		return SubString(0, length);
	}

	method : public : SubString(offset : Int, length : Int) ~ Stringy {
		return Stringy->New(@string, offset, length);
	}

	method : public : Delete(offset : Int, length : Int) ~ Bool {
		space := offset + length;
		if(offset < 0 | offset > @pos | space < 0 | space > @pos) {
			return false;
		};

		max := @max - length;
		temp := Char->New[max];
		Runtime->Copy(temp, 0, @string, 0, offset);
		Runtime->Copy(temp, offset, @string, space, @max - space);

		@string := temp;	
		@max := @pos := max;

		return true;
	}

	#~
	Returns a character array representation of the Stringy
	@return character array
	~#
	method : public : ToCharArray() ~ Char[] {
		temp := Char->New[@pos];
		Runtime->Copy(temp, 0, @string, 0, @pos);
		return temp;
	}

	#~
	Returns a byte array representation of the Stringy
	@return byte array
	~#
	method : public : ToByteArray() ~ Byte[] {
		temp := Byte->New[@pos];
		bytes :=  @string->ToBytes();
		Runtime->Copy(temp, 0, bytes, 0, @pos);
		return temp;
	}

	method : InteralArray() ~ Char[] {
		return @string;
	}

	#~
	Returns rather the string is empty
	@return true if empty, false otherwise 
	~#
	method : public : IsEmpty() ~ Bool {
		return @pos = 0 ? true : false; 			
	}

	#~
	Returns character at the given index
	@param index index offset
	@return character at index
	~#
	method : public : Get(index : Int) ~ Char {
		if(index > -1 & index < @pos) {
			return @string[index];
		};

		return '\0';
	}

	#~
	Searches for the first occurrence of a string
	@param find string to search for
	@return index of first occurrence, -1 otherwise
	~#
	method : public : Find(find : Stringy) ~ Int {
		return Find(0, find);
	}

	#~
	Searches for the first occurrence of a string
	@param offset search index offset
	@param find string to search for
	@return index of first occurrence, -1 otherwise
	~#
	method : public : native : Find(offset : Int, find : Stringy) ~ Int {
		size := find->Size();
		if(size > 0 & offset < @pos) {
			found := Find(offset, find->Get(0));
			while(found > -1) {
				match := true;
				i := found;	j : Int;
				for(j := 0; match & j < size & i < @pos; j += 1;) {
					if(find->Get(j) <> @string[i]) {
						match := false;
					};
					i += 1;
				};

				if(match & j = size) {
					return found;
				};
				
				found := Find(found + 1, find->Get(0));
			};

			return -1;
		};

		return -1;
	}



	#~
	Searches for the first occurrence of a character
	@param char character to search for
	@return index of first occurrence, -1 otherwise
	~#
	method : public : Find(char : Char) ~ Int {
		return Find(0, char);
	}
	
	#~
	Searches for the first occurrence of a character
	@param offset search offset
	@param char character to search for
	@return index of first occurrence, -1 otherwise
	~#
	method : public : Find(offset : Int, char : Char) ~ Int {
		if(offset < @pos & offset > -1) {
			each(j : @pos) {
				if(@string[j] = char) {
					return j;
				};
			};
		};

		return -1;
	}




	method : public : Size() ~ Int {
		return @pos;
	}

	method : public : PrintLine() ~ Nil {
		@string->PrintLine();
	}

	method : public : Print() ~ Nil {
		@string->Print();
	}
}