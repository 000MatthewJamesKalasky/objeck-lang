use Collection.Generic;

bundle CodeGen {
	#~
	Token scanner
	~#
	class Scanner {
		@filename : String;
		@tokens : Vector<Token>;

		New(filename : String) {
			@filename := filename;
			@tokens := Vector->New()<Token>;
		}
		
		method : public : Scan() ~ Vector<Token> {
			reserved := Map->New()<String, Token>;
			# GTK3 sync keywords
			reserved->Insert("GDK_AVAILABLE_IN_ALL", Token->New(Token->Type->GDK_AVAILABLE_IN_ALL_ID, "GDK_AVAILABLE_IN_ALL"));
			reserved->Insert("GDK_AVAILABLE_IN_3_0", Token->New(Token->Type->GDK_AVAILABLE_IN_3_0_ID, "GDK_AVAILABLE_IN_3_0"));
			reserved->Insert("GDK_AVAILABLE_IN_3_2", Token->New(Token->Type->GDK_AVAILABLE_IN_3_2_ID, "GDK_AVAILABLE_IN_3_2"));
			reserved->Insert("GDK_AVAILABLE_IN_3_4", Token->New(Token->Type->GDK_AVAILABLE_IN_3_4_ID, "GDK_AVAILABLE_IN_3_4"));
			reserved->Insert("GDK_AVAILABLE_IN_3_6", Token->New(Token->Type->GDK_AVAILABLE_IN_3_6_ID, "GDK_AVAILABLE_IN_3_6"));
			reserved->Insert("GDK_AVAILABLE_IN_3_8", Token->New(Token->Type->GDK_AVAILABLE_IN_3_8_ID, "GDK_AVAILABLE_IN_3_8"));
			reserved->Insert("GDK_AVAILABLE_IN_3_10", Token->New(Token->Type->GDK_AVAILABLE_IN_3_10_ID, "GDK_AVAILABLE_IN_3_10"));
			reserved->Insert("GDK_AVAILABLE_IN_3_12", Token->New(Token->Type->GDK_AVAILABLE_IN_3_12_ID, "GDK_AVAILABLE_IN_3_12"));

			# types to map
			reserved->Insert("GType", Token->New(Token->Type->GTYPE_ID, "GTYPE"));
			reserved->Insert("const", Token->New(Token->Type->CONST_ID, "const"));
			reserved->Insert("int", Token->New(Token->Type->INT_ID, "int"));
			reserved->Insert("char", Token->New(Token->Type->CHAR_ID, "char"));
			reserved->Insert("void", Token->New(Token->Type->VOID_ID, "void"));
			reserved->Insert("gint", Token->New(Token->Type->GINT_ID, "guint"));
			reserved->Insert("guint", Token->New(Token->Type->GUINT_ID, "guint"));
			reserved->Insert("gboolean", Token->New(Token->Type->GBOOLEAN_ID, "GBOOLEAN_ID"));
			reserved->Insert("gchar", Token->New(Token->Type->GCHAR_ID, "GCHAR_ID"));
			
			reader := System.IO.Filesystem.FileReader->New(@filename);
			line_num := 0;
			while(reader->IsEOF() <> true) {
				line := reader->ReadLine();
				line_num := line_num + 1;

				i := 0;
				while(i < line->Size()) {
					# skip whitespace
					c := line->Get(i);
					while((c = ' ' | c = '\t' | c = '\r'| c = '\n') & i < line->Size()) {
						i += 1;
						c := line->Get(i);
					};

					# parse
					if(i < line->Size()) {
						# keyword
						if(line->Get(i)->IsChar()) {
							ident := "";
							c := line->Get(i);
							while(c->IsChar() | c->IsDigit() | c = '_') {
								ident->Append(line->Get(i));
								i += 1;
								c := line->Get(i);
							};
							
							result := reserved->Find(ident);
							if(result <> Nil) {
								@tokens->AddBack(result);
							}
							else {
								@tokens->AddBack(Token->New(Token->Type->IDENT, ident));
							};
						}
						# number
						else if(line->Get(i)->IsDigit()) {
							number := "";
							c := line->Get(i);
							while(c->IsDigit()) {
								number->Append(line->Get(i));
								i += 1;
								c := line->Get(i);
							};
							@tokens->AddBack(Token->New(Token->Type->NUM, number));
						}
						# other
						else {
							select(line->Get(i)) {
								label '(': {
									@tokens->AddBack(Token->New(Token->Type->OPRN, "("));
								}
								
								label ')': {
									@tokens->AddBack(Token->New(Token->Type->CPRN, ")"));
								}

								label '[': {
									@tokens->AddBack(Token->New(Token->Type->OBR, "["));
								}

								label ']': {
									@tokens->AddBack(Token->New(Token->Type->CBR, "]"));
								}

								label ',': {
									@tokens->AddBack(Token->New(Token->Type->COMMA, ","));
								}
								
								label ';': {
									@tokens->AddBack(Token->New(Token->Type->SCOLON, ";"));
								}

								label '*': {
									@tokens->AddBack(Token->New(Token->Type->STAR, "*"));
								}
								
								label '&': {
									@tokens->AddBack(Token->New(Token->Type->AND, "*"));
								}
								
								other: {
									@tokens->AddBack(Token->New(Token->Type->UNKWN, "?"));
								}
							};
							# update
							i += 1;
						};
					};
				};
			};
			reader->Close();
			
			@tokens->AddBack(Token->New(Token->Type->EOS));
			return @tokens;
		}
	}
	
	#~
	Token
	~#
	class Token {
		#~
		Token type
		~#
		enum Type := -200 {
			GDK_AVAILABLE_IN_ALL_ID,
			GDK_AVAILABLE_IN_3_0_ID,
			GDK_AVAILABLE_IN_3_2_ID,
			GDK_AVAILABLE_IN_3_4_ID,
			GDK_AVAILABLE_IN_3_6_ID,
			GDK_AVAILABLE_IN_3_8_ID,
			GDK_AVAILABLE_IN_3_10_ID,
			GDK_AVAILABLE_IN_3_12_ID,
			INT_ID,
			CHAR_ID,
			GINT_ID,
			GTYPE_ID,
			GUINT_ID,
			GCHAR_ID,
			GBOOLEAN_ID,
			VOID_ID,
			CONST_ID,
			OPRN,
			CPRN,
			OBR,
			CBR,
			COMMA,
			SCOLON,
			STAR,
			AND,
			NUM,
			IDENT,
			UNKWN,
			EOS
		}
		
		@type : Token->Type;
		@value : String;

		New(type : Token->Type) {
			@type := type;
		}
		
		New(type : Token->Type, value : String) {
			@type := type;
			@value := value;
		}

		method : public : GetType() ~ Token->Type {
			return @type;
		}
		
		method : public : GetValue() ~ String {
			return @value;
		}

		method : public : ToString() ~ String {
			select(@type) {
				label Token->Type->GDK_AVAILABLE_IN_ALL_ID {
					return "GDK_AVAILABLE_IN_ALL_ID"; 
				}

				label Token->Type->GDK_AVAILABLE_IN_3_0_ID {
					return "GDK_AVAILABLE_IN_3_0_ID"; 
				}

				label Token->Type->GDK_AVAILABLE_IN_3_2_ID {
					return "GDK_AVAILABLE_IN_3_2_ID"; 
				}

				label Token->Type->GDK_AVAILABLE_IN_3_4_ID {
					return "GDK_AVAILABLE_IN_3_4_ID"; 
				}

				label Token->Type->GDK_AVAILABLE_IN_3_6_ID {
					return "GDK_AVAILABLE_IN_3_6_ID"; 
				}

				label Token->Type->GDK_AVAILABLE_IN_3_8_ID {
					return "GDK_AVAILABLE_IN_3_8_ID"; 
				}

				label Token->Type->GDK_AVAILABLE_IN_3_10_ID {
					return "GDK_AVAILABLE_IN_3_10_ID"; 
				}

				label Token->Type->GDK_AVAILABLE_IN_3_12_ID {
					return "GDK_AVAILABLE_IN_3_12_ID"; 
				}
				
				label Token->Type->INT_ID {
					return "type=INT_ID";
				}

				label Token->Type->CHAR_ID {
					return "type=CHAR_ID";
				}

				label Token->Type->GINT_ID {
					return "type=GINT_ID";
				}

				label Token->Type->GTYPE_ID {
					return "type=GTYPE_ID";
				}

				label Token->Type->GUINT_ID {
					return "type=GUINT_ID";
				}

				label Token->Type->GBOOLEAN_ID {
					return "type=GBOOLEAN_ID";
				}

				label Token->Type->GCHAR_ID {
					return "type=GCHAR_ID";
				}

				label Token->Type->VOID_ID {
					return "type=VOID_ID";
				}

				label Token->Type->CONST_ID {
					return "type=CONST_ID";
				}

				label Token->Type->OPRN {
					return "type=GCHAR_ID";
				}

				label Token->Type->CPRN {
					return "type=GCHAR_ID";
				}

				label Token->Type->OBR {
					return "type='{$@value}'";
				}

				label Token->Type->CBR {
					return "type='{$@value}'";
				}

				label Token->Type->COMMA {
					return "type='{$@value}'";
				}

				label Token->Type->SCOLON {
					return "type='{$@value}'";
				}

				label Token->Type->STAR {
					return "type='{$@value}'";
				}

				label Token->Type->AND {
					return "type='{$@value}'";
				}

				label Token->Type->NUM {
					return "type='{$@value}'";
				}

				label Token->Type->IDENT {
					return "type=IDENT, value=\"{$@value}\"";
				}
			};

			return "<unknown>";
		}
	}
}
