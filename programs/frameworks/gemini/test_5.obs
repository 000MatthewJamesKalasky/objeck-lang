use Web.HTTP, Data.JSON;

class Test {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {			
			Corpus->Delete("corpora/test1-ckee03muftrq")->ToString()->PrintLine();
			
			corpuses := Corpus->List();
			each(corpus in corpuses) {
				corpus->ToString()->PrintLine();
			};
		};
	}
}

class Corpus from OAuthEndPoint implements Stringify {
	@name : String;
	@display_name : String;
	@create_time_str : String;
	@update_time_str : String;

	New : private(request_json : JsonElement) {
		Parent();

		@name := request_json->Get("name")->GetString();
		@display_name := request_json->Get("displayName")->GetString();
		@create_time_str := request_json->Get("createTime")->GetString();
		@update_time_str := request_json->Get("updateTime")->GetString();
	}

	function : Create(name : String) ~ Corpus {
		request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
		request_json->Insert("displayName", name);
		data := request_json->ToString()->ToByteArray();
		# data->ToString()->PrintLine();

		token := GetToken();
		headers := Collection.Map->New()<String, String>;
		headers->Insert("Authorization", "Bearer {$token}");
		response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/corpora"), data, 
			"application/json", headers);

		if(response <> Nil) {
			#response->GetContent()->ToString()->PrintLine();
			
			response_json := JsonParser->TextToElement(response->GetContent()->ToString());
			if(response_json = Nil) {
				"### Error: Unable to parse response ###"->ErrorLine();
				return Nil;
			};
			
			if(response_json->Has("error")) {
				error_str := response_json->FindElements("error/message")->GetString();
				SetLastError(error_str);
				return Nil;
			};

			return Corpus->New(response_json);
		};

		return Nil;	
	}

	function : Get(name : String) ~ Corpus {
		token := GetToken();
		headers := Collection.Map->New()<String, String>;
		headers->Insert("Authorization", "Bearer {$token}");
		response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$name}"), 
			"application/json", headers);

		if(response <> Nil) {
			#response->GetContent()->ToString()->PrintLine();
			
			response_json := JsonParser->TextToElement(response->GetContent()->ToString());
			if(response_json = Nil) {
				"### Error: Unable to parse response ###"->ErrorLine();
				return Nil;
			};
			
			if(response_json->Has("error")) {
				error_str := response_json->FindElements("error/message")->GetString();
				SetLastError(error_str);
				return Nil;
			};

			return Corpus->New(response_json);
		};

		return Nil;	
	}

	function : List() ~ Collection.Vector<Corpus> {
		token := GetToken();
		headers := Collection.Map->New()<String, String>;
		headers->Insert("Authorization", "Bearer {$token}");
		response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/corpora"), 
			"application/json", headers);

		if(response <> Nil) {
			# response->GetContent()->ToString()->PrintLine();
			
			response_json := JsonParser->TextToElement(response->GetContent()->ToString());
			if(response_json = Nil) {
				"### Error: Unable to parse response ###"->ErrorLine();
				return Nil;
			};
			
			if(response_json->Has("error")) {
				error_str := response_json->FindElements("error/message")->GetString();
				SetLastError(error_str);
				return Nil;
			};

			corpuses := Collection.Vector->New()<Corpus>;
			
			corporas_json := response_json->Get("corpora");
			if(corporas_json <> Nil) {
				each(corpora_json in corporas_json) {
					corpuses->AddBack(Corpus->New(corpora_json));
				};
			};

			return corpuses;
		};

		return Nil;	
	}

	function : Delete(name : String) ~ Bool {
		token := GetToken();
		headers := Collection.Map->New()<String, String>;
		headers->Insert("Authorization", "Bearer {$token}");
		response := HttpsClient->QuickDelete(Url->New("https://generativelanguage.googleapis.com/v1beta/{$name}"), 
			"application/json", headers);
		
		if(response <> Nil) {
			# response->GetContent()->ToString()->PrintLine();
			
			response_json := JsonParser->TextToElement(response->GetContent()->ToString());
			if(response_json = Nil) {
				"### Error: Unable to parse response ###"->ErrorLine();
				return false;
			};
			
			if(response_json->Has("error")) {
				error_str := response_json->FindElements("error/message")->GetString();
				SetLastError(error_str);
				return false;
			};

			return true;
		};

		return false;	
	}

	#~
	String representation of the object
	@return string representation
	~#
	method : public : ToString() ~ String {
		buffer := "[name='";
		buffer += @name;

		buffer += "', display_name='"
		buffer += @display_name;

		buffer += "', create_time_str='"
		buffer += @create_time_str;

		buffer += "', update_time_str='"
		buffer += @update_time_str;

		buffer += "']";
		return buffer;
	}
}

class : private : OAuthEndPoint {
	@last_message : static : String;

	New() {}

	function : WriteNewToken() ~ Nil {
		scopes := ["https://www.googleapis.com/auth/cloud-platform", 
			"https://www.googleapis.com/auth/generative-language.retriever"];
		token := System.IO.Net.OAuth.OAuthClient->New("client_secret.json", scopes)->GetToken();

		token_str := token->GetAccessToken();
		date := System.Time.Date->New();
		date->AddSeconds(token->GetExpiresIn());
		date_str := date->ToShortString();

		System.IO.Filesystem.FileWriter->WriteFile("client_secret.dat", "{$date_str}\r\n{$token_str}");
	}

	function : ReadToken() ~ String {
		client_secrets := System.IO.Filesystem.FileReader->ReadFile("client_secret.dat");
		if(client_secrets <> Nil) {
			client_secret_parts := client_secrets->Split("\r\n");
			if(client_secret_parts->Size() = 2){
				date_str := client_secret_parts[0];
				create_time := System.Time.DateUtility->Parse(date_str, "MM/dd/yyyy hh:mm:ss", false);
				if(create_time->Compare(System.Time.Date->New(false)) > 0) {
					token_str := client_secret_parts[1];
					return token_str;
				};
			};
		};

		return Nil;
	}

	function : GetToken() ~ String {		
		token := ReadToken();
		if(token = Nil) {
			WriteNewToken();
			token := ReadToken();
		};

		return token;
	}

	function : SetLastError(last_message : String) ~ Nil {
		@last_message := last_message;
	}

	#~
	Get the last error
	@return last error
	~#
	function : GetLastError() ~ String {
		return @last_message;
	}
}
