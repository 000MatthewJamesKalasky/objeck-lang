use Collection;

class StreamParser {
	@elem_stack : StreamParser->Type[];
	@elem_stack_pos : Int;

	@doc_stream : Char[];
	@doc_stream_pos : Int;

	@is_debug : Bool;
	
	enum Type {
		ARRAY
	}

	consts Limit {
		DEPTH_MAX := 256
	}

	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			parser := StreamParser->New(System.IO.Filesystem.FileReader->ReadFile(args[0]));
			parser->ParseNext(0);
			parser->ParseNext(0);
		}
	}

	New(stream : String) {
		@is_debug := true;

		@elem_stack := StreamParser->Type->New[Limit->DEPTH_MAX];
		@doc_stream := stream->ToCharArray();
	}

	method : MatchChar(char : Char) ~ Bool {
		return GetChar() = char;
	}

	method : GetChar() ~ Char {
		if(@doc_stream_pos < @doc_stream->Size()) {
			return @doc_stream[@doc_stream_pos];
		};

		return '\0';
	}

	method : NextChar() ~ Nil {
		@doc_stream_pos += 1;
	}

	
	method : Whitespace() ~ Nil {
		char := GetChar();
		while(char = ' ' | char = '\t' | char = '\r' | char = '\n') {
			NextChar();
			char := GetChar();
		}
	}

	method : Print(msg : String, level : Int) ~ Nil {
		each(i : level) {
			"..|"->Print();
		};
		msg->PrintLine();
	}
	
	method : ParseNext(level : Int) ~ Nil {
		Whitespace();

		# number
		char := GetChar();
		if(char->IsDigit()) {
			start := @doc_stream_pos;
			char := GetChar();
			while(char->IsDigit() | char = '.') {
				NextChar();
				char := GetChar();
			};
			value := String->New(@doc_stream, start, @doc_stream_pos - start);
Print("Number: level={$level}: value={$value}", level);
		}
		# array
		else if(char = '[' | char = ',') {
Print("Array: level={$level}", level);
			NextChar();

			if(GetChar() <> ']') {
				ParseNext(level + 1);

				Whitespace();
				if(GetChar() = ',') {
					NextChar();
				};
			};
			NextChar();	
		}
		else {
			"*** Error: '{$char}' ***"->ErrorLine();
		}
	}
}