use Collection;

class Repl {
	function : Main(args : String[]) ~ Nil {
		# test: performance contrib to playing
		p := Node->New(20.0, 10.0); # 50/50 dateset for playing, what is the predictor?
		p->AddChild(14.0, 8.0); # left
		p->AddChild(6.0, 2.0); # right
		gi := p->GiniImpurity();
		"perf={$gi}"->PrintLine();
		
		# test: class contrib to playing
		p := Node->New(20.0, 10.0); # 50/50 dateset for playing, what is the predictor?
		p->AddChild(10.0, 8.0); # left
		p->AddChild(10.0, 2.0); # right
		gi := p->GiniImpurity();
		"class={$gi}"->PrintLine();
	}
}

class Node {
	@goal : Float;
	@achieved : Float;
	@parent : Node;
	@children : Vector<Node>;

	New(g : Float, a : Float) {
		@goal := g;
		@achieved := a;
		@children := Vector->New()<Node>;
	}

	New : private (g : Float, a : Float, p : Node) {
		@goal := g;
		@achieved := a;
		@parent := p;
		@children := Vector->New()<Node>;
	}

	method : public : GetGoal() ~ Float {
		return @goal;
	}

	method : public : GetAchieved() ~ Float {
		return @achieved;
	}

	method : public : GiniImpurity() ~ Float {	
		pxy := @goal;

		gi := 0.0;
		each(child := @children) {
			gi += (child->GetGoal() / pxy) * child->Gini();
		};

		return gi;
	}

	method : Gini() ~ Float {
		l := @achieved/@goal; r := 1-l;
		return 1 - (l*l + r*r);
	}

	method : public : AddChild(x : Float, y : Float) ~ Node {
		n := Node->New(x, y, @self);
		@children->AddBack(n);
		return n;
	}

	method : public : GetChildren() ~ Vector<Node> {
		return @children;
	}

	method : public : IsLeaf() ~ Bool {
		return @children->IsEmpty();
	}
}