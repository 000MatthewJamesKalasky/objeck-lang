class KMeans {
	function : Main(args : String[]) ~ Nil {
		data := LoadData();
		k := 2;

		dims := data->Size();
		data_rows := dims[0]; 

		if(dims[1] = 2) {
			cols := dims[1];
"data_rows={$data_rows}, cols={$cols}\n---"->PrintLine();

			centers := Float->New[k->As(Int), cols];
			each(a : k) {
				each(b : cols) {
					data_sum := 0.0;
					each(c : data_rows) {
						data_sum += data[c, b];
					};
					data_sum /= data_rows;

					point : Float;
					if(a % 2 = 0) {
						point := data_sum - (data_sum / k->As(Float));
					}
					else {
						point := data_sum + (data_sum / k->As(Float));
					};

					centers[a, b] := point;
				};
			};

# centers->ToString()->PrintLine();
# "---"->PrintLine();

			dims := centers->Size();
			centers_rows := dims[0]; 

			groups := Collection.Vector->New[k]<Collection.Pair<FloatRef,FloatRef>>;
			each(a : groups) {
				groups[a] := Collection.Vector->New()<Collection.Pair<FloatRef,FloatRef>>;
			}

			temp := Float->New[k];
			each(a : data_rows) {
				x1 := data[a, 0];
				y1 := data[a, 1];

				each(b : centers_rows) {
					x2 := centers[b, 0];
					y2 := centers[b, 1];

					dist := Distance(x1, x2, y1, y2);
# "{$k} :[{$x1}, {$y1}], {$x2}, {$y2}: {$dist}"->PrintLine();
					temp[b] := dist;
				};

				index := 0;
				value := Float->Inf();
				each(b : temp) {
					if(temp[b] < value) {
						value := temp[b];
						index := b;
					}
				};
# "{$index}: {$value}"->PrintLine();
								
				group := groups[index];
				group->AddBack(Collection.Pair->New(x1, y1)<FloatRef, FloatRef>);
			};

			DoStuff(groups);
		};
	}

	function : DoStuff(groups : Collection.Vector[]<Collection.Pair<FloatRef,FloatRef>>) ~ Nil {
		# TODO: recenter
		each(a : groups) {
			group := groups[a];

			x_total := 0.0;
			y_total := 0.0;
			each(pair := group) {
				x_total += pair->GetFirst();
				y_total += pair->GetSecond();
			};
			x_total /= group->Size();
			y_total /= group->Size();

			"{$x_total}|{$y_total}"->PrintLine();
			"---"->PrintLine();
		};
	}

	function : Distance(x1 : Float, x2 : Float, y1  : Float, y2 : Float) ~ Float {
		return Float->Sqrt(Float->Pow(x2 - x1, 2.0) + Float->Pow(y2 - y1, 2.0) * 1.0);
	}

	function : LoadData() ~ Float[,] {
		return [
			[0.6, 5.0]
			[1.2, 4.8]
			[0.6, 4.2]
			[1.5, 3.5]
			[0.4, 3.0]
			[1.0, 2.0]
			[3.0, 5.0]
			[3.3, 4.0]
			[3.0, 3.0]
			[3.9, 2.2]
			[3.0, 5.0]
			[3.5, 2.0]];
	}
}