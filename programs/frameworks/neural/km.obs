use Collection;

class KMeans {
	function : Main(args : String[]) ~ Nil {
		points := LoadData();
		centroids := LoadCentroids();
		k := centroids->Size();

		# test centroids size eqals k

		buckets := Vector->New[k]<Point>;
		each(i : k) {
			buckets[i] := Vector->New()<Point>;
		};
		results := DistanceResult->New[k];

		each(c : 3) {
			each(point := points) {
				each(i : centroids) {
					centroid := centroids->Get(i);
					distance := Distance(centroid, point);
					results[i] := DistanceResult->New(point, distance);
"{$point} | {$centroid} => {$distance}"->PrintLine();
				};

				index := -1;
				min := Float->Inf();
				each(i : results) {
					result := results[i];
					if(result->GetDistance() < min) {
						min := result->GetDistance();
						index := i;
					}
				};

				result := results[index];
				bucket := buckets[index];
				bucket->AddBack(result->GetPoint());

"---\n{$index}: {$result}\n"->PrintLine();
			};

	
			
			centroids->Empty();
			each(i : k) {
				bucket := buckets[i];

				x_update := y_update := 0.0;
				each(item := bucket) {
					x_update += item->GetX();
					y_update += item->GetY();
				};
				x_update /= bucket->Size()->As(Float);
				y_update /= bucket->Size()->As(Float);

				centroids->AddBack(Point->New(x_update, y_update))
# "{$i}: {$x_update}, {$y_update}"->PrintLine();
				bucket->Empty();
			};

			"==="->PrintLine();
			centroids->ToString()->PrintLine();
			"==="->PrintLine();
		};
	}

	function : native : Distance(a : Point, b : Point) ~ Float {
		x1 := a->GetX(); y1 := a->GetY();
		x2 := b->GetX(); y2 := b->GetY();

		return Float->Sqrt(Float->Pow(x2 - x1, 2.0) + Float->Pow(y2 - y1, 2.0));
	}

	function : LoadCentroids() ~ Vector<Point> {
		centroids := Vector->New()<Point>;

		centroids->AddBack(Point->New(3, 4));
		centroids->AddBack(Point->New(7, 8));
#		centroids->AddBack(Point->New(5, 5));

		return centroids;
	}

	function : LoadData() ~ Vector<Point> {
		points := Vector->New()<Point>;

		points->AddBack(Point->New(9.78, 7.86));
		points->AddBack(Point->New(0.81, 0.77));
		points->AddBack(Point->New(8.82, 5.48));
		points->AddBack(Point->New(1.80, 0.43));
		points->AddBack(Point->New(6.16, 6.60));
		points->AddBack(Point->New(6.51, 8.72));
		points->AddBack(Point->New(1.10, 2.56));
		points->AddBack(Point->New(7.89, 4.49));
		points->AddBack(Point->New(3.33, 2.89));
		points->AddBack(Point->New(0.74, 3.99));
		points->AddBack(Point->New(3.15, 1.70));
		points->AddBack(Point->New(0.55, 6.27));

		return points;
	}
}

class DistanceResult implements Stringify {
	@point : Point;
	@distance : Float;

	New(point : Point, distance : Float) {
		@point := point;
		@distance := distance;
	}

	method : public : GetPoint() ~ Point {
		return @point;
	}

	method : public : GetDistance() ~ Float {
		return @distance;
	}

	method : public : ToString() ~ String {
		return "{$@point}: {$@distance}";
	}
}

class Point implements Stringify {
	@x : Float;
	@y : Float;

	New(x : Float, y : Float) {
		@x := x;
		@y := y;
	}

	method : public : GetX() ~ Float {
		return @x;
	}

	method : public : GetY() ~ Float {
		return @y;
	}

	method : public : ToString() ~ String {
		return "{{$@x}, {$@y}}";
	}
}