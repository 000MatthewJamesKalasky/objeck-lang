use Collection;

class KMeans {
	@debug : static : Bool;

	function : Main(args : String[]) ~ Nil {
		@debug := true;

		points := LoadData();
		centroids := InitializeCentroids();
		results := CalculateMean(points, centroids);

		"\n======"->PrintLine();
		each(i : results) {
			result := results[i];
			"G{$i}->{$result}"->PrintLine();
		};
	}

	function : CalculateMean(points : Vector<Point>, centroids : Vector<Point>) ~ Vector[]<Point> {
		k := centroids->Size();

		buckets := Vector->New[k]<Point>;
		each(i : k) {
			buckets[i] := Vector->New()<Point>;
		};
		results := Distance->New[k];

		last_centroids := Point->New[k];
		each(i : last_centroids) {
			last_centroids[i] := Point->New();
		};

		converged := false;
		do {
			if(@debug) {
				"\n=>{$centroids}\n------"->PrintLine();
			};

			each(point := points) {
				each(i : centroids) {
					centroid := centroids->Get(i);
					distance := GetDistance(centroid, point);
					result := Distance->New(point, distance);

					if(@debug) {
						"{$centroid}: {$result}"->PrintLine();
					};
					results[i] := result;
				};

				if(@debug) {
					"------"->PrintLine();
				};

				pt_index := -1;
				min_dist := Float->Inf();
				each(i : results) {
					result := results[i];
					if(result->GetDistance() < min_dist) {
						min_dist := result->GetDistance();
						pt_index := i;
					}
				};

				result := results[pt_index];
				bucket := buckets[pt_index];
				bucket->AddBack(result->GetPoint());
			};

			each(i : k) {
				last_centroids[i] := centroids->Get(i);
			};
			
			centroids->Empty();
			each(i : k) {
				bucket := buckets[i];

				x_update := y_update := 0.0;
				each(item := bucket) {
					x_update += item->GetX();
					y_update += item->GetY();
				};
				x_update /= bucket->Size()->As(Float);
				y_update /= bucket->Size()->As(Float);

				if(@debug) {
					"C{$i}->{$x_update}, {$y_update}"->PrintLine();
				};

				centroids->AddBack(Point->New(x_update, y_update));
			};

			converged := HasConverged(centroids, last_centroids);
			if(<>converged) {
				each(i : k) {
					buckets[i]->Empty();
				};
			}
		}
		while(<>converged);

		return buckets;
	}

	function : native : HasConverged(current : Vector<Point>, last : Point[]) ~ Bool {
		each(i : current) {
			left := current->Get(i);
			right := last[i];

			if(<>left->Equals(right)) {
				return false;
			};
		}

		return true;
	}

	function : native : GetDistance(a : Point, b : Point) ~ Float {
		x1 := a->GetX(); y1 := a->GetY();
		x2 := b->GetX(); y2 := b->GetY();

		return Float->Sqrt(Float->Pow(x2 - x1, 2.0) + Float->Pow(y2 - y1, 2.0));
	}

	function : InitializeCentroids() ~ Vector<Point> {
		centroids := Vector->New()<Point>;

		centroids->AddBack(Point->New(Float->Random() * 10.0, Float->Random() * 10.0));
		centroids->AddBack(Point->New(Float->Random() * 10.0, Float->Random() * 10.0));
#		centroids->AddBack(Point->New(5, 5));

		return centroids;
	}

	function : LoadData() ~ Vector<Point> {
		points := Vector->New()<Point>;

		points->AddBack(Point->New(9.78, 7.86));
		points->AddBack(Point->New(0.81, 0.77));
		points->AddBack(Point->New(8.82, 5.48));
		points->AddBack(Point->New(1.80, 0.43));
		points->AddBack(Point->New(6.16, 6.60));
		points->AddBack(Point->New(6.51, 8.72));
		points->AddBack(Point->New(1.10, 2.56));
		points->AddBack(Point->New(7.89, 4.49));
		points->AddBack(Point->New(3.33, 2.89));
		points->AddBack(Point->New(0.74, 3.99));
		points->AddBack(Point->New(3.15, 1.70));
		points->AddBack(Point->New(0.55, 6.27));

		return points;
	}
}

class : private : Distance implements Stringify {
	@point : Point;
	@distance : Float;

	New(point : Point, distance : Float) {
		@point := point;
		@distance := distance;
	}

	method : public : GetPoint() ~ Point {
		return @point;
	}

	method : public : GetDistance() ~ Float {
		return @distance;
	}

	method : public : ToString() ~ String {
		return "{$@point}: {$@distance}";
	}
}

class : private : Point implements Stringify {
	@x : Float;
	@y : Float;

	New() {
		@x := 0.0;
		@y := 0.0;
	}

	New(x : Float, y : Float) {
		@x := x;
		@y := y;
	}

	method : public : GetX() ~ Float {
		return @x;
	}

	method : public : GetY() ~ Float {
		return @y;
	}

	method : public : Equals(point : Point) ~ Bool {
		return point->GetX() = @x & point->GetY() = @y;
	}

	method : public : ToString() ~ String {
		return "{{$@x}, {$@y}}";
	}
}