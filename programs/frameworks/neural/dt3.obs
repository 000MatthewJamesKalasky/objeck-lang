use Collection;
use Data.CSV;

class DecisionTree {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() > 0) {
			matrix := ToMatrix(args[0]);
			matrix->ToString()->PrintLine();

			Test(1,2,matrix)->PrintLine();
			Test(0,2,matrix)->PrintLine();
		};
	}

	function : Test(test : Int, target : Int, matrix : Float[,]) ~ Float {
		wgi := 0.0;
		dims := matrix->Size();
		size := dims[0]->As(Float);

		# --- Left ---
		goal := Matches(test, matrix);
		acheived := Acheived(test, target, matrix);
		reached := acheived / goal;
		not_reached := (goal - acheived) / goal;
		left_gi := 1 - (reached*reached + not_reached*not_reached);
# "Left:\tgoal={$goal}\tacheived={$acheived}\tgi={$left_gi}"->PrintLine();
		wgi += goal / size * left_gi;

		# --- Right ---
		goal := Mismatch(test, matrix);
		acheived := Unacheived(test, target, matrix);
		reached := acheived / goal;
		not_reached := (goal - acheived) / goal;
		right_gi := 1 - (reached*reached + not_reached*not_reached);
# "right:\tgoal={$goal}\tacheived={$acheived}\tgi={$right_gi}"->PrintLine();
		wgi += goal / size * right_gi;

		return wgi;
	}

	function : Split(index : Int, matrix : Float[,]) ~ Float[,] {
		return Nil;
	}

	function : Matches(index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(index > -1 & index < rows) {
			each(row : rows) {
				if(matrix[row, index] <> 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : Acheived(test_index : Int, goal_index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(test_index > -1 & test_index < rows & goal_index > -1 & goal_index < rows) {
			each(row : rows) {
				if(matrix[row, test_index] <> 0.0 & matrix[row, goal_index] <> 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : Unacheived(test_index : Int, goal_index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(test_index > -1 & test_index < rows & goal_index > -1 & goal_index < rows) {
			each(row : rows) {
				if(matrix[row, test_index] = 0.0 & matrix[row, goal_index] <> 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : Mismatch(index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(index > -1 & index < rows) {
			each(row : rows) {
				if(matrix[row, index] = 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : ToMatrix(filename : String) ~ Float[,] {
		table := CsvTable->New(System.IO.Filesystem.FileReader->ReadFile(filename));
		if(table->IsParsed()) {
			row_size := table->Size();
			if(row_size->Size() > 1) {
				column := table->Get(1);
				column_size := column->Size();

				matrix := Float->New[row_size - 1, column_size];
				for(i := 1; i < row_size; i += 1;) {
					each(j : column_size) {
						value := table->Get(i)->Get(j)->ToLower();
						if(value->Equals("0") | value->StartsWith("0.0")  | value->Equals("false")) {
							matrix[i - 1, j] := 0;
						}
						else {
							matrix[i - 1, j] := 1;	
						};
					};
				};

				return matrix;
			};
		};

		return Nil;
	}
}
