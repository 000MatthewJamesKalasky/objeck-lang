use Collection;
use Data.CSV;

class DecisionTree {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() > 0) {
			matrix := ToMatrix(args[0]);
			dims := matrix->Size();
			rows := dims[0];

			root := node := Node->New(2, rows, Matches(2, matrix));
			done := false;

			while(<>done) {
				# left
				left := WeightedGini(0,2,matrix);
				left_wgi := left->GetWeightedGini();
				
				# right
				right := WeightedGini(1,2,matrix);
				right_wgi := right->GetWeightedGini();

				if(left_wgi <> 0.0 & left_wgi < right_wgi) {
					matrix := Split(0, matrix);
					node->SetLeft(Node->New(left_wgi, left->GetLeft(), left->GetLeft()));
				}
				else if(right_wgi <> 0.0) {
					matrix := Split(1, matrix);
					node->SetRight(Node->New(right_wgi, right->GetLeft(), right->GetLeft()));
				}
				else {
					done := true;
				};
			};

			root->ToString()->PrintLine();
		};
	}

	function : Split(index : Int, in : Float[,]) ~ Float[,] {
		split_len := Matches(index, in)->ToInt();
		if(split_len > 0) {
			dims := in->Size();
			rows := dims[0];
			cols := dims[1];

			out := Float->New[split_len, cols];
			count := 0;
			if(index > -1 & index < rows) {
				each(row : rows) {
					if(in[row, index] <> 0.0) {
						each(k : cols) {
							out[count, k] := in[row, k];
						};
						count += 1;
					};
				};
			};

			return out;
		};

		return Nil;
	}

	function : WeightedGini(test : Int, target : Int, matrix : Float[,]) ~ Result {
		wgi := 0.0;
		dims := matrix->Size();
		size := dims[0]->As(Float);

		# --- Left ---
		left, right : Node;
		goal := Matches(test, matrix);
		if(goal > 0.0) {
			acheived := Acheived(test, target, matrix);
			reached := acheived / goal;
			not_reached := (goal - acheived) / goal;
			left_gi := 1 - (reached*reached + not_reached*not_reached);
			left := Node->New(test, goal, acheived, left_gi);
			wgi += goal / size * left_gi;
		}
		else {
			return Result->New(Nil, Nil, 0.0);
		};

		# --- Right ---
		goal := Mismatch(test, matrix);
		if(goal > 0.0) {
			acheived := Unacheived(test, target, matrix);
			reached := acheived / goal;
			not_reached := (goal - acheived) / goal;
			right_gi := 1 - (reached*reached + not_reached*not_reached);
			right := Node->New(test, goal, acheived, right_gi);
			wgi += goal / size * right_gi;
		}
		else {
			return Result->New(Nil, Nil, 0.0);
		};

		return Result->New(left, right, wgi);
	}

	function : Matches(index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(index > -1 & index < rows) {
			each(row : rows) {
				if(matrix[row, index] <> 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : Acheived(test_index : Int, goal_index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(test_index > -1 & test_index < rows & goal_index > -1 & goal_index < rows) {
			each(row : rows) {
				if(matrix[row, test_index] <> 0.0 & matrix[row, goal_index] <> 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : Unacheived(test_index : Int, goal_index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(test_index > -1 & test_index < rows & goal_index > -1 & goal_index < rows) {
			each(row : rows) {
				if(matrix[row, test_index] = 0.0 & matrix[row, goal_index] <> 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : Mismatch(index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(index > -1 & index < rows) {
			each(row : rows) {
				if(matrix[row, index] = 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : ToMatrix(filename : String) ~ Float[,] {
		table := CsvTable->New(System.IO.Filesystem.FileReader->ReadFile(filename));
		if(table->IsParsed()) {
			row_size := table->Size();
			if(row_size->Size() > 1) {
				column := table->Get(1);
				column_size := column->Size();

				matrix := Float->New[row_size - 1, column_size];
				for(i := 1; i < row_size; i += 1;) {
					each(j : column_size) {
						value := table->Get(i)->Get(j)->ToLower();
						if(value->Equals("0") | value->StartsWith("0.0")  | value->Equals("false")) {
							matrix[i - 1, j] := 0;
						}
						else {
							matrix[i - 1, j] := 1;	
						};
					};
				};

				return matrix;
			};
		};

		return Nil;
	}
}

class Result {
	@left : Node;
	@right : Node;
	@weighted_gini : Float;

	New(left : Node, right : Node, weighted_gini : Float) {
		@weighted_gini := weighted_gini;
		@left := left;
		@right := right;
	}

	method : public : GetLeft() ~ Node {
		return @left;
	}

	method : public : GetRight() ~ Node {
		return @right;
	}

	method : public : GetWeightedGini() ~ Float {
		return @weighted_gini
	}
}

class Node {
	@uid : static : Int;
	@id : Int;
	@test : Int;
	@goal : Float;
	@acheived : Float;
	@gini : Float;
	@left : Node;
	@right : Node;

	New(gini : Float, left : Node, right : Node) {
		@gini : Float;
		@left := left;
		@right := right;

		@id := @uid;
		@uid += 1;
	}

	New(test : Int, goal : Float, acheived : Float, gini : Float) {
		@test := test;
		@goal := goal;
		@acheived := acheived;
		@gini := gini;

		@id := @uid;
		@uid += 1;
	}

	New(test : Int, goal : Float, acheived : Float) {
		@test := test;
		@goal := goal;
		@acheived := acheived;
		@gini := 0.0;

		@id := @uid;
		@uid += 1;
	}

	method : public : GetGoal() ~ Float {
		return @goal;
	}

	method : public : GetAcheived() ~ Float {
		return @acheived;
	}

	method : public : GetGini() ~ Float {
		return @gini;
	}

	method : public : SetGini(gini : Float) ~ Nil {
		@gini := gini;
	}

	method : public : GetLeft() ~ Node {
		return @left;
	}

	method : public : SetLeft(left : Node) ~ Nil {
		@left := left;
	}

	method : public : GetRight() ~ Node {
		return @right;
	}

	method : public : SetRight(right : Node) ~ Nil {
		@right := right;
	}

	method : public : ToString() ~ String {
		buffer := "";
		ToString(buffer);
		return buffer;
	}

	method : public : ToString(buffer : String) ~ Nil {
		buffer += "id={$@id},";
		buffer += "test={$@test},";
		buffer += "goal={$@goal},";
		buffer += "acheived={$@acheived},";
		buffer += "gini={$@gini}\n";

		if(@left <> Nil) {
			@left->ToString(buffer);
		};

		if(@right <> Nil) {
			@right->ToString(buffer);
		};
	}
}