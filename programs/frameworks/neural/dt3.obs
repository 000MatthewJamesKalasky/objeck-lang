use Collection;
use Data.CSV;

class DecisionTree {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() > 0) {
			matrix := ToMatrix(args[0]);
			dims := matrix->Size();
			rows := dims[0];

			root := Node->New(rows, Matches(2, matrix));
root->ToString()->PrintLine();

			done := false;
			while(<>done) {
				left_wgi := WeightedGini(0,2,matrix); # left
				right_wgi := WeightedGini(1,2,matrix); # right
# "left_wgi={$left_wgi},right_wgi={$right_wgi}"->PrintLine();

				if(left_wgi <> 0.0 & right_wgi <> 0.0) {
					matrix := Split(0, matrix);
				}
				else {
					done := true;
				};
			}
		};
	}

	function : Split(index : Int, in : Float[,]) ~ Float[,] {
		split_len := Matches(index, in)->ToInt();
		if(split_len > 0) {
			dims := in->Size();
			rows := dims[0];
			cols := dims[1];

			out := Float->New[split_len, cols];
			count := 0;
			if(index > -1 & index < rows) {
				each(row : rows) {
					if(in[row, index] <> 0.0) {
						each(k : cols) {
							out[count, k] := in[row, k];
						};
						count += 1;
					};
				};
			};

			return out;
		};

		return Nil;
	}

	function : WeightedGini(test : Int, target : Int, matrix : Float[,]) ~ Float {
		wgi := 0.0;
		dims := matrix->Size();
		size := dims[0]->As(Float);

		# --- Left ---
		goal := Matches(test, matrix);
		if(goal > 0.0) {
			acheived := Acheived(test, target, matrix);
			reached := acheived / goal;
			not_reached := (goal - acheived) / goal;
			left_gi := 1 - (reached*reached + not_reached*not_reached);
			left := Node->New(goal, acheived, left_gi);
left->ToString()->PrintLine();
			wgi += goal / size * left_gi;
		}
		else {
			return 0.0;
		};

		# --- Right ---
		goal := Mismatch(test, matrix);
		if(goal > 0.0) {
			acheived := Unacheived(test, target, matrix);
			reached := acheived / goal;
			not_reached := (goal - acheived) / goal;
			right_gi := 1 - (reached*reached + not_reached*not_reached);
			right := Node->New(goal, acheived, right_gi);
right->ToString()->PrintLine();
			wgi += goal / size * right_gi;
		}
		else {
			return 0.0;
		};

		return wgi;
	}

	function : Matches(index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(index > -1 & index < rows) {
			each(row : rows) {
				if(matrix[row, index] <> 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : Acheived(test_index : Int, goal_index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(test_index > -1 & test_index < rows & goal_index > -1 & goal_index < rows) {
			each(row : rows) {
				if(matrix[row, test_index] <> 0.0 & matrix[row, goal_index] <> 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : Unacheived(test_index : Int, goal_index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(test_index > -1 & test_index < rows & goal_index > -1 & goal_index < rows) {
			each(row : rows) {
				if(matrix[row, test_index] = 0.0 & matrix[row, goal_index] <> 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : Mismatch(index : Int, matrix : Float[,]) ~ Float {
		dims := matrix->Size();
		rows := dims[0];

		count := 0;
		if(index > -1 & index < rows) {
			each(row : rows) {
				if(matrix[row, index] = 0.0) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : ToMatrix(filename : String) ~ Float[,] {
		table := CsvTable->New(System.IO.Filesystem.FileReader->ReadFile(filename));
		if(table->IsParsed()) {
			row_size := table->Size();
			if(row_size->Size() > 1) {
				column := table->Get(1);
				column_size := column->Size();

				matrix := Float->New[row_size - 1, column_size];
				for(i := 1; i < row_size; i += 1;) {
					each(j : column_size) {
						value := table->Get(i)->Get(j)->ToLower();
						if(value->Equals("0") | value->StartsWith("0.0")  | value->Equals("false")) {
							matrix[i - 1, j] := 0;
						}
						else {
							matrix[i - 1, j] := 1;	
						};
					};
				};

				return matrix;
			};
		};

		return Nil;
	}
}

class Node {
	@goal : Float;
	@acheived : Float;
	@gini : Float;

	New(goal : Float, acheived : Float, gini : Float) {
		@goal := goal;
		@acheived := acheived;
		@gini := gini;
	}

	New(goal : Float, acheived : Float) {
		@goal := goal;
		@acheived := acheived;
		@gini := 0.0;
	}

	method : public : GetGoal() ~ Float {
		return @goal;
	}

	method : public : GetAcheived() ~ Float {
		return @acheived;
	}

	method : public : GetGini() ~ Float {
		return @gini;
	}

	method : public : ToString() ~ String {
		buffer := "";

		buffer += "goal={$@goal},";
		buffer += "acheived={$@acheived},";
		buffer += "gini={$@gini}";	
			
		return buffer;
	}
}