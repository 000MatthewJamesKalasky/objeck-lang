use Collection;

class DecisionTree {
   function : Main(args : String[]) ~ Nil {
      #---
      p := Node->New(16, 14);
      p->AddChild(12, 1);
      p->AddChild(4, 13);
      Gain(p)->PrintLine();
      #---
      p := Node->New(16, 14);
      p->AddChild(7, 1);
      p->AddChild(4, 6);
      p->AddChild(5, 7);
      Gain(p)->PrintLine();
   }

   function : native : Gain(parent : Node) ~ Float {
      px := parent->GetX(); 
      py := parent->GetY();
      pxy := px + py;
      children := parent->GetChildren();

      e : Float;
      values := Float->New[2, children->Size()];
      each(i : children) {
         child := children->Get(i);
         x := child->GetX();
         y := child->GetY();

         values[i, 0] := Entropy(x, y);
         values[i, 1] := (x + y) / pxy;
         
         e += values[i, 0] * values[i, 1];
      };

      return Entropy(px, py) - e;
   }

   function : Entropy(x : Float, y : Float) ~ Float {
      xy := x + y;
      return -1.0 * (Float->Log2(x / xy) * (x / xy)) + -1.0 * (Float->Log2(y / xy) * (y / xy));
   }
}

class Node {
   @x : Float;
   @y : Float;
   @children : Vector<Node>;

   New(x : Float, y : Float) {
      @x := x;
      @y := y;

      @children := Vector->New()<Node>;
   }

   method : public : GetX() ~ Float {
      return @x;
   }

   method : public : GetY() ~ Float {
      return @y;
   }

   method : public : AddChild(x : Float, y : Float) ~ Nil {
      @children->AddBack(Node->New(x, y));
   }

   method : public : GetChildren() ~ Vector<Node> {
      return @children;
   }
}