use Collection;

class DecisionTree {
   function : Main(args : String[]) ~ Nil {
      #---
      p := DecisionElem->New(16, 14);
      p->AddChild(12, 1);
      p->AddChild(4, 13);
      Gain(p)->PrintLine();

      #---
      p := DecisionElem->New(16, 14);
      p->AddChild(7, 1);
      p->AddChild(4, 6);
      p->AddChild(5, 7);
      Gain(p)->PrintLine();
   }

   function : native : Gain(parent : DecisionElem) ~ Float {
      px := parent->GetX(); 
      py := parent->GetY();
      pxy := px + py;
      children := parent->GetChildren();

      e : Float;
      each(i : children) {
         child := children->Get(i);
         x := child->GetX();
         y := child->GetY();
         e += Entropy(x, y) * (x + y) / pxy;
      };

      return Entropy(px, py) - e;
   }

   function : Entropy(x : Float, y : Float) ~ Float {
      xy := x + y;
      return -1.0 * (Float->Log2(x / xy) * (x / xy)) + -1.0 * (Float->Log2(y / xy) * (y / xy));
   }
}

class DecisionElem {
   @x : Float;
   @y : Float;
   @children : Vector<DecisionElem>;

   New(x : Float, y : Float) {
      @x := x;
      @y := y;

      @children := Vector->New()<DecisionElem>;
   }

   method : public : GetX() ~ Float {
      return @x;
   }

   method : public : GetY() ~ Float {
      return @y;
   }

   method : public : AddChild(x : Float, y : Float) ~ Nil {
      @children->AddBack(DecisionElem->New(x, y));
   }

   method : public : GetChildren() ~ Vector<DecisionElem> {
      return @children;
   }
}