class MultiRegression {
	# TODO: save calculated vectors
	function : Main(args : String[]) ~ Nil {
		data := LoadData();
		dims := data->Size();
		rows := dims[0]->As(Float);
		cols := dims[1];

		if(cols > 1) {
			"=== 0 ==="->PrintLine();
			data->ToString()->PrintLine();

			data_sums := VectorSums(data);
			data_sums->PrintLine();
			"---"->PrintLine();

			"=== 1 ==="->PrintLine();
			data_means := VectorMeans(data);
			data_means->PrintLine();

			"=== 2 ==="->PrintLine();
			x_squares := Float->New[cols - 1];
			for(i := 1; i < cols; i += 1;) {
				term_vector := VectorPower(data, i, 2.);
				term := VectorSum(term_vector);
				coff := term - Float->Pow(data_sums[i], 2.) / rows;			
# term->PrintLine();
# coff->PrintLine();
				x_squares[i - 1] := coff;
			};
			x_squares->ToString()->PrintLine();

			y_index := 0;
			xy_products := Float->New[cols - 1];
			for(i := 1; i < cols; i += 1;) {
				termvector := ProductSum(data, 0, i);
				termsum := VectorSum(termvector);
				coff := termsum - data_sums[y_index] * data_sums[i] / rows;
# termsum->PrintLine();
# coff->PrintLine();
				xy_products[i - 1] := coff;
			};
			xy_products->ToString()->PrintLine();

			# TODO: pick indexes, consider a range
			x_products := ProductSum(data, 1, 2);
			x_product_sum := VectorSum(x_products);

			coff_sum := data_sums[1];
			for(j := 2; j < data_sums->Size(); j += 1;) {
				coff_sum *= data_sums[j];
			};
			x_product := x_product_sum - coff_sum / rows;
# x_product_sum->PrintLine();
x_product->PrintLine();

			term_sum := x_squares[0];
			for(j := 1; j < x_squares->Size(); j += 1;) {
				term_sum *= x_squares[j];
			};
			x_product *= x_product;

			"=== 3 ==="->PrintLine();
			d := term_sum - x_product;
d->PrintLine();
		}
	}

	function : ProductSum(in : Float[,], col_a : Int, col_b : Int) ~ Float[] {
		dims := in->Size();
		rows := dims[0];
		cols := dims[1];

		if(col_a < cols & col_b < cols) {
			out := Float->New[rows];

			each(r : rows) {		
				out[r] := in[r, col_a] * in[r, col_b]
			};

			return out;
		};

		return Nil;
	}

	function : VectorPower(in : Float[,], col : Int, pow : Float) ~ Float[] {
		dims := in->Size();
		rows := dims[0];
		cols := dims[1];

		if(col < cols) {
			out := Float->New[rows];

			each(r : rows) {		
				out[r] := Float->Pow(in[r, col], pow);
			};

			return out;
		};

		return Nil;
	}

	function : VectorMeans(in : Float[,]) ~ Float[] {
		dims := in->Size();
		rows := dims[0];
		cols := dims[1];

		out := Float->New[cols];
		
		each(c : cols) {
			sum := 0.;

			each(r : rows) {
				sum += in[r, c];
			};

			out[c] := sum / rows;
		};

		return out;
	}

	function : VectorSum(in : Float[]) ~ Float {
		rows := in->Size();
		
		sum := 0.;

		each(r : rows) {
			sum += in[r];
		};

		return sum;
	}

	function : VectorSums(in : Float[,]) ~ Float[] {
		dims := in->Size();
		rows := dims[0];
		cols := dims[1];

		out := Float->New[cols];
		
		each(c : cols) {
			sum := 0.;

			each(r : rows) {
				sum += in[r, c];
			};

			out[c] := sum;
		};

		return out;
	}

	function : LoadData() ~ Float[,] {
		return [
			[140., 60., 22.]
			[155., 62., 25.]
			[159., 67., 24.]
			[179., 70., 20.]
			[192., 71., 15.]
			[200., 72., 14.]
			[212., 75., 14.]
			[215., 78., 11.]];
	}
}