use Collection.Generic;

class PathFinder {
	@grid : Char[,];
	@not_found : Point;
	@path : Vector<Point>;

	New() {
		@grid := Char->New[4,4];
		@path := Vector->New()<Point>;
		@not_found := Point->New(-1, -1);
	}
	
	function : Main(args : String[]) ~ Nil {
		pf := PathFinder->New();
		pf->Run();
	}

	method : Run() ~ Nil {
		#start and end
		start := Point->New(0, 1);
		@grid[start->GetX(),start->GetY()] := 'S';
		
		end := Point->New(3, 2);
		@grid[end->GetX(),end->GetY()] := 'E';

		Distance(start, end);

		@grid[1,0] := 'X';
#		@grid[1,1] := 'X';
		@grid[1,2] := 'X';
		@grid[1,3] := 'X';

#~
		# obstacles
		@grid[2,0] := 'X';
		@grid[1,1] := 'X';
		@grid[1,2] := 'X';
		@grid[3,3] := 'X';
~#

		# show initial grid
		PrintGrid();
		start->ToString()->PrintLine();

		@path->AddBack(start);
		pt := Find(start, end);
		while(pt <> Nil & pt->GetX() <> -1) {
pt->ToString()->PrintLine();
			@path->AddBack(pt);
			pt := Find(pt, end);
		};
		
		UpdatePath(@path);

		end->ToString()->PrintLine();

		PrintGrid();

		if(pt <> Nil & pt->GetX() < 0) {
			"\n*** No Solution ***"->PrintLine();
		};
	}

	method : Find(pos : Point, end : Point) ~ Point {
		x := pos->GetX();
		y := pos->GetY();

		dims := @grid->Size();
		x_max := dims[0];
		y_max := dims[1];

		dir : Point;
		if(x > -1 & y > -1 & x < x_max & y < y_max) {
# "pos: {$x}, {$y}"->PrintLine();

			# TODO: obstacles

			# check left/right
			can_move_left := CheckMove(x - 1, y); # x - 1 > -1 & @grid[x - 1, y] <> 'X';
			can_move_right := CheckMove(x + 1, y); # x + 1 < x_max & @grid[x + 1, y] <> 'X';

			# check up/down
			can_move_up := CheckMove(x, y - 1); # y - 1 > -1 & @grid[x, y - 1] <> 'X';
			can_move_down := CheckMove(x, y + 1); # y + 1 < y_max & @grid[x, y + 1] <> 'X';

# "move: left={$can_move_left}, right={$can_move_right}, up={$can_move_up}, down={$can_move_down}"->PrintLine();

			# pick best move
			min_dist := (x_max * y_max)->ToFloat();
			
			if(can_move_left) {
				pt := Point->New(x - 1, y);
				test := Distance(pt, end);
# "left: {$min_dist} to {$test}"->PrintLine();
				if(test <= min_dist) {
					min_dist := test;
					dir := pt;
				};
			};

			if(can_move_right) {
				pt := Point->New(x + 1, y);
				test := Distance(pt, end);
# "right: {$min_dist} to {$test}"->PrintLine();				
				if(test <= min_dist) {
					min_dist := test;
					dir := pt;
				};
			};

			if(can_move_up) {
				pt := Point->New(x, y - 1);
				test := Distance(pt, end);
# "up: {$min_dist} to {$test}"->PrintLine();				
				if(test <= min_dist) {
					min_dist := test;
					dir := pt;
				};
			};

			if(can_move_down) {
				pt := Point->New(x, y + 1);
				test := Distance(pt, end);
# "down: {$min_dist} to {$test}"->PrintLine();				
				if(test <= min_dist) {
					min_dist := test;
					dir := pt;
				};
			};

# "-------------"->PrintLine();

			if(dir <> Nil) {
				return dir->Equals(end) ? Nil : dir;
			};

		};

		return @not_found;
	}

	method : CheckMove(x : Int, y : Int) ~ Bool {
		dims := @grid->Size();
		x_max := dims[0];
		y_max := dims[1];

		if(x < 0 | x >= x_max | y < 0 | y >= y_max) {
			return false;
		};

		if(@grid[x, y] = 'X') {
			return false;
		};


		each(i : @path) {
			pt := @path->Get(i);
			if(pt->Equals(x, y)) {
				return false;
			};
		};

		return true;
	}


	method : UpdatePath(@path : Vector<Point>) ~ Nil {
		each(i : @path) {
			pt := @path->Get(i);
			@grid[pt->GetX(), pt->GetY()] := '#';
		};
	}

	method : Distance(a : Point, b : Point) ~ Float {
		x_norm := Float->Power(a->GetX()->ToFloat() - b->GetX()->ToFloat(), 2.0);
		y_norm := Float->Power(a->GetY()->ToFloat() - b->GetY()->ToFloat(), 2.0);

		return (x_norm + y_norm)->SquareRoot();
	}

	method : PrintGrid() ~ Nil {
		"================="->PrintLine();
		dims := @grid->Size();

		for(i := 0; i < dims[1]; i +=1;) {
			for(j := 0; j < dims[0]; j +=1;) {
				value := @grid[j,i];
				if(value = '\0') {
					"-, "->Print();
				}
				else {
					"{$value}, "->Print();
				};
			};
			'\n'->Print();
		};

		"================="->PrintLine();
	}
}

class Point {
	@x : Int;
	@y : Int;

	New(x : Int, y : Int) {
		@x := x;
		@y := y;
	}

	method : public : GetX() ~ Int {
		return @x;
	}

	method : public : SetX(x : Int) ~ Nil {
		@x := x;
	}

	method : public : GetY() ~ Int {
		return @y;
	}

	method : public : SetY(y : Int) ~ Nil {
		@y := y;
	}

	method : public : Equals(x : Int, y : Int) ~ Bool {
		if(@x = x & @y = y) {
"Equals: {$x}, {$y}"->PrintLine();
			return true;
		};

		return false;
	}

	method : public : Equals(pt : Point) ~ Bool {
		if(pt->GetX() = @x & pt->GetY() = @y) {
			return true;
		};

		return false;
	}

	method : public : ToString() ~ String {
		return "[{$@x}, {$@y}]";
	}
}