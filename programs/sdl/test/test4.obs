#~
# 2D smooth scrolling
# 
# compiler: obc -src sdl_test_5.obs -lib collect.obl,sdl_game.obl,sdl2.obl -dest sdl_test_5.obe
# run: obr game2d.obe
~#

use Game.SDL2;
use Game.Framework;
use Collection.Generic;

class Demo {
	@framework : GameFramework;
	@player : Player;
	@level : Level;

	function : Main(args : String[]) ~ Nil {
		Demo->New()->Run();
	}

	New() {
		@framework := GameFramework->New(Game->SCREEN_WIDTH, Game->SCREEN_HEIGHT, "Scroll Test");
		@framework->SetClearColor(Color->New(0, 0, 255));
	}

	method : Run() ~ Nil {
		if(@framework->IsOk()) {
			@player := Player->New(@framework->AddRectangle(40, 60));
			@level := Level->New(@player, @framework);

			quit := false;
			e := @framework->GetEvent();
			while(<>quit) {
				@framework->FrameStart();
				@framework->Clear();
				
				# process input
				while(e->Poll() <> 0) {
					if(e->GetType() = EventType->SDL_QUIT) {
						quit := true;
					};

					ProcessInput(e);
				};

				# update
				@player->Update();
				@level->Update();

				shift := @level->GetShiftX();
				if(@player->GetRight() >= 500) {
					diff := @player->GetRight() - 500;
					@player->SetRight(500);
					if(shift > -1500) {
						@level->ShiftWorld(-1 * diff);
					};
				};

				if(@player->GetLeft() <= 120) {
					diff := 120 - @player->GetLeft();
					@player->SetLeft(120);
					if(shift < 0) {
						@level->ShiftWorld(diff);
					};
				};
				
				# draw
				@player->Draw();
				@level->Draw();

				# show
				@framework->Show();
				@framework->FrameEnd();
			};
		}
		else {
			"--- Error Initializing Game Environment ---"->ErrorLine();
			return;
		};

		leaving {
			@framework->Quit();
		};
	}

	method : public : ProcessInput(e : Event) ~ Nil {
		if(e->GetType() = EventType->SDL_KEYDOWN) {
			select(e->GetKey()->GetKeysym()->GetScancode()) {		
				label Scancode->SDL_SCANCODE_LEFT: {
					@player->GoWest();
				}

				label Scancode->SDL_SCANCODE_RIGHT: {
					@player->GoEast();
				}

				label Scancode->SDL_SCANCODE_UP: {
					@player->GoNorth();
				}

				label Scancode->SDL_SCANCODE_DOWN: {
					@player->GoSouth();
				}
			};
		}
		else if(e->GetType() = EventType->SDL_KEYUP) {
		   	code := e->GetKey()->GetKeysym()->GetScancode();
		   	
		   	if(code = Scancode->SDL_SCANCODE_LEFT & @player->ChangeEastWest() < 0) {
		   		@player->Stop();
			};

			if(code = Scancode->SDL_SCANCODE_RIGHT & @player->ChangeEastWest() > 0) {
				@player->Stop();
			};

			if(code = Scancode->SDL_SCANCODE_UP & @player->ChangeNorthSouth() < 0) {
		   		@player->Stop();
			};

			if(code = Scancode->SDL_SCANCODE_DOWN & @player->ChangeNorthSouth() > 0) {
				@player->Stop();
			};
		};
	}
}

class Player {
	@rect : Rectangle;
	@change_x : Float;
	@change_y : Float;
	@platforms : Vector<Barrier>;

	New(rect : Rectangle) {
		@rect := rect;
		@rect->SetFill(true);
		@rect->SetColor(Color->New(255, 0, 0));
		@rect->SetLeft(120);
	}

	method : public : GetRect() ~ Rectangle {
		return @rect; 
	}

	method : public : GetLeft() ~ Int {
		return @rect->GetLeft();
	}

	method : public : GetRight() ~ Int {
		return @rect->GetRight();
	}

	method : public : SetLeft(x : Int) ~ Nil {
		@rect->SetLeft(x);
	}

	method : public : SetRight(x2 : Int) ~ Nil {
		@rect->SetRight(x2);
	}

	method : public : SetLevel(level : Level)  ~ Nil {
		@platforms := level->GetBarriers()<Barrier>;
	}

	method : public : ChangeEastWest()  ~ Int {
		return @change_x;
	}

	method : public : ChangeNorthSouth()  ~ Int {
		return @change_y;
	}

	method : public : GoWest()  ~ Nil {
		@change_x := -6;
	}

	method : public : GoEast()  ~ Nil {
		@change_x := 6;
	}

	method : public : Stop() ~ Nil {
		@change_x := @change_y := 0;
	}

	method : public : GoNorth()  ~ Nil {
		@change_y := -6;
	}

	method : public : GoSouth()  ~ Nil {
		@change_y := 6;
	}

	method : public : native : Update()  ~ Nil {
#		Gravity();

		# Move left/right
		@rect->AddX(@change_x);

		collides := Level->Collisions(@self, @platforms);
		each(i : collides) {
			platform := collides->Get(i);
			if(@change_x > 0) {
				@rect->SetRight(platform->GetLeft());
			}
			# moving left
			else if(@change_x < 0) {
				@rect->SetLeft(platform->GetRight());
			};
		};
				
		# Move up/down
		@rect->AddY(@change_y);
		each(i : @platforms) {
			platform := @platforms->Get(i);
			if(platform->Collides(@rect)) {
				# moving right
				if(@change_y > 0) {
					@rect->SetBottom(platform->GetTop());
				}
				# moving left
				else if(@change_y < 0) {
					@rect->SetTop(platform->GetBottom());
				};

				# Stop our vertical movement
				@change_y := 0;
			};
		};				
	}

	method : public : Draw()  ~ Nil {
		@rect->Render();
	}

	method : public : Gravity()  ~ Nil {
		if(@change_y = 0) {
			@change_y := 1;
		}
		else {
			@change_y += 0.35;
		};

		# See if we are on the ground.
		if(@rect->GetTop() >= Game->SCREEN_HEIGHT - @rect->GetHeight() & @change_y >= 0) {
			@change_y := 0;
			@rect->SetTop(Game->SCREEN_HEIGHT - @rect->GetHeight());
		};
	}
}

class Barrier {
	@rect : Rectangle;

	New(x : Int, y : Int, rect : Rectangle) {
		@rect := rect;
		@rect->SetFill(true);
		@rect->SetColor(Color->New(0, 255, 0));
		@rect->Set(x, y);
	}

	method : public : AddX(x : Int)  ~ Nil {
		@rect->AddX(x);
	}

	method : public : GetLeft()  ~ Int {
		return @rect->GetLeft();
	}

	method : public : GetRight()  ~ Int {
		return @rect->GetRight();
	}

	method : public : GetTop()  ~ Int {
		return @rect->GetTop();
	}

	method : public : GetBottom()  ~ Int {
		return @rect->GetBottom();
	}

	method : public : Draw()  ~ Nil {
		@rect->Render();
	}

	method : public : Collides(rect : Rectangle) ~ Bool {
		return @rect->GetPosition()->Overlaps(rect->GetPosition());
	}
}

class Level {
	@player : Player;
	@platforms : Vector<Barrier>;
	@shift_x : Int;

	New(player : Player, framework : GameFramework) {
		@player := player;

		@platforms := Vector->New()<Barrier>;		
		@platforms->AddBack(Barrier->New(600, 500, framework->AddRectangle(100, 50)));	
		@platforms->AddBack(Barrier->New(400, 400, framework->AddRectangle(100, 50)));	
		@platforms->AddBack(Barrier->New(1005, 400, framework->AddRectangle(100, 50)));

		@player->SetLevel(@self);
	}

	function : Collides(player : Player, obstacles : Vector<Barrier>) ~ Bool {
		each(i : obstacles) {
			obstacle := obstacles->Get(i);
			if(obstacle->Collides(player->GetRect())) {
				return true;
			};
		};

		return false;
	}

	function : Collisions(player : Player, obstacles : Vector<Barrier>) ~ Vector<Barrier> {
		collides := Vector->New()<Barrier>;

		each(i : obstacles) {
			obstacle := obstacles->Get(i);
			if(obstacle->Collides(player->GetRect())) {
				collides->AddBack(obstacle);
			};
		};

		return collides;
	}

	method : public : GetShiftX() ~ Int {
		return @shift_x;
	}

	method : public : ShiftWorld(shift_x : Int) ~ Nil {
		@shift_x += shift_x;

		each(i : @platforms) {
			platform := @platforms->Get(i);
			platform->AddX(shift_x);
		};
	}

	method : public : GetBarriers() ~ Vector<Barrier> {
		return @platforms;
	}

	method : public : Update()  ~ Nil {
		each(i : @platforms) {
			platform := @platforms->Get(i);
		};
	}

	method : public : Draw()  ~ Nil {
		each(i : @platforms) {
			@platforms->Get(i)->Draw();
		};
	}
}

consts Game {
	SCREEN_WIDTH := 800,
	SCREEN_HEIGHT := 600
}