use Game.SDL2;
use Game.Framework;
use Collection;

class Player {
	@rect : AnimatedImageSprite;
	@change_x : Float;
	@change_y : Float;
	@level : Level;
	@platforms : Vector;

	New(rect : AnimatedImageSprite) {
		@rect := rect;
		@rect->SetLeft(120);
	}

	method : public : GetRect() ~ AnimatedImageSprite {
		return @rect; 
	}

	method : public : GetLeft() ~ Int {
		return @rect->GetLeft();
	}

	method : public : GetRight() ~ Int {
		return @rect->GetRight();
	}

	method : public : SetLeft(x : Int) ~ Nil {
		@rect->SetLeft(x);
	}

	method : public : SetRight(x2 : Int) ~ Nil {
		@rect->SetRight(x2);
	}

	method : public : SetLevel(level : Level)  ~ Nil {
		@level := level;
		@platforms := @level->GetPlatforms();
	}

	method : public : ChangeLeft()  ~ Int {
		return @change_x;
	}

	method : public : GoLeft()  ~ Nil {
		@change_x := -6;
	}

	method : public : GoRight()  ~ Nil {
		@change_x := 6;
	}

	method : public : Stop() ~ Nil {
		@change_x := 0;
	}

	method : public : Jump()  ~ Nil {
		@rect->AddY(2);
		bottom := Level->Collides(@self, @platforms);
        @rect->AddY(-2);
 
        if(bottom | @rect->GetBottom() >= Game->SCREEN_HEIGHT) {
			@change_y := -10;
        };
	}

	method : public : native : Update()  ~ Nil {
		Gravity();

		# Move left/right
        @rect->AddX(@change_x);
        collides := Level->Collisions(@self, @platforms);
        each(i : collides) {
        	block := collides->Get(i)->As(Block);
        	# moving right
			if(@change_x > 0) {
				if(block->GetType() <> Block->Type->LEFT_STONE_SLOP_UP) {
    				@rect->SetRight(block->GetLeft());
    			};
            }
    		# moving left
            else if(@change_x < 0) {
            	if(block->GetType() <> Block->Type->RIGHT_STONE_SLOP_UP) {
bar := block->GetType()->As(Int);            		
"--- Blah: type={$bar} ---"->PrintLine();
            		@rect->SetLeft(block->GetRight());
            	};
            };
        };
		
		# Move up/down
        @rect->AddY(@change_y);
		each(i : @platforms) {
        	block := @platforms->Get(i)->As(Block);
        	if(block->Collides(@rect)) {
        		# moving down
        		if(@change_y > 0) {
        			if(block->GetType() = Block->Type->LEFT_STONE_SLOP_UP) {
        				UpLeftSlope(block);
						if(@rect->GetBottom() - 2 < block->GetTop()) {
							@rect->SetBottom(block->GetTop());
						};
					}
					else if(block->GetType() = Block->Type->RIGHT_STONE_SLOP_UP) {
        				UpRightSlope(block);
						if(@rect->GetBottom() - 2 < block->GetTop()) {
							@rect->SetBottom(block->GetTop());
						};
					}
					else {
        				@rect->SetBottom(block->GetTop());
        			};
                }
        		# moving up
                else if(@change_y < 0) {
                	@rect->SetTop(block->GetBottom());
		        };

	            # Stop our vertical movement
            	@change_y := 0;
#~
	            if(block->TypeOf(MovingPlatform)) {
	            	@rect->AddX(block->As(MovingPlatform)->GetChangeLeft());
	            };
~#	            
        	};
        };				
	}

	method : UpRightSlope(block : Block) ~ Nil {
		left := block->GetLeft();
		right := block->GetRight();
		top := block->GetTop();
		bottom := block->GetBottom();

		px := @rect->GetRight();
		py := @rect->GetBottom();

"--- Foo Bar ---"->PrintLine();

		if(@change_x <= 0) {
			while(InsideTriangle(right, bottom, right, bottom, left, top, px, py)) {
				@rect->AddY(-1);

				px := @rect->GetRight();
				py := @rect->GetBottom();
			};
		};
	}

	method : UpLeftSlope(block : Block) ~ Nil {
		left := block->GetLeft();
		right := block->GetRight();
		top := block->GetTop();
		bottom := block->GetBottom();

		px := @rect->GetRight();
		py := @rect->GetBottom();

		if(@change_x >= 0) {
			while(InsideTriangle(left, bottom, right, bottom, right, top, px, py)) {
				@rect->AddY(-1);

				px := @rect->GetRight();
				py := @rect->GetBottom();
			};
		};
	}

	function : InsideTriangle(x1 : Int, y1 : Int, x2 : Int, y2 : Int, x3 : Int, y3 : Int, x : Int, y : Int) ~ Bool {   
		a := TriangleArea(x1, y1, x2, y2, x3, y3);
		a1 := TriangleArea(x, y, x2, y2, x3, y3);
        a2 := TriangleArea(x1, y1, x, y, x3, y3);      
        a3 := TriangleArea(x1, y1, x2, y2, x, y);

		return (a = a1 + a2 + a3);
    }

	function : native : TriangleArea(x1 : Int, y1 : Int, x2 : Int, y2 : Int, x3 : Int, y3 : Int) ~ Int {
       return Int->Abs((x1*(y2-y3) + x2*(y3-y1)+x3*(y1-y2))/2);
	}

	method : public : Draw()  ~ Nil {
		index := Int->Abs((@level->GetShift() + @rect->GetLeft()) / 30 % @rect->GetClipCount());
		@rect->Render(index);
	}

	method : public : Gravity()  ~ Nil {
        if(@change_y = 0) {
            @change_y := 1;
        }
        else {
            @change_y += .35;
        };

        # See if we are on the ground.
        if(@rect->GetTop() >= Game->SCREEN_HEIGHT - @rect->GetHeight() & @change_y >= 0) {
            @change_y := 0;
            @rect->SetTop(Game->SCREEN_HEIGHT - @rect->GetHeight());
        };
	}
}