use Game.SDL2;
use Game.Framework;
use Collection;

class Demo {
	@framework : GameFramework;
	@player : Player;
	@platforms : Vector;

	function : Main(args : String[]) ~ Nil {
		Demo->New()->Run();
	}

	New() {
		@framework := GameFramework->New(Game->SCREEN_WIDTH, Game->SCREEN_HEIGHT, "Accel");
		@framework->SetClearColor(Color->New(0, 0, 255));
		@platforms := Vector->New();
	}

	method : Run() ~ Nil {
		if(@framework->IsOk()) {
			clips := Vector->New();
			clips->AddBack(Rect->New(0, 0, 32, 52));
#~			
			clips->AddBack(Rect->New(342, 0, 342, 354));
			clips->AddBack(Rect->New(648, 0, 342, 354));
			clips->AddBack(Rect->New(1026, 0, 342, 354));
~#
			@player := Player->New(@framework->AddAnimatedImageSprite("C:\\Users\\objec\\Documents\\Code\\objeck-lang\\programs\\sdl\\engine\\tests\\media\\images\\player.png", clips), @platforms);
			@platforms->AddBack(Platform->New(420, 535, @framework->AddRectangle(110, 35)));
			@platforms->AddBack(Platform->New(340, 475, @framework->AddRectangle(120, 35)));
			@platforms->AddBack(Platform->New(220, 385, @framework->AddRectangle(210, 35)));
			@platforms->AddBack(Platform->New(520, 285, @framework->AddRectangle(210, 35)));

			quit := false;
			e := @framework->GetEvent();
			while(<>quit) {
				@framework->FrameStart();
				@framework->Clear();
				
				# process input
				while(e->Poll() <> 0) {
					if(e->GetType() = EventType->SDL_QUIT) {
						quit := true;
					};

					ProcessInput(e);
				};

				# update
				@player->Update();

				# draw
				@player->Draw();
				each(i : @platforms) {
					@platforms->Get(i)->As(Platform)->Draw();
				};
				
				# show
				@framework->Show();
				@framework->FrameEnd();
			};
		}
		else {
			"--- Error Initializing Game Environment ---"->ErrorLine();
			return;
		};

		leaving {
			@framework->Quit();
		};
	}

	method : public : ProcessInput(e : Event) ~ Nil {
		if(e->GetType() = EventType->SDL_KEYDOWN) {
	        select(e->GetKey()->GetKeysym()->GetScancode()) {    	
	            label Scancode->SDL_SCANCODE_LEFT: {
	            	@player->GoLeft();
	            }

	            label Scancode->SDL_SCANCODE_RIGHT: {
	            	@player->GoRight();
	            }

	            label Scancode->SDL_SCANCODE_UP: {
	            	@player->Jump(true);
	            }

	            label Scancode->SDL_SCANCODE_D: {
	           		@player->Dump();
	           	}
	        };
	    }
	    else if(e->GetType() = EventType->SDL_KEYUP) {
	       	select(e->GetKey()->GetKeysym()->GetScancode()) {
		       	label Scancode->SDL_SCANCODE_LEFT:
		        label Scancode->SDL_SCANCODE_RIGHT: {
		        	@player->Stop();
		        }

		        label Scancode->SDL_SCANCODE_UP: {
		        	@player->Jump(false);
		       	}
		    };
	    };
	}

	function : Collisions(player : Player, obstacles : Vector) ~ Vector {
		collides := Vector->New();

		each(i : obstacles) {
        	obstacle := obstacles->Get(i)->As(Platform);
        	if(obstacle->Collides(player->GetRect())) {
        		collides->AddBack(obstacle);
        	};
        };

        return collides;
    }
}

class Player {
	@rect : AnimatedImageSprite;
	@loc : Vector2;
	@vel : Vector2;
	@acc : Vector2;
	@jumped : Bool;
	@jump_max : Int;
	@hit_top : Bool;
	@platforms : Vector;
	
	New(rect : AnimatedImageSprite, platforms : Vector) {
		@rect := rect;		
		@loc := Vector2->New(Game->SCREEN_WIDTH / 2, Game->SCREEN_HEIGHT / 2);
		@vel := Vector2->New();
		@acc := Vector2->New();

		@platforms := platforms;
	}

	method : public : GetRect() ~ AnimatedImageSprite {
		return @rect;
	}

	method : public : GetLeft() ~ Int {
		return @rect->GetLeft();
	}

	method : public : GetRight() ~ Int {
		return @rect->GetRight();
	}

	method : public : GoLeft()  ~ Nil {
		if(@rect->GetFlip() = RendererFlip->SDL_FLIP_NONE) {
			@rect->SetFlip(RendererFlip->SDL_FLIP_HORIZONTAL);
		};

		@acc->SetX(-0.75);
	}

	method : public : GoRight()  ~ Nil {
		if(@rect->GetFlip() = RendererFlip->SDL_FLIP_HORIZONTAL) {
			@rect->SetFlip(RendererFlip->SDL_FLIP_NONE);
		};

		@acc->SetX(0.75);
	}

	method : public : Stop()  ~ Nil {
	}
	
	method : public : Jump(jumped : Bool)  ~ Nil {
		@jumped := jumped;
	}

	method : public : Update()  ~ Nil {
		if(@hit_top) {
			@acc->SetY(120);
			@hit_top := false;
		}
		else {
			if(@jumped & @jump_max < 3) {
				@acc->SetY(-5.3);
				@jump_max += 1;
			}
			else {
				@acc->SetY(0.65);
			};
		};

		# movement equations
		@acc->Add(Vector2->MulX(Vector2->MulY(@vel, -0.0135), -0.0447));
		@vel->Add(Vector2->Mul(@acc, 0.83));
		@loc->Add(@vel);
		@acc->Zero();
		
		# reposition 'x'
		@rect->SetCenterX(@loc->GetX());
		collides := Demo->Collisions(@self, @platforms);
        each(i : collides) {
        	platform := collides->Get(i)->As(Platform);
			if(@vel->GetX() > 0.01) {
    			@rect->SetRight(platform->GetLeft());
    			@loc->SetX(platform->GetLeft() - @rect->GetWidth() / 2);
    			@vel->MulX(0);
            }
    		else if(@vel->GetX() < -0.01) {
            	@rect->SetLeft(platform->GetRight());
            	@loc->SetX(platform->GetRight() + @rect->GetWidth() / 2);
            	@vel->MulX(0);
            };
        };

		# reposition 'y'
		@rect->SetBottom(@loc->GetY() - @rect->GetHeight() / 2);
		each(i : @platforms) {
        	platform := @platforms->Get(i)->As(Platform);
        	if(platform->Collides(@rect)) {
        		if(@vel->GetY() < 0.01) {
					@rect->SetTop(platform->GetBottom());
                	@loc->SetY(platform->GetBottom() + @rect->GetHeight() / 2);
					@jump_max := 3;
					@hit_top := true;
	            }
	            else if(@vel->GetY() > 0.01) {
        			@rect->SetBottom(platform->GetTop());
        			@loc->SetY(platform->GetTop() + @rect->GetHeight() / 2);
					@vel->SetY(0);
					@jump_max := 0;
                };
	        };
	    };

	    # wrap around side
		if(@loc->GetX() > Game->SCREEN_WIDTH) {
			@loc->SetX(0);
		}
		else if(@loc->GetX() < 0) {
			@loc->SetX(Game->SCREEN_WIDTH->As(Float));
		};

		# hit floor
		if(@rect->GetBottom() > Game->SCREEN_HEIGHT) {
			@rect->SetBottom(Game->SCREEN_HEIGHT);
        	@loc->SetY(Game->SCREEN_HEIGHT + @rect->GetHeight() / 2);
			@jump_max := 0;
			@vel->SetY(0);
		}
		else if(@loc->GetY() < 0) {
			@loc->SetY(0);
			@vel->SetY(0);
		};
	}

	method : public : Dump() ~ Nil {
		ax := @acc->GetX();
		ay := @acc->GetY();

		vx := @vel->GetX();
		vy := @vel->GetY();

		lx := @loc->GetX();
		ly := @loc->GetY();
				
		"x=[acc={$ax}, vel={$vx}, loc={$lx}]"->PrintLine();
		"y=[acc={$ay}, vel={$vy}, loc={$ly}]"->PrintLine();
		"--------"->PrintLine();
	}

	method : public : Draw()  ~ Nil {
		index := Int->Abs(@rect->GetLeft() / 50 % @rect->GetClipCount());
		@rect->Render(index);
	}
}

class Platform {
	@rect : Rectangle;

	New(x : Int, y : Int, rect : Rectangle) {
		@rect := rect;
		@rect->SetFill(true);
		@rect->SetColor(Color->New(0, 255, 0));
		@rect->Set(x, y);
	}

	method : public : AddX(x : Int)  ~ Nil {
		@rect->AddX(x);
	}

	method : public : GetLeft()  ~ Int {
		return @rect->GetLeft();
	}

	method : public : GetRight()  ~ Int {
		return @rect->GetRight();
	}

	method : public : GetTop()  ~ Int {
		return @rect->GetTop();
	}

	method : public : GetBottom()  ~ Int {
		return @rect->GetBottom();
	}

	method : public : Draw()  ~ Nil {
		@rect->Render();
	}

	method : public : Collides(rect : AnimatedImageSprite) ~ Bool {
		return @rect->GetPosition()->Overlaps(rect->GetPosition());
	}
}

consts Game {
	SCREEN_WIDTH := 800,
	SCREEN_HEIGHT := 600
}