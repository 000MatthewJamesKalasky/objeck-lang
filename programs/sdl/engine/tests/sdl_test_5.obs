use Game.SDL2;
use Game.Engine;
use Collection;

class Demo {
	@engine : GameEngine;
	@player : Player;
	@level : Level;

	function : Main(args : String[]) ~ Nil {
		Demo->New()->Run();
	}

	New() {
		@engine := GameEngine->New(Game->SCREEN_WIDTH, Game->SCREEN_HEIGHT, "Platformer Jumper");
		@engine->SetClearColor(Color->New(0, 0, 255));
	}

	method : Run() ~ Nil {
		if(@engine->IsOk()) {
			@player := Player->New(@engine->AddRectangle(40, 60));
			@level := Level->New(@player, @engine);

			quit := false;
			e := @engine->GetEvent();
			while(<>quit) {
				@engine->FrameStart();
				@engine->Clear();
				
				# process input
				while(e->Poll() <> 0) {
					if(e->GetType() = EventType->SDL_QUIT) {
						quit := true;
					};

					ProcessInput(e);
				};

				# update
				@player->Update();
				@level->Update();

				if(@player->GetRight() >= 500) {
					diff := @player->GetRight() - 500;
					@player->SetRight(500);
					@level->ShiftWorld(-1 * diff);
		        };

		        if(@player->GetLeft() <= 120) {
					diff := 120 - @player->GetLeft();
					@player->SetLeft(120);
					@level->ShiftWorld(diff);
				};

				current_position := @player->GetLeft() + @level->GetShiftX();

#~
				# check for screen edges
				if(@player->GetRight() > Game->SCREEN_WIDTH) {
		            @player->SetRight(Game->SCREEN_WIDTH);
		        };
		 
		        if(@player->GetLeft() < 0) {
		            @player->SetLeft(0);
		        };
~#

				# draw
				@player->Draw();
				@level->Draw();

				# show
				@engine->Show();
				@engine->FrameEnd();
			};
		}
		else {
			"--- Error Initializing Game Environment ---"->ErrorLine();
			return;
		};

		leaving {
			@engine->Quit();
		};
	}

	method : public : ProcessInput(e : Event) ~ Nil {
		if(e->GetType() = EventType->SDL_KEYDOWN) {
	        select(e->GetKey()->GetKeysym()->GetScancode()) {    	
	            label Scancode->SDL_SCANCODE_LEFT: {
	            	@player->GoLeft();
	            }

	            label Scancode->SDL_SCANCODE_RIGHT: {
	            	@player->GoRight();
	            }

	            label Scancode->SDL_SCANCODE_UP: {
	            	@player->Jump();
	            }
	        };
	    }
	    else if(e->GetType() = EventType->SDL_KEYUP) {
	       	code := e->GetKey()->GetKeysym()->GetScancode();
	       	
	       	if(code = Scancode->SDL_SCANCODE_LEFT & @player->ChangeX() < 0) {
	       		@player->Stop();
	        };

	        if(code = Scancode->SDL_SCANCODE_RIGHT & @player->ChangeX() > 0) {
	        	@player->Stop();
	        };
	    };
	}
}

class Player {
	@rect : Rectangle;
	@change_x : Float;
	@change_y : Float;
	@platforms : Vector;

	New(rect : Rectangle) {
		@rect := rect;
		@rect->SetFill(true);
		@rect->SetColor(Color->New(255, 0, 0));
		@rect->SetX(120);
	}

	method : public : GetRect() ~ Rectangle {
		return @rect; 
	}

	method : public : GetLeft() ~ Int {
		return @rect->GetX();
	}

	method : public : GetRight() ~ Int {
		return @rect->GetX2();
	}

	method : public : SetLeft(x : Int) ~ Nil {
		@rect->SetX(x);
	}

	method : public : SetRight(x2 : Int) ~ Nil {
		@rect->SetX2(x2);
	}

	method : public : SetLevel(level : Level)  ~ Nil {
		@platforms := level->GetPlatforms();
	}

	method : public : ChangeX()  ~ Int {
		return @change_x;
	}

	method : public : GoLeft()  ~ Nil {
		@change_x := -6;
	}

	method : public : GoRight()  ~ Nil {
		@change_x := 6;
	}

	method : public : Stop()  ~ Nil {
		@change_x := 0;
	}

	# TODO
	method : public : Jump()  ~ Nil {
		@rect->AddY(2);
		bottom := Level->Collides(@self, @platforms);
        @rect->AddY(-2);
 
        if(bottom | @rect->GetY2() >= Game->SCREEN_HEIGHT) {
			@change_y := -10;
        };
	}

	method : public : native : Update()  ~ Nil {
		Gravity();

		# Move left/right
        @rect->AddX(@change_x);

        collides := Level->Collisions(@self, @platforms);
        each(i : collides) {
        	platform := collides->Get(i)->As(Platform);
			if(@change_x > 0) {
    			@rect->SetX2(platform->GetX());
            }
    		# moving left
            else if(@change_x < 0) {
            	@rect->SetX(platform->GetX2());
            };
        };

        collides := Level->Collisions(@self, @platforms);
        each(i : collides) {
        	platform := collides->Get(i)->As(Platform);
    		# moving right
    		if(@change_x > 0) {
    			@rect->SetX2(platform->GetX());
            }
    		# moving left
            else if(@change_x < 0) {
            	@rect->SetX(platform->GetX2());
            };
        };
				
		# Move up/down
        @rect->AddY(@change_y);
		each(i : @platforms) {
        	platform := @platforms->Get(i)->As(Platform);
        	if(platform->Collides(@rect)) {
        		# moving right
        		if(@change_y > 0) {
        			@rect->SetY2(platform->GetY());
                }
        		# moving left
                else if(@change_y < 0) {
                	@rect->SetY(platform->GetY2());
	            };

	            if(platform->TypeOf(MovingPlatform)) {
	            	@rect->SetX(platform->As(MovingPlatform)->GetChangeX());
	            };
        	};
        };				
	}

	method : public : Draw()  ~ Nil {
		@rect->Render();
	}

	method : public : Gravity()  ~ Nil {
        if(@change_y = 0) {
            @change_y := 1;
        }
        else {
            @change_y += .35;
        };
 
        # See if we are on the ground.
        if(@rect->GetY() >= Game->SCREEN_HEIGHT - @rect->GetHeight() & @change_y >= 0) {
            @change_y := 0;
            @rect->SetY(Game->SCREEN_HEIGHT - @rect->GetHeight());
        };
	}
}

class Platform {
	@rect : Rectangle;

	New(x : Int, y : Int, rect : Rectangle) {
		@rect := rect;
		@rect->SetFill(true);
		@rect->SetColor(Color->New(0, 255, 0));
		@rect->Set(x, y);
	}

	method : public : AddX(x : Int)  ~ Nil {
		@rect->AddX(x);
	}

	method : public : GetX()  ~ Int {
		return @rect->GetX();
	}

	method : public : GetX2()  ~ Int {
		return @rect->GetX2();
	}

	method : public : GetY()  ~ Int {
		return @rect->GetY();
	}

	method : public : GetY2()  ~ Int {
		return @rect->GetY2();
	}

	method : public : Update()  ~ Nil {
	}

	method : public : Draw()  ~ Nil {
		@rect->Render();
	}

	method : public : Collides(rect : Rectangle) ~ Bool {
		return @rect->GetPosition()->Overlaps(rect->GetPosition());
	}
}

class MovingPlatform from Platform {
	@change_x : Int;
    @change_y : Int;
    @boundary_top : Int;
    @boundary_bottom : Int;
    @boundary_left : Int;
    @boundary_right : Int;
    @player : Player;
    @level : Level;

	New(x : Int, y : Int, rect : Rectangle, player : Player) {
		Parent(x, y, rect);
		@player := player;
	}

	method : public : GetChangeX() ~ Int {
		return @change_x;
	}

	method : public : SetLevel(level : Level)  ~ Nil {
		@level := level;
	}

	method : public : native : Update()  ~ Nil {
		@rect->AddX(@change_x);

		if(Collides(@player->GetRect())) {
			if(@change_x < 0) {
                @player->GetRect()->SetX2(@rect->GetX());
            }
            else {
            	@player->GetRect()->SetX(@rect->GetX2());
 			};
		};

		@rect->AddY(@change_y);
		if(Collides(@player->GetRect())) {
			if(@change_y < 0) {
                @player->GetRect()->SetY2(@rect->GetY());
			}
            else {
				@player->GetRect()->SetY(@rect->GetY2());
            };
		};

		if(@rect->GetY2() > @boundary_bottom | @rect->GetY() < @boundary_top) {
			@change_y *= -1;
		};

		cur_pos := @rect->GetX() - @level->GetShiftX();
        if(cur_pos < @boundary_left | cur_pos > @boundary_right) {
			@change_x *= -1;
        };
	}
}

class Level {
	@player : Player;
	@platforms : Vector;
	@shift_x : Int;

	New(player : Player, engine : GameEngine) {
		@player := player;
		@platforms := Vector->New();

		@platforms->AddBack(Platform->New(500, 500, engine->AddRectangle(210, 70)));
		@platforms->AddBack(Platform->New(200, 400, engine->AddRectangle(210, 70)));	
		@platforms->AddBack(Platform->New(600, 300, engine->AddRectangle(210, 70)));
		@platforms->AddBack(Platform->New(850, 600, engine->AddRectangle(210, 70)));
		@platforms->AddBack(Platform->New(1025, 500, engine->AddRectangle(210, 70)));	
		@platforms->AddBack(Platform->New(1250, 300, engine->AddRectangle(210, 70)));

		@player->SetLevel(@self);
	}

	function : Collides(player : Player, obstacles : Vector) ~ Bool {
		each(i : obstacles) {
        	obstacle := obstacles->Get(i)->As(Platform);
        	if(obstacle->Collides(player->GetRect())) {
        		return true;
        	};
        };

        return false;
	}

	function : Collisions(player : Player, obstacles : Vector) ~ Vector {
		collides := Vector->New();

		each(i : obstacles) {
        	obstacle := obstacles->Get(i)->As(Platform);
        	if(obstacle->Collides(player->GetRect())) {
        		collides->AddBack(obstacle);
        	};
        };

        return collides;
    }

	method : public : GetShiftX() ~ Int {
		return @shift_x;
	}

	method : public : ShiftWorld(shift_x : Int) ~ Nil {
		@shift_x += shift_x;

		each(i : @platforms) {
			platform := @platforms->Get(i)->As(Platform);
			platform->AddX(shift_x);
		};
	}

	method : public : GetPlatforms() ~ Vector {
		return @platforms;
	}

	method : public : Update()  ~ Nil {
		each(i : @platforms) {
			@platforms->Get(i)->As(Platform)->Update();
		};
	}

	method : public : Draw()  ~ Nil {
		each(i : @platforms) {
			@platforms->Get(i)->As(Platform)->Draw();
		};
	}
}

consts Game {
	SCREEN_WIDTH := 800,
	SCREEN_HEIGHT := 600
}