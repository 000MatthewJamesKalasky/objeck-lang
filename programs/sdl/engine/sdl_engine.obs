use Game.SDL2;
use Collection;

#~
Game engine wrapper around SDL2
~#
bundle Game.Engine {
	#~
	Animated sprite backed by a sprite sheet.
	~#
	class AnimatedImageSprite from ImageSprite {
		@clip : Rect;
		@clip_offset : Int;
		@clip_count : Int;

		New(renderer : Renderer, file : String, clip_count : Int) {
			Parent(renderer, file);

			if(@is_ok) {
				@clip_count := clip_count;
				@clip_offset := GetWidth() / @clip_count;
				@clip := Rect->New(0, 0, @clip_offset, GetHeight());
			};
		}

		#~
		Renders sprite
		@param x x-position
		@param y y-position
		@param index sprite image index
		~#
		method : public : Render(x : Int, y : Int, index : Int) ~ Nil {
			if(@is_ok & index > -1 & index < @clip_count) {
				@clip->SetX(@clip_offset * index);
				RenderAll(x, y, @clip, @angle, Nil, @flip);
			};
		}

		#~
		Get number of clips in sprite sheet
		@return number of clips
		~#
		method : public : GetClipCount() ~ Int {
			return @clip_count;
		}
	}

	#~
	Animated sprite backed by a sprite sheet.
	~#
	class ImageSprite from Sprite {
		@is_ok : Bool;
		@angle : Float;
		@flip : RendererFlip;

		New(renderer : Renderer, file : String) {
			Parent(renderer);
			@angle := 0;
			@flip := RendererFlip->SDL_FLIP_NONE;
			@is_ok := LoadImage(file);
		}

		method : LoadImage(file : String) ~ Bool {
			Free();

			surface := Image->Load(file);
			if(surface->IsNull()) {
				"Unable to load image '{$file}'"->ErrorLine();
				return false;
			};
			# TODO: set colorkey
			surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(0, 0xFF, 0xFF));

			texture := surface->CreateTexture(@renderer);
			if(texture->IsNull()) {
				"Unable to create texture!"->ErrorLine();
				return false;
			};

			@render_rect->SetW(surface->GetW());
			@render_rect->SetH(surface->GetH());
			
			surface->Free();

			@texture := texture;
			return @texture <> Nil;
		}

		method : public : SetAngle(angle : Float) ~ Nil {
			@angle := angle;
		}

		method : public : GetAngle() ~ Float {
			return @angle;
		}

		method : public : SetFlip(flip : RendererFlip) ~ Nil {
			@flip := flip;
		}

		method : public : GetFlip() ~ RendererFlip {
			return @flip;
		}

		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@is_ok) {
				RenderAll(x, y, Nil, @angle, Nil, @flip);
			};
		}
	}

	class TextSprite from Sprite {
		@font : Font;
		@is_ok : Bool;

		New(renderer : Renderer, font : Font) {
			Parent(renderer);
			@font := font;
		}

		method : public : SetFont(font : Font) ~ Nil {
			@font := font;
		}		

		method : public : RenderedText(text : String, color : Color := Nil) ~ Nil {
			if(@font <> Nil) {
				Free();

				if(color = Nil) {
					color := Color->New(32, 32, 32);
				};

				# Render text surface
				text_surface := @font->RenderTextSolid(text, color);
				if(text_surface->IsNull()) {
					"Unable to render text surface!"->ErrorLine();
					@is_ok := false;
				};

				texture := text_surface->CreateTexture(@renderer);
				@render_rect->SetW(text_surface->GetW());
				@render_rect->SetH(text_surface->GetH());
				text_surface->Free();
				
				@texture := texture;
				@is_ok := @texture <> Nil;
			}
			else {
				@is_ok := false;
			};
		}

		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@is_ok) {
				RenderAll(x, y);
			};
		}
	}

	class Sprite implements Shape {
		@texture : Texture;
		@render_rect : Rect;
		@position : Position;
		@renderer : Renderer;

		New(renderer : Renderer) {			
			@renderer := renderer;			
			@render_rect := Rect->New();
			@position := Position->New(@render_rect);
		}

		method : public : Free() ~ Nil {
			if(@texture <> Nil)	{
				@texture->Destroy();
				@render_rect->SetX(0);
				@render_rect->SetY(0);
			};
		}

		method : public : SetColor(red : Int, green : Int, blue : Int) ~ Nil {
			@texture->SetColorMod(red, green, blue);
		}

		method : public : SetBlendMode(blending : BlendMode) ~ Nil {
			@texture->SetBlendMode(blending);
		}
		
		method : public : SetAlpha(alpha : Int) ~ Nil {
			@texture->SetAlphaMod(alpha );
		}

		method : RenderAll(x : Int, y : Int, clip : Rect := Nil, angle : Float := 0.0, 
				center : Point := Nil, flip : RendererFlip := RendererFlip->SDL_FLIP_NONE) ~ Nil {
			@render_rect->SetX(x);
			@render_rect->SetY(y);
			if(clip <> Nil)	{
				@render_rect->SetW(clip->GetW());
				@render_rect->SetH(clip->GetH());
			};
			@renderer->CopyEx(@texture, clip, @render_rect, angle, center, flip);
		}

		method : public : Render(clip : Rect := Nil, angle : Float := 0.0, 
				center : Point := Nil, flip : RendererFlip := RendererFlip->SDL_FLIP_NONE) ~ Nil {
			RenderAll(@position->GetX(), @position->GetY(), clip, angle, center, flip);
		}

		method : public : GetWidth() ~ Int {
			return @render_rect->GetW();
		}

		method : public : GetHeight() ~ Int {
			return @render_rect->GetH();
		}

		method : public : GetPosition() ~ Position {
			return @position;
		}

		method : public : GetX() ~ Int {
			return @position->GetX();
		}

		method : public : GetY() ~ Int {
			return @position->GetY();
		}
	}

	class Rectangle implements Shape {
		@render_rect : Rect;
		@position : Position;
		@renderer : Renderer;
		@color : Color;
		@fill : Bool;

		New(renderer : Renderer, w : Int, h : Int) {
			@renderer := renderer;
			@render_rect := Rect->New(w, h);
			@position := Position->New(@render_rect);
		}

		method : public : Free() ~ Nil {			
		}

		method : public : GetWidth() ~ Int {
			return @render_rect->GetW();
		}

		method : public : GetHeight() ~ Int {
			return @render_rect->GetH();
		}

		method : public : GetX() ~ Int {
			return @position->GetX();
		}

		method : public : GetY() ~ Int {
			return @position->GetY();
		}

		method : public : GetPosition() ~ Position {
			return @position;
		}

		method : public : SetColor(color : Color) ~ Nil {
			@color := color;
		}

		method : public : GetColor() ~ Color {
			return @color;
		}

		method : public : SetFill(fill : Bool) ~ Nil {
			@fill := fill;
		}

		method : public : Set(x : Int, y : Int) ~ Nil {
			@position->Set(x, y);
		}

		method : public : GetFill() ~ Bool {
			return @fill;
		}

		method : public : Render() ~ Nil {
			Render(@position->GetX(), @position->GetY());
		}

		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@color = Nil) {
				@color := Color->New();
			};

			@render_rect->SetX(x);
			@render_rect->SetY(y);
			@renderer->SetDrawColor(@color->GetR(), @color->GetG(), @color->GetB(), @color->GetA());

			if(@fill) {
				@renderer->FillRect(@render_rect);
			}
			else {
				@renderer->DrawRect(@render_rect);
			};
		}
	}

	class Position {
		@rect : Rect;
		@x : Int;
		@y : Int;

		New(rect : Rect) {
			@rect := rect;
		}

		method : public : GetRect() ~ Rect {
			return @rect;
		}

		method : public : Set(x : Int, y : Int) ~ Nil {
			@x := x; @y := y;
		}

		method : public : GetX() ~ Int {
			return @x;
		}

		method : public : GetX2() ~ Int {
			return @x + @rect->GetW();
		}

		method : public : GetCenterX() ~ Int {
			return GetX2() / 2;
		}

		method : public : GetY() ~ Int {
			return @y;
		}

		method : public : GetY2() ~ Int {
			return @y + @rect->GetH();
		}

		method : public : GetCenterY() ~ Int {
			return GetY2() / 2;
		}

		method : public : native : Overlaps(rect : Position) ~ Bool {
			right_a := rect->GetX();
			right_b := GetX2();

			left_a := GetX();
			left_b := rect->GetX2();

			top_a := GetY();
			top_b := rect->GetY2();

			bottom_a := rect->GetY();
			bottom_b := GetY2();

			return right_b > right_a & left_a < left_b & top_b > top_a & bottom_a < bottom_b;
		}

		method : public : Contains(x : Int, y : Int) ~ Bool {
			return false;
		}
	}

	interface Shape {
		method : public : virtual : GetWidth() ~ Int;
		method : public : virtual : GetHeight() ~ Int;
		method : public : virtual : GetPosition() ~ Position;
		method : public : virtual : Free() ~ Nil;
	}

	class GameEngine {
		@is_ok : Bool;
		@screen_width : Int;
		@screen_height : Int;
		@renderer : Renderer;

		@clear_color : Color;
		@frame_rate : Int;
		@fps : Int;
		@frame_start : Int;

		@shapes : Vector;

		@font : Font;
		@joystick : Joystick;

		@event : Event;

		@debug_msg : static : String;

		New(screen_width : Int, screen_height : Int, title : String, fps : Int, init_flags : Int) {
			@fps := fps;
			@frame_rate := 1000 / @fps;
			@shapes := Vector->New();
			
			@is_ok := Init(screen_width, screen_height, title, init_flags);
		}

		New(screen_width : Int, screen_height : Int, title : String) {
			init_flags := HardwareFlags->SDL_INIT_VIDEO->As(Int) or
				HardwareFlags->SDL_INIT_AUDIO->As(Int) or 
				HardwareFlags->SDL_INIT_JOYSTICK->As(Int);
			@fps := 60;	
			@frame_rate := 1000 / 60;
			@shapes := Vector->New();
			
			@is_ok := Init(screen_width, screen_height, title, init_flags);
		}

		function : Debug(debug_msg : String) ~ Nil {
			if(@debug_msg = Nil) {
				@debug_msg := debug_msg;
				@debug_msg->ErrorLine();
			}
			else if(<>debug_msg->Equals(@debug_msg)) {
				@debug_msg := debug_msg;
				@debug_msg->ErrorLine();
			};
		}
		
		method : Init(screen_width : Int, screen_height : Int, title : String, init_flags : Int) ~ Bool {
			success := true;

			@screen_width := screen_width;
			@screen_height := screen_height;

			# Initialize SDL
			if(Core->Init(init_flags) < 0) {
				"SDL could not initialize!"->ErrorLine();
				return false;
			};
			
			if(<>Hints->Set("SDL_RENDER_SCALE_QUALITY", "1")) {
				"Warning: Linear texture filtering not enabled!"->ErrorLine();
				return false;
			};

			# Create window
			@window := Window->New(title, WindowFlags->SDL_WINDOWPOS_UNDEFINED, 
				WindowFlags->SDL_WINDOWPOS_UNDEFINED, @screen_width, @screen_height, 
				WindowFlags->SDL_WINDOW_SHOWN);
			if(@window->IsNull()) {
				"Cannot create window!"->ErrorLine();
				return false;
			};

			@renderer := Renderer->New(@window, -1, 
				RendererFlags->SDL_RENDERER_ACCELERATED and RendererFlags->SDL_RENDERER_PRESENTVSYNC);
			if(@renderer->IsNull()) {
				"Cannot create renderer!"->ErrorLine();
				return false;
			};
			@renderer->SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);

			img_flags := ImageFlags->IMG_INIT_PNG->As(Int);
			if((Image->Init(img_flags) and img_flags) = 0) {
				"SDL image could not initialize!"->ErrorLine();
				return false;
			};

			if(Font->Init() < 0) {
				"SDL_ttf could not initialize!"->ErrorLine();
				return false;
			};

			# SHOULD BE A PARAMETER
			@font := Font->New("../../../../programs/sdl/engine/tests/media/lazy.ttf", 18);
			if(@font->IsNull()) {
				"Failed to load font!"->ErrorLine();
				return false;
			};

			if(<>Mixer->OpenAudio(44100, Mixer->Flags->MIX_DEFAULT_FORMAT, 2, 2048)) {
				"SDL mixer could not initialize!"->ErrorLine();
				return false;
			};

			if(Joystick->Number() < 1) {
				"Warning: No joysticks connected!"->ErrorLine();
			};
			@joystick := Joystick->New(0);

			@event := Event->New();
			
			return true;
		}

		method : public : IsOk() ~ Bool {
			return @is_ok;
		}		

		method : public : GetRenderer() ~ Renderer {
			return @renderer;
		}

		method : public : GetEvent() ~ Event {
			return @event;
		}

		method : public : FrameStart() ~ Nil {
			@frame_start := Timer->GetTicks();
		}

		method : public : GetFps() ~ Int {
			return @fps;
		}

		method : public : FrameEnd() ~ Nil {
			end := @frame_start - Timer->GetTicks();
			if(end < @frame_rate) {
				Timer->Delay(@frame_rate - end);
			};
		}

		method : public : SetClearColor(color : Color) ~ Nil {
			@clear_color := color;
		}

		method : public : GetClearColor() ~ Color {
			return @clear_color;
		}

		method : public : Clear() ~ Nil {
			if(@clear_color = Nil) {
				@renderer->SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
			}
			else {
				@renderer->SetDrawColor(@clear_color->GetR(), @clear_color->GetG(), 
					@clear_color->GetB(), @clear_color->GetA());
			};
			@renderer->Clear();
		}

		method : public : Show() ~ Nil {
			@renderer->Present();
		}

		method : public : AddRectangle(w : Int, h : Int) ~ Rectangle {
			shape := Rectangle->New(@renderer, w, h);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : AddTextSprite() ~ TextSprite {
			shape := TextSprite->New(@renderer, @font);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : AddImageSprite(file : String) ~ ImageSprite {
			shape := ImageSprite->New(@renderer, file);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : AddAnimatedImageSprite(file : String, clip_count : Int) ~ AnimatedImageSprite {
			shape := AnimatedImageSprite->New(@renderer, file, clip_count);
			@shapes->AddBack(shape);

			return shape;
		}

		method : public : RemoveSprite(shape : Shape) ~ Bool {
			found := -1;
			
			for(i := 0; i < @shapes->Size() & found < 0; i +=1;) {
				if(@shapes->Get(i) = shape) {
					found := i;
				};
			};

			if(found > -1) {
				@shapes->Remove(found);
				shape->Free();

				return true;
			};

			return false;
		}

		method : public : FreeShapes() ~ Nil {
			each(i : @shapes) {
				shape := @shapes->Get(i)->As(Shape);
				shape->Free();
			};
		}

		method : public : Quit() ~ Nil {
			each(i : @shapes) {
				shape := @shapes->Get(i)->As(Shape);
				shape->Free();
			};

			if(@event <> Nil) {
				@event->Free();
			};

			if(@joystick <> Nil) {
				@joystick->Free();
			};
			
			Image->Quit();
			Font->Quit();
			Mixer->Quit();
			Core->Quit();
		}
	}
}	