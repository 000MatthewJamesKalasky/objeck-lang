use System.IO.File;
use Collection;

class Scanner {
	@file : String;
	@tokens : Vector;
	@strings : Vector;
	
	New(file : String) {
		@file ← file;
		@tokens ← Vector→New();
		@strings ← Vector→New();
	}
	
	method : public : GetTokens() ~ Vector {
		return @tokens;
	}
	
	method : public : GetStrings() ~ Vector {
		return @strings;
	}
	
	method : public : native : Scan() ~ Bool {
		reserved ← StringMap→New();
		reserved→Insert("while", IntHolder→New(Token→Type→WHILE→As(Int)));
		reserved→Insert("if", IntHolder→New(Token→Type→IF→As(Int)));
		reserved→Insert("else", IntHolder→New(Token→Type→ELSE→As(Int)));
		reserved→Insert("print", IntHolder→New(Token→Type→PRINT→As(Int)));
		reserved→Insert("puti", IntHolder→New(Token→Type→PUTI→As(Int)));
		reserved→Insert("putc", IntHolder→New(Token→Type→PUTC→As(Int)));
		reserved→Insert("puts", IntHolder→New(Token→Type→PUTS→As(Int)));
		
		reader ← FileReader→New(@file);
		leaving {
			reader→Close();
		};
		
		string_count ← 0;
		line_num ← 0;
		while(reader→IsEOF() <> true) {
			line ← reader→ReadString();
			line_num += 1;
					  
			i ← 0;  
			while(i < line→Size()) {  
				# skip whitespace
				while((line→Get(i) = ' ' | line→Get(i) = '\t') & i < line→Size()) {
					i += 1;
				};
				
				# parse the line
				if(i < line→Size()) {
					# variable
					if(line→Get(i)→IsChar() | line→Get(i) = '_') {
						string ← "";
						while(line→Get(i)→IsChar() | line→Get(i)→IsDigit() | line→Get(i) = '_') {
							string→Append(line→Get(i));
							i += 1;
						};
					
						token ← reserved→Find(string)→As(IntHolder);
						if(token <> Nil) {
							type ← token→Get()→As(Token→Type);
							@tokens→AddBack(Token→New(line_num, type, string));
						}
						else {
							@tokens→AddBack(Token→New(line_num, Token→Type→VAR, string));
						};
					}
					# number
					else if(line→Get(i)→IsDigit()) {
						number ← "";
						while(line→Get(i)→IsDigit()) {
							number→Append(line→Get(i));
							i += 1;
						};						
						@tokens→AddBack(Token→New(line_num, Token→Type→NUM, "num", number→ToInt()));
					}
					# char
					else if(line→Get(i) = '\'') {
						i += 1;
						if(line→Get(i) = '\\') {
							i += 1;
							select(line→Get(i)) {
								label 'r': {
									@tokens→AddBack(Token→New(line_num, Token→Type→CHAR, "char", '\r'));
									i += 1;
								}
								
								label 'n': {
									@tokens→AddBack(Token→New(line_num, Token→Type→CHAR, "char", '\n'));
									i += 1;
								}
								
								label 't': {
									@tokens→AddBack(Token→New(line_num, Token→Type→CHAR, "char", '\t'));
									i += 1;
								}
								
								label '\\': {
									@tokens→AddBack(Token→New(line_num, Token→Type→CHAR, "char", '\\'));
									i += 1;
								}
							};
						}
						else {
							@tokens→AddBack(Token→New(line_num, Token→Type→CHAR, "char", line→Get(i)));
							i += 1;
						};
						
						if(line→Get(i) <> '\'') {
							System.IO.Console→Print("{$line_num}: *** Invalid token: char='")→Print(line→Get(i))→PrintLine("' ***");
							System.Runtime→Exit(1);
						};
						i += 1;
					}
					# string
					else if(line→Get(i) = '"') {
						i += 1;
						string ← "";
						while(line→Get(i) <> '"' & line→Get(i) <> '\0') {
							string→Append(line→Get(i));
							i += 1;
						};
						@strings→AddBack(string);
						
						@tokens→AddBack(Token→New(line_num, Token→Type→STR_REF, "string", string_count));						
						string_count += 1;
						i += 1;
					}
					# other
					else {
						select(line→Get(i)) {
							label ',': {
								@tokens→AddBack(Token→New(line_num, Token→Type→COMMA, "comma"));
							}
							
							label '(': {
								@tokens→AddBack(Token→New(line_num, Token→Type→OPREN, "opren"));
							}
						
							label ')': {
								@tokens→AddBack(Token→New(line_num, Token→Type→CPREN, "cpren"));
							}
				
							label '{': {
								
								@tokens→AddBack(Token→New(line_num, Token→Type→OCBRACE, "ocbrace"));
							}
				
							label '}': {
								@tokens→AddBack(Token→New(line_num, Token→Type→CCBRACE, "ccbrace"));
							}
						
							label '/': {
								@tokens→AddBack(Token→New(line_num, Token→Type→DIV, "div"));
							}
							
							label '%': {
								@tokens→AddBack(Token→New(line_num, Token→Type→MOD, "mod"));
							}

							label '*': {
								@tokens→AddBack(Token→New(line_num, Token→Type→MUL, "mul"));
							}

							label '+': {
								@tokens→AddBack(Token→New(line_num, Token→Type→ADD, "add"));
							}

							label '-': {
								@tokens→AddBack(Token→New(line_num, Token→Type→SUB, "sub"));
							}
						
							label ';': {
								@tokens→AddBack(Token→New(line_num, Token→Type→SEMI, "semi-colon"));
							}
							
							label '<': {
								if(i + 1 < line→Size() & line→Get(i + 1) = '=') {
									@tokens→AddBack(Token→New(line_num, Token→Type→LESS_EQL, "equal"));
									i += 1;
								}
								else {
									@tokens→AddBack(Token→New(line_num, Token→Type→LESS, "less"));
								};
							}
							
							label '>': {
								if(i + 1 < line→Size() & line→Get(i + 1) = '=') {
									@tokens→AddBack(Token→New(line_num, Token→Type→GTR_EQL, "equal"));
									i += 1;
								}
								else {
									@tokens→AddBack(Token→New(line_num, Token→Type→GTR, "gtr"));
								};
							}
							
							label '=': {
								if(i + 1 < line→Size() & line→Get(i + 1) = '=') {
									@tokens→AddBack(Token→New(line_num, Token→Type→EQL, "equal"));
									i += 1;
								}
								else {
									@tokens→AddBack(Token→New(line_num, Token→Type→ASGN, "asgn"));
								};
							}
							
							label '&': {
								if(i + 1 < line→Size() & line→Get(i + 1) = '&') {
									@tokens→AddBack(Token→New(line_num, Token→Type→AND, "and"));
									i += 1;
								}
								else {
									@tokens→AddBack(Token→New(line_num, Token→Type→OTHER, "OTHER"));
								};
							}
							
							label '|': {
								if(i + 1 < line→Size() & line→Get(i + 1) = '|') {
									@tokens→AddBack(Token→New(line_num, Token→Type→OR, "or"));
									i += 1;
								}
								else {
									@tokens→AddBack(Token→New(line_num, Token→Type→OTHER, "OTHER"));
								};
							}
							
							label '!': {
								if(i + 1 < line→Size() & line→Get(i + 1) = '=') {
									@tokens→AddBack(Token→New(line_num, Token→Type→NEQL, "neql"));
									i += 1;
								}
								else {
									@tokens→AddBack(Token→New(line_num, Token→Type→NOT, "not"));
								};
							}
							
							other: {
								System.IO.Console→Print("{$line_num}: *** Invalid token: char='")→Print(line→Get(i))→PrintLine("' ***");
								System.Runtime→Exit(1);
							}
						};
						i += 1;
					};  
				};
			};
		};
		@tokens→AddBack(Token→New(line_num, Token→Type→EOS, "eos"));
		
		return true;
	}
	
	function : DumpTokens(tokens : Vector) ~ Nil {
		each(i : tokens) {
			token ← tokens→Get(i)→As(Token);
			name ← token→GetName();
			
			select(token→GetType()) {
				label Token→Type→VAR: {
					"var: name={$name}"→PrintLine();
				}
				
				label Token→Type→STR_REF: {
					value ← token→GetValue();
					"str_ref: id={$value}"→PrintLine();
				}
				
				label Token→Type→NUM: {
					value ← token→GetValue();
					"num: value={$value}"→PrintLine();
				}
				
				other : {
					name→PrintLine();
				}
			};
		};
	}
}

class Token {
	@line_num : Int;
	@type : Type;
	@name : String;
	@value : Int;

	enum Type ← -32 {
		ASGN,
		WHILE,
		ELSE,
		IF,
		PRINT,
		PUTC,
		PUTI,
		PUTS,
		NUM,
		CHAR,
		STR_REF,
		VAR,
		OPREN,
		CPREN,
		OCBRACE,
		CCBRACE,
		AND,
		OR,
		DIV,
		MOD,
		MUL,
		ADD,
		SUB,
		SEMI,
		COMMA,
		LESS,
		LESS_EQL,
		GTR,
		GTR_EQL,
		EQL,
		NEQL,
		NOT,
		EOS,
		OTHER
	}
	
	New(line_num : Int, type : Type, name : String) {
		@line_num ← line_num;
		@type ← type;
		@name ← name;
	}
	
	New(line_num : Int, type : Type, name : String, value : Int) {
		@line_num ← line_num;
		@type ← type;
		@value ← value;
		@name ← name;
	}
	
	method : public : GetLine() ~ Int {
		return @line_num;
	}
	
	method : public : GetType() ~ Type {
		return @type;
	}
	
	method : public : GetName() ~ String {
		return @name;
	}
	
	method : public : GetValue() ~ Int {
		return @value;
	}
}