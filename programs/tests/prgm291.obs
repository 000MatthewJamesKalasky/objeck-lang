class HeapTest { 
    function : Main(args : String[]) ~ Nil {
        h := Heap->New(11, Heap->Type->MAX); 
        h->Insert(13);
        h->Insert(2);
        h->Insert(1);
        h->Insert(5);
        h->Insert(33);
        h->Insert(3);
        
        Standard->Print(h->Peek())->PrintLine();
    } 
} 

class Heap { 
    @heap : Int[];
    @max : Int;
    @size : Int;
    @type : Heap->Type;
    
    enum Type {
        MIN,
        MAX
    }

    # Constructor  
    New(max : Int, type : Heap->Type) { 
        @max := max; 
        @type := type;
        @heap := Int->New[@max]; 
    } 
      
    # Inserts a new key 
    method : public : Insert(key : Int) ~ Bool { 
        if(@size = @max) { 
            return false; 
        } 
      
        # First insert the new key at the end  
        i := @size; 
        @heap[i] := key; 
        @size++; 
          
        if(@type = Heap->Type->MIN) {
            while(i <> 0 & @heap[i] < @heap[GetParent(i)]) { 
                Swap(@heap, i, GetParent(i)); 
                i := GetParent(i); 
            }
        }
        else {
            while(i <> 0 & @heap[i] > @heap[GetParent(i)]) { 
                Swap(@heap, i, GetParent(i)); 
                i := GetParent(i); 
            }
        }

        return true; 
    } 
      
    # Returns the minimum key (key at root) from min heap  
    method : public : Peek() ~ Int { 
        return @heap[0]; 
    } 
     
    # Method to remove minimum element (or root) from min heap  
    method : public : Pop() ~ Int { 
        if(@size <= 0) { 
            if(@type = Heap->Type->MIN) {
                return Int->MaxSize(); 
            }
            else {
                return Int->MaxSize(); 
            }
        } 
  
        if(@size = 1) { 
            @size--; 
            return @heap[0]; 
        } 
          
        # Store the minimum value,  
        # and remove it from heap  
        root := @heap[0]; 
  
        @heap[0] := @heap[@size - 1]; 
        @size--; 
        Heapify(0); 
  
        return root; 
    } 

    method : public : Size() ~ Int {
        return @size;
    }

    method : public : Capacity() ~ Int {
        return @max;
    }
          
    # This function deletes key at the  
    # given index. It first reduced value  
    # to minus infinite, then calls Pop() 
    method : public : Delete(key : Int) ~ Nil { 
        Decrease(key, Int->MinSize()); 
        Pop(); 
    } 

    # Swapping using reference  
    method : Swap(array : Int[], a : Int, b : Int) ~ Nil { 
        temp := array[a]; 
        array[a] := array[b]; 
        array[b] := temp; 
    } 
          
    # Get the Parent index for the given index 
    method : GetParent(key : Int) ~ Int { 
        return (key - 1) / 2; 
    } 
      
    # Get the Left Child index for the given index 
    method : GetLeft(key : Int) ~ Int { 
        return 2 * key + 1; 
    } 
      
    # Get the Right Child index for the given index 
    method : GetRight(key : Int) ~ Int { 
        return 2 * key + 2; 
    } 
          
    # A recursive method to heapify a subtree  
    # with the root at given index  
    # This method assumes that the subtrees 
    # are already heapified 
    method : Heapify(key : Int) ~ Nil { 
        left := GetLeft(key); 
        right := GetRight(key); 
  
        value := key; 
        if(@type = Heap->Type->MIN) {
            if(left < @size & @heap[left] < @heap[value]) { 
                value := left; 
            } 

            if(right < @size & @heap[right] < @heap[value]) { 
                value := right; 
            } 
        }
        else {
            if(left < @size & @heap[left] > @heap[value]) { 
                value := left; 
            } 

            if(right < @size & @heap[right] > @heap[value]) { 
                value := right; 
            } 
        }
        
        if(value <> key) { 
            Swap(@heap, key, value); 
            Heapify(value); 
        } 
    } 
      
    # Increases value of given key to new_val. 
    # It is assumed that new_val is greater  
    # than @heap[key]. Heapify from the given key 
    method : Increase(key : Int, new_val : Int) ~ Nil { 
        @heap[key] := new_val; 
        Heapify(key); 
    }

    # Decreases value of given key to new_val.  
    # It is assumed that new_val is smaller than @heap[key].  
    method : Decrease(key : Int, new_val : Int) ~ Nil { 
        @heap[key] := new_val; 
  
        if(@type = Heap->Type->MIN) {
            while(key <> 0 & @heap[key] < @heap[GetParent(key)]) { 
                Swap(@heap, key, GetParent(key)); 
                key := GetParent(key); 
            } 
        }
        else {
            while(key <> 0 & @heap[key] > @heap[GetParent(key)]) { 
                Swap(@heap, key, GetParent(key)); 
                key := GetParent(key); 
            } 
        }
    }
     
    # Changes value on a key 
    method : Update(key : Int, new_val : Int) ~ Nil { 
        if(@heap[key] = new_val) { 
            return; 
        }

        if(@type = Heap->Type->MIN) {
            if(@heap[key] < new_val) { 
                Increase(key, new_val); 
            } 
            else { 
                Decrease(key, new_val); 
            };
        }
        else {
            if(@heap[key] > new_val) { 
                Decrease(key, new_val); 
            } 
            else { 
                Increase(key, new_val); 
            };
        };
    } 
}