#~
Credit: translation of snarkbait (https://gist.github.com/snarkbait) Java implementation
~#
class BinaryHeap<H : Compare> {
    @heap : H[];
    @length : Int;
    @min : Bool;

    function : Main(args : String[]) ~ Nil {
        heap := BinaryHeap->New(true)<IntRef>;
        heap->Insert(IntRef->New(3));
        heap->Insert(IntRef->New(1));
        heap->Insert(IntRef->New(9));
        heap->Insert(IntRef->New(0));

#        heap->Pop()->As(IntRef)->PrintLine();
#        heap->Pop()->As(IntRef)->PrintLine();

        "---"->PrintLine();

        values := heap->GetHeap();
        each(value := values) {
            (value = Nil)->PrintLine();
            foo := value->As(IntRef);
            foo->PrintLine();
        };
    }

    New() {
        @heap := H->New[10];
        @length := 0;
        @min := true;
    }

    New(array : H[], min : Bool) {
        @heap := H->New[10];
        @length := 0;
        @min := min;

        each(elem in array) {
            Insert(elem);
        };
    }

    New(min : Bool) {
        @heap := H->New[10];
        @length := 0;
        @min := min;
    }

    method : public : GetHeap() ~ H[] {
        values := H->New[@length - 1];

        for(i := 1; i < @length; i += 1;) {
            value := @heap[i];
            if(value <> Nil) {
                values[i - 1] := value;
            };
        };

 # return Arrays.copyOfRange(@heap, 1, @length + 1);
        return values;
    }

    method : public : Insert(value : H) ~ Nil {
        # Resize if needed
        if(@length >= @heap->Size() - 1)
        {
            @heap := Resize();
        }

        @length++;
        @heap[@length] := value;
        bubbleUp();
    }

    method : public : Pop() ~ H {
        result := Peek();

        Swap(1, @length);
        @heap[@length] := Nil;
        @length--;

        BubbleDown();

        return result;
    }

    method : public : Pop(value : H) ~ Bool {
        for(i := 0; i < @heap->Size(); i += 1;) {
            if(value->Compare(@heap[i]) = 0)
            {
i->PrintLine();
                Swap(i, @length);
                @heap[@length] := Nil;
                @length--;

                BubbleDown();
                return true;
            }
        }
        return false;
    }

    method : public : Poll() ~ H {
        if(IsEmpty()) {
            return Nil;
        }

        result := Peek();

        Swap(1, @length);
        @heap[@length] := Nil;
        @length--;

        BubbleDown();
        return result;
    }

    method : public : IsEmpty() ~ Bool {
        return @length = 0;
    }

    method : public : Peek() ~ H {
        if(IsEmpty()) {
            return Nil;
        };

        return @heap[1];
    }

    method : public : Size() ~ Int {
        return @length;
    }

    method : Resize() ~ H[] {
        # Add 10 to array capacity
# return Arrays.copyOf(@heap, @heap->Size() + 10);
        return Nil;
    }

    method : bubbleUp() ~ Nil {
        index := @length;
        if(@min) {
            while(HasParent(index) & (parent(index)->Compare(@heap[index]) > 0)) {
                Swap(index, ParentIndex(index));
                index := ParentIndex(index);
            }   
        }
        else {
            while(HasParent(index) & (parent(index)->Compare(@heap[index]) < 0)) {
                Swap(index, ParentIndex(index));
                index := ParentIndex(index);
            }   

        }
    }

    method : BubbleDown() ~ Nil {
        index := 1;
        if(@min) {
            while(HasLeftChild((index))) {
                # find smaller of child values
                smaller := LeftIndex(index);
                if(HasRightChild(index) & @heap[LeftIndex(index)]->Compare(@heap[RightIndex(index)]) > 0) {
                    smaller := RightIndex(index);
                }
                if(@heap[index]->Compare(@heap[smaller]) > 0)
                {
                    Swap(index, smaller);
                }
                else {
                    break;
                }

                index := smaller;
            }               
        }
        else {
            while(HasLeftChild((index))) {
                # find larger of child values
                larger := LeftIndex(index);
                if(HasRightChild(index) & @heap[LeftIndex(index)]->Compare(@heap[RightIndex(index)]) < 0) {
                    larger := RightIndex(index);
                }

                if(@heap[index]->Compare(@heap[larger]) < 0) {
                    Swap(index, larger);
                }
                else { 
                    break;
                }
                index := larger;
            }               
        }
    }

    method : HasParent(i : Int) ~ Bool {
        return i > 1;
    }

    method : LeftIndex(i : Int)  ~ Int {
        return i * 2;
    }

    method : RightIndex(i : Int) ~ Int {
        return i * 2 + 1;
    }

    method : HasLeftChild(i : Int) ~ Bool {
        return LeftIndex(i) <= @length;
    }

    method : HasRightChild(i : Int) ~ Bool {
        return RightIndex(i) <= @length;
    }

    method : ParentIndex(i : Int) ~ Int {
        return i / 2;
    }

    method : parent(i : Int) ~ H {
        return @heap[ParentIndex(i)];
    }

    method : Swap(index1 : Int, index2 : Int) ~ Nil {
        temp := @heap[index1];
        @heap[index1] := @heap[index2];
        @heap[index2] := temp;
    }
}