#~
Credit: translation of snarkbait (https://gist.github.com/snarkbait/86c7a4bc743e8f327dbc) Java implementation
~#
class Heap<H : Compare> {
    @heap : H[];
    @length : Int;
    @min : Bool;

    function : Main(args : String[]) ~ Nil {
        heap := Heap->New(Heap->Order->MIN)<IntRef>;
        heap->Insert(IntRef->New(3));
        heap->Insert(IntRef->New(1));
        heap->Insert(IntRef->New(9));
        heap->Insert(IntRef->New(0));

        heap->Resize();

        heap->Pop()->As(IntRef)->PrintLine();
        heap->Pop()->As(IntRef)->PrintLine();

        "---"->PrintLine();

        values := heap->ToArray();
        each(ref := values) {
            value := ref->As(IntRef);
            value->Get()->PrintLine();
        };

        heap->Size()->PrintLine();
    }

    enum Order {
        MIN,
        MAX
    }

    New() {
        @heap := H->New[8];
        @length := 0;
        @min := true;
    }

    New(array : H[], order : Heap->Order) {
        @heap := H->New[8];
        @length := 0;
        @min := order = Heap->Order->MIN ? true : false;

        each(elem in array) {
            Insert(elem);
        };
    }

    New(order : Heap->Order) {
        @heap := H->New[8];
        @length := 0;
        @min := order = Heap->Order->MIN ? true : false;
    }

    method : public : ToArray() ~ H[] {        
        buffer := H->New[@length];

        i := 0;
        each(elem := @heap) {
            if(elem <> Nil) {
                buffer[i++] := elem;
            }
        };

        return buffer;
    }

    method : public : Insert(value : H) ~ Nil {
        if(@length >= @heap->Size() - 1) {
            @heap := Resize();
        };

        @length++;
        @heap[@length] := value;

        ShiftUp();
    }

    method : public : Pop() ~ H {
        result := Peek();

        Swap(1, @length);
        @heap[@length] := Nil;
        @length--;

        ShiftDown();

        return result;
    }

    method : public : Pop(value : H) ~ Bool {
        each(i : @heap) {
            if(value->Compare(@heap[i]) = 0) {
                Swap(i, @length);
                @heap[@length] := Nil;
                @length--;

                ShiftDown();
                
                return true;
            };
        };

        return false;
    }

    method : public : Poll() ~ H {
        if(IsEmpty()) {
            return Nil;
        }

        result := Peek();
        Swap(1, @length);
        @heap[@length] := Nil;
        @length--;

        ShiftDown();
        
        return result;
    }

    method : public : IsEmpty() ~ Bool {
        return @length <= 0;
    }

    method : public : Peek() ~ H {
        if(IsEmpty()) {
            return Nil;
        };

        return @heap[1];
    }

    method : public : Size() ~ Int {
        return @length;
    }

    method : Resize() ~ H[] {
        temp := H->New[@heap->Size() + @heap->Size() / 2];

        each(i : @heap) {
            elem := @heap[i];
            temp[i] := elem;
        };

        return temp;
    }

    method : ShiftUp() ~ Nil {
        index := @length;
        if(@min) {
            while(HasParent(index) & (GetParent(index)->Compare(@heap[index]) > 0)) {
                Swap(index, GetParentIndex(index));
                index := GetParentIndex(index);
            }   
        }
        else {
            while(HasParent(index) & (GetParent(index)->Compare(@heap[index]) < 0)) {
                Swap(index, GetParentIndex(index));
                index := GetParentIndex(index);
            }   
        }
    }

    method : ShiftDown() ~ Nil {
        index := 1;
        if(@min) {
            while(HasLeftChild((index))) {
                # find smaller of child values
                smaller := GetLeftIndex(index);
                if(HasRightChild(index) & @heap[GetLeftIndex(index)]->Compare(@heap[GetRightIndex(index)]) > 0) {
                    smaller := GetRightIndex(index);
                }

                if(@heap[index]->Compare(@heap[smaller]) > 0) {
                    Swap(index, smaller);
                }
                else {
                    break;
                };
                index := smaller;
            }               
        }
        else {
            while(HasLeftChild((index))) {
                # find larger of child values
                larger := GetLeftIndex(index);
                if(HasRightChild(index) & @heap[GetLeftIndex(index)]->Compare(@heap[GetRightIndex(index)]) < 0) {
                    larger := GetRightIndex(index);
                }

                if(@heap[index]->Compare(@heap[larger]) < 0) {
                    Swap(index, larger);
                }
                else { 
                    break;
                };
                index := larger;
            }               
        }
    }

    method : HasParent(i : Int) ~ Bool {
        return i > 1;
    }

    method : GetLeftIndex(i : Int)  ~ Int {
        return i * 2;
    }

    method : GetRightIndex(i : Int) ~ Int {
        return i * 2 + 1;
    }

    method : HasLeftChild(i : Int) ~ Bool {
        return GetLeftIndex(i) <= @length;
    }

    method : HasRightChild(i : Int) ~ Bool {
        return GetRightIndex(i) <= @length;
    }

    method : GetParentIndex(i : Int) ~ Int {
        return i / 2;
    }

    method : GetParent(i : Int) ~ H {
        return @heap[GetParentIndex(i)];
    }

    method : Swap(index1 : Int, index2 : Int) ~ Nil {
        temp := @heap[index1];
        @heap[index1] := @heap[index2];
        @heap[index2] := temp;
    }
}