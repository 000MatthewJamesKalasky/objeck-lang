use Collection.Generic;
use System.IO.Filesystem;

class Test {
    function : Main(args : String[]) ~ Nil {
        bytes := FileReader->ReadBinaryFile("multi.dat");
        bytes->Size()->PrintLine();
        ParseMultipartEncoding(bytes);
    }

    function : ParseMultipartEncoding(encoded : Byte[]) ~ Nil {
        offset := -1;
        i := 0;
        while(offset < 0 & i < encoded->Size()) {
            byte := encoded[i++];
            if(byte = '\r' | byte = '\n') {
                offset := i - 1;
            };
        };

        boundary := Byte->New[offset];
        Runtime->Copy(boundary, 0, encoded, 0, offset)->PrintLine();
        boundary->Size()->PrintLine();

        Find(encoded, 0, boundary)->PrintLine();
        Find(encoded, offset, boundary)->PrintLine();
    }

    function : Find(bytes : Byte[], search : Byte) ~ Int {
        return Find(bytes, 0, search);
    }
    
    function : Find(bytes : Byte[], offset : Int, search : Byte) ~ Int {
        if(offset < bytes->Size() & offset > -1) {
            for(i := offset; i < bytes->Size(); i += 1;) {
                if(bytes[i] = search) {
                    return i;
                };
            };
        };

        return -1;
    }

    function : Find(bytes : Byte[], search : Byte[]) ~ Int {
        return Find(bytes, 0, search);
    }
    
    function : Find(bytes : Byte[], offset : Int, search : Byte[]) ~ Int {
        bytes_size := bytes->Size();
        search_size := search->Size();

        if(search_size > 0 & offset < bytes_size) {
            found_index := Find(bytes, offset, search[0]);
            while(found_index > -1) {
                j := found_index;
                match := true;
                i : Int;
                for(i := 0; match & i < search_size & j < bytes_size; i += 1;) {
                    if(search[i] <> bytes[j]) {
                        match := false;
                    };
                    j += 1;
                };
                
                if(match & i = search_size) {
                    return found_index;
                };
                
                found_index := Find(bytes, found_index + 1, search[0]);
            };

            return -1;
        };

        return -1;
    }

    function : ParseUrlEncoding(encoded : String) ~ Map<String, String> {
        decodings := Map->New()<String, String>;

        pairs :=  encoded->Split('&');
        if(pairs <> Nil) {
            each(i : pairs) {
                key_value := pairs[i]->Split('=');
                if(key_value <> Nil & key_value->Size() = 2) {
                    marker := Web.HTTP.Url->Decode(key_value[0])->ReplaceAll('+', ' ');
                    value := Web.HTTP.Url->Decode(key_value[1])->ReplaceAll('+', ' ');
                    decodings->Insert(marker, value);
                };
            };
        };

        return decodings;
    }
}