use Collection.Generic;

class Test {
    function : Main(args : String[]) ~ Nil {
#        encoding := "a\r\ncd\r\nefg\r\n";
#        encoding := "\r\n\r\n\r\n";
#        encoding := "a\nb\nc\n";

        
        encoding := "------WebKitFormBoundaryoApq65UWHGEygDnw\r\n";
        encoding += "Content-Disposition: form-data; name=\"fname\"\r\n\r\n";
        encoding += "Randy\"John\"&\\r\n";
        encoding += "------WebKitFormBoundaryoApq65UWHGEygDnw\r\n";
        encoding += "Content-Disposition: form-data; name=\"lname\"\r\n\r\n";
        encoding += "Hollines /www/http/ @\r\n";
        encoding += "------WebKitFormBoundaryoApq65UWHGEygDnw--";

        
        lines := ReadLines(encoding);
        each(i : lines) {
            line := lines[i];
            "|{$line}|"->PrintLine();
        };
    }

    function : ReadLines(string : String) ~ String[] {
        count := 0;

        # count lines
        start := 0;
        skip := false;
        each(i : string) {
            if(skip) {
                skip := false;
            }
            else {
                if(string->Get(i) = '\r' & string->Get(i + 1) = '\n') {
                    line : String;
                    count += 1;

                    # update
                    start := i + 2;
                    skip := true;
                }
                else if(string->Get(i) = '\n' | string->Get(i) = '\r') {
                    line : String;
                    count += 1;

                    # update
                    start := i + 1;
                };
            };
        };

        lines := String->New[count];
        count := 0;

        # parse lines
        start := 0;
        skip := false;
        each(i : string) {
            if(skip) {
                skip := false;
            }
            else {
                if(string->Get(i) = '\r' & string->Get(i + 1) = '\n') {
                    line : String;
                    len := i - start;
                    if(len > 0) {
                        lines[count++] := string->SubString(start, len);
                    }
                    else {
                        lines[count++] := String->New();
                    };

                    # update
                    start := i + 2;
                    skip := true;
                }
                else if(string->Get(i) = '\n' | string->Get(i) = '\r') {
                    line : String;
                    len := i - start;
                    if(len > 0) {
                        lines[count++] := string->SubString(start, len);
                    }
                    else {
                        lines[count++] := String->New();
                    };

                    # update
                    start := i + 1;
                };
            };
        };

        return lines;
    }

    function : ParseUrlEncoding(encoding : String) ~ Map<String, String> {
        decodings := Map->New()<String, String>;

        pairs :=  encoding->Split('&');
        if(pairs <> Nil) {
            each(i : pairs) {
                key_value := pairs[i]->Split('=');
                if(key_value <> Nil & key_value->Size() = 2) {
                    key := Web.HTTP.Url->Decode(key_value[0])->ReplaceAll('+', ' ');
                    value := Web.HTTP.Url->Decode(key_value[1])->ReplaceAll('+', ' ');
                    decodings->Insert(key, value);
                };
            };
        };

        return decodings;
    }
}