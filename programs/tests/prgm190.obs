use Collection.Generic;
use System.IO.Filesystem;

class Test {
    @debug : static : Bool;

    function : Main(args : String[]) ~ Nil {
        @debug := true;
        ParseMultipartEncoding(FileReader->ReadBinaryFile("data/mime.dat"));
    }

    function : ParseMultipartEncoding(encoded : Byte[]) ~ Nil {
        # read encoding string
        marker_bytes := ReadLine(0, encoded);
        if(marker_bytes = Nil) {
            return;
        };

        if(@debug) {
            encoding_size := encoded->Size();        
            str_marker := marker_bytes->ToString();
            "size={$encoding_size}, marker=`{$str_marker}`"->PrintLine();
        };

        # fetch all markers
        marker_indexes := Byte->FindAll(encoded, marker_bytes);
        if(marker_indexes = Nil) {
            return;
        };

        if(@debug) {
            num_markers := marker_indexes->Size();
            "num_markers={$num_markers}\n==="->PrintLine();
        };

        # read white space
        boundry_index := marker_bytes->Size();
        if(<>MatchSpace(boundry_index, encoded)) {
            return;
        };
        boundry_index += 2;

        # read content line
boundry_index->ToHexString()->PrintLine();

        content_bytes := ReadLine(boundry_index, encoded);
        if(content_bytes = Nil) {
            return;
        };

        if(@debug) {
            content_str := content_bytes->ToString();
            "content_str={$content_str}"->PrintLine();
        };

        # read white space
        boundry_index += content_bytes->Size();

        if(<>MatchSpace(boundry_index, encoded)) {
            return;
        };
        boundry_index += 2;

        if(<>MatchSpace(boundry_index, encoded)) {
            return;
        };
        boundry_index += 2;
boundry_index->ToHexString()->PrintLine();

        if(@debug) {
            end_index := marker_indexes[1];
            "(Read content): boundry_index={$boundry_index}, end_index={$end_index}"->PrintLine();
            "---"->PrintLine();
        };
    }

    function : ReadLine(offset : Int, encoded : Byte[]) ~ Byte[] {
        i := offset;
        if(i < encoded->Size()) {
            done := false;
            read := 0;
            while(<>done & i < encoded->Size()) {
                byte := encoded[i++];
                if(byte = '\r') {
                    done := true;
                }
                else {
                    read += 1;
                };
            };

            line := Byte->New[read];
            if(Runtime->Copy(line, 0, encoded, offset, read)) {
                return line;
            };
        };

        return Nil;
    }

    function : MatchSpace(offset : Int, encoded : Byte[]) ~ Bool {
        if(offset + 1 < encoded->Size()) {
            return encoded[offset] = '\r' & encoded[offset + 1] = '\n';
        };

        return false;
    }

    function : MatchClosing(offset : Int, encoded : Byte[]) ~ Bool {
        if(offset + 1 < encoded->Size()) {
            return encoded[offset] = '-' & encoded[offset + 1] = '-';
        };

        return false;
    }

    function : ParseUrlEncoding(encoded : String) ~ Map<String, String> {
        decodings := Map->New()<String, String>;

        pairs :=  encoded->Split('&');
        if(pairs <> Nil) {
            each(i : pairs) {
                key_value := pairs[i]->Split('=');
                if(key_value <> Nil & key_value->Size() = 2) {
                    marker_bytes := Web.HTTP.Url->Decode(key_value[0])->ReplaceAll('+', ' ');
                    value := Web.HTTP.Url->Decode(key_value[1])->ReplaceAll('+', ' ');
                    decodings->Insert(marker_bytes, value);
                };
            };
        };

        return decodings;
    }
}