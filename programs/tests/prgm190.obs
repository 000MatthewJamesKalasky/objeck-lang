use Collection.Generic;
use System.IO.Filesystem;

class Test {
    function : Main(args : String[]) ~ Nil {
        ParseMultipartEncoding(FileReader->ReadBinaryFile("data/mime.dat"));
    }

    function : ParseMultipartEncoding(encoded : Byte[]) ~ Nil {
encoding_size := encoded->Size();        
        marker_bytes := ReadLine(0, encoded);
        if(marker_bytes <> Nil) {
str_marker := marker_bytes->ToString();
"size={$encoding_size}, marker=`{$str_marker}`\n==="->PrintLine();

            marker_indexes := Byte->FindAll(encoded, marker_bytes);
            each(i : marker_indexes) {
                boundry_index := marker_indexes[i];
                boundry_index += marker_bytes->Size();
                match_space := MatchSpace(boundry_index, encoded);
                match_closing := MatchClosing(boundry_index, encoded);
"{$i}: match_space={$match_space}, match_closing={$match_closing}"->PrintLine();
                boundry_index += 2;
                type_bytes := ReadLine(boundry_index, encoded);
if(type_bytes <> Nil) { type_bytes->ToString()->PrintLine(); };
                boundry_index += type_bytes->Size() - 1;
                if(MatchSpace(boundry_index, encoded)) {
                    boundry_index += 2;
"(Read content); boundry_index to next boundry_index Runtime->Copy(..)"->PrintLine();
                };

                "---"->PrintLine();
            };
        };
    }

    function : ReadLine(offset : Int, encoded : Byte[]) ~ Byte[] {
        if(offset < encoded->Size()) {
            pos := -1;
            i := offset;
            while(pos < 0 & i < encoded->Size()) {
                byte := encoded[i++];
                if(byte = '\r') {
                    pos := i - 1;
                };
            };

            line := Byte->New[pos];
            if(Runtime->Copy(line, 0, encoded, 0, pos)) {
                return line;
            };
        };

        return Nil;
    }

    function : MatchSpace(offset : Int, encoded : Byte[]) ~ Bool {
        if(offset + 1 < encoded->Size()) {
            return encoded[offset] = '\r' & encoded[offset + 1] = '\n';
        };

        return false;
    }

    function : MatchClosing(offset : Int, encoded : Byte[]) ~ Bool {
        if(offset + 1 < encoded->Size()) {
            return encoded[offset] = '-' & encoded[offset + 1] = '-';
        };

        return false;
    }

    function : ParseUrlEncoding(encoded : String) ~ Map<String, String> {
        decodings := Map->New()<String, String>;

        pairs :=  encoded->Split('&');
        if(pairs <> Nil) {
            each(i : pairs) {
                key_value := pairs[i]->Split('=');
                if(key_value <> Nil & key_value->Size() = 2) {
                    marker_bytes := Web.HTTP.Url->Decode(key_value[0])->ReplaceAll('+', ' ');
                    value := Web.HTTP.Url->Decode(key_value[1])->ReplaceAll('+', ' ');
                    decodings->Insert(marker_bytes, value);
                };
            };
        };

        return decodings;
    }
}