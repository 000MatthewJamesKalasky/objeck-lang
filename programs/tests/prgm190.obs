use Collection.Generic;
use System.IO.Filesystem;

class Test {
    @debug : static : Bool;

    function : Main(args : String[]) ~ Nil {
        @debug := true;

        multipart_content := ParseMultipartEncoding(FileReader->ReadBinaryFile("data/mime.dat"));
        if(multipart_content <> Nil) {
            multipart_content_size := multipart_content->Size();
            "===\nParsed {$multipart_content_size} content type(s)."->PrintLine();
        };
    }

    function : ParseMultipartEncoding(encoded : Byte[]) ~ Vector<ContentType> {
        multipart_content := Vector->New()<ContentType>;

        # read encoding string
        marker_bytes := ReadLine(0, encoded);
        if(marker_bytes = Nil) {
            return Nil;
        };

        encoding_size := encoded->Size();
        if(@debug) {
            encoding_size_hex := encoding_size->ToHexString();   
            str_marker := marker_bytes->ToString();
            "size=0x{$encoding_size_hex}({$encoding_size}), marker=|{$str_marker}|"->PrintLine();
        };

        # fetch all markers
        marker_indexes := Byte->FindAll(encoded, marker_bytes);
        if(marker_indexes = Nil) {
            return Nil;
        };

        if(@debug) {
            num_markers := marker_indexes->Size();
            "num_markers={$num_markers}\n==="->PrintLine();
        };

        boundry_index := 0;
        for(i := 0; i < marker_indexes->Size() - 1; i += 1;) {
            boundary_bytes := ReadLine(marker_indexes[i], encoded);
            if(boundary_bytes = Nil) {
                return Nil;
            };
            boundry_index += boundary_bytes->Size();

            # read white space
            if(<>MatchSpace(boundry_index, encoded)) {
                return Nil;
            };
            boundry_index += 2;
 
            # read content headers
            done := false;
            content_headers := Vector->New()<String>;
            do {
                # read content line
                header_bytes := ReadLine(boundry_index, encoded);
                if(header_bytes <> Nil) {            
                    boundry_index += header_bytes->Size();
                    content_str := header_bytes->ToString();
                    if(@debug) {                
                        "header=|{$content_str}|"->PrintLine();
                    };

                    # TODO: parser header names/values
                    content_str_index := content_str->Find(':');
                    if(content_str_index > 0) {
                        name := content_str->SubString(content_str_index);
name->PrintLine();                        
                        content_headers->AddBack(content_str);
                    };
                }
                else {
                    done := true;
                };

                # read white space
                if(<>MatchSpace(boundry_index, encoded)) {
                    return Nil;
                };
                boundry_index += 2;
            }
            while(<>done);
            
            # read content
            content_size := marker_indexes[i + 1] - boundry_index - 2;
            if(@debug) {
                "(Body): start={$boundry_index}, len={$content_size}"->Print();
            };

            content_bytes := Byte->New[content_size];
            if(Runtime->Copy(content_bytes, 0, encoded, boundry_index, content_size)) {
                content_str := String->New(content_bytes);
                ", content: |{$content_str}|"->PrintLine();
            };
            boundry_index += content_bytes->Size();

            # read white space
            if(<>MatchSpace(boundry_index, encoded)) {
                return Nil;
            };
            boundry_index += 2;

            if(@debug) {
                boundry_index_hex := boundry_index->ToHexString();
                "ending content position=0x{$boundry_index_hex}"->PrintLine();
                "---"->PrintLine();
            };

            multipart_content->AddBack(ContentType->New(content_headers, content_bytes));
        };

        boundary_bytes := ReadLine(marker_indexes[marker_indexes->Size() - 1], encoded);
        if(boundary_bytes = Nil) {
            return Nil;
        };
        boundry_index += boundary_bytes->Size();

        boundary_str := boundary_bytes->ToString();
        if(boundary_str->EndsWith("--") & encoding_size = boundry_index) {
            if(@debug) {
                boundry_index_hex := boundry_index->ToHexString();
                "Fin. (multipart ending position=0x{$boundry_index_hex})"->PrintLine();
            };

            return multipart_content;
        };

        return Nil;
    }

    function : ReadLine(offset : Int, encoded : Byte[]) ~ Byte[] {
        i := offset;
        if(i < encoded->Size()) {
            done := false;
            read := 0;
            while(<>done & i < encoded->Size()) {
                byte := encoded[i++];
                if(byte = '\r') {
                    done := true;
                }
                else {
                    read += 1;
                };
            };

            line := Byte->New[read];
            if(Runtime->Copy(line, 0, encoded, offset, read)) {
                return line;
            };
        };

        return Nil;
    }

    function : MatchSpace(offset : Int, encoded : Byte[]) ~ Bool {
        if(offset + 1 < encoded->Size()) {
            return encoded[offset] = '\r' & encoded[offset + 1] = '\n';
        };

        return false;
    }

    function : ParseUrlEncoding(encoded : String) ~ Map<String, String> {
        decodings := Map->New()<String, String>;

        pairs :=  encoded->Split('&');
        if(pairs <> Nil) {
            each(i : pairs) {
                key_value := pairs[i]->Split('=');
                if(key_value <> Nil & key_value->Size() = 2) {
                    marker_bytes := Web.HTTP.Url->Decode(key_value[0])->ReplaceAll('+', ' ');
                    value := Web.HTTP.Url->Decode(key_value[1])->ReplaceAll('+', ' ');
                    decodings->Insert(marker_bytes, value);
                };
            };
        };

        return decodings;
    }
}

class ContentType {
    @content_headers : Vector<String>;
    @content : Byte[];

    New(content_headers : Vector<String>, content : Byte[]) {
        @content_headers := content_headers;
        @content := content;
    }
}