use Collection, System.ML;

class Test {
	function : Main(args : String[]) ~ Nil {
		records := Collection.Vector->New()<FloatArrayRef>;

		records->AddBack(FloatArrayRef->New([0.38615586, 1.214427208]));
		records->AddBack(FloatArrayRef->New([1.718464173, 3.372883202]));
		records->AddBack(FloatArrayRef->New([1.584066635, 9.475994705]));
		records->AddBack(FloatArrayRef->New([7.163115086, 3.790681535]));
		records->AddBack(FloatArrayRef->New([3.442126649, 1.697612421]));
		records->AddBack(FloatArrayRef->New([2.284682944, 1.737259037]));
		records->AddBack(FloatArrayRef->New([4.421239156, 7.947645822]));
		records->AddBack(FloatArrayRef->New([0.412965248, 9.610534599]));
		records->AddBack(FloatArrayRef->New([7.833552317, 7.483994114]));
		records->AddBack(FloatArrayRef->New([1.513004878, 7.382620369]));
		records->AddBack(FloatArrayRef->New([3.607487753, 5.005536167]));
		records->AddBack(FloatArrayRef->New([3.384052126, 3.064628698]));
		records->AddBack(FloatArrayRef->New([2.13966849, 8.265686125]));
		records->AddBack(FloatArrayRef->New([4.996348732, 4.698026935]));
		records->AddBack(FloatArrayRef->New([4.018244149, 4.710124032]));
		records->AddBack(FloatArrayRef->New([2.125462682, 3.958296964]));
		records->AddBack(FloatArrayRef->New([5.51003858, 4.950951249]));
		records->AddBack(FloatArrayRef->New([3.148218579, 5.412938048]));
		records->AddBack(FloatArrayRef->New([5.809705114, 5.95242922]));
		records->AddBack(FloatArrayRef->New([6.690433556, 7.809409341]));
		records->AddBack(FloatArrayRef->New([3.510805088, 0.737320193]));
		records->AddBack(FloatArrayRef->New([3.973897423, 8.047290782]));
		records->AddBack(FloatArrayRef->New([7.377464414, 3.034343973]));
		records->AddBack(FloatArrayRef->New([3.403090072, 6.541184122]));
		records->AddBack(FloatArrayRef->New([7.991916152, 1.474549104]));
		records->AddBack(FloatArrayRef->New([2.927025216, 9.045466629]));
		records->AddBack(FloatArrayRef->New([9.677901811, 3.044481052]));
		records->AddBack(FloatArrayRef->New([2.103293937, 2.446154204]));
		records->AddBack(FloatArrayRef->New([9.340432657, 2.896683906]));
		records->AddBack(FloatArrayRef->New([7.674354483, 4.765027229]));
		records->AddBack(FloatArrayRef->New([8.656404515, 0.481807722]));

		labels := ["group-a","group-b", "group-c"];
		groups := KMeans->Group(labels, records, 2, 0.0, 10.0);
		
		num_groups := groups->Size();
		"number of groups: {$num_groups}\n---"->PrintLine();

		DunnIndex(groups);
	}

	function : private : DunnIndex(groups : Hash<String, Vector<FloatArrayRef>>) ~ Nil {
		group_key_values := groups->GetKeyValues()<Pair<String, Vector<FloatArrayRef>>>;

		max_intra_distance := 0.0;
		each(group_key_value in group_key_values) {
			group := group_key_value->GetSecond();
			group_name := group_key_value->GetFirst();
			
			group_size := group->Size();
			"group: name='{$group_name}', size={$group_size}\n---"->PrintLine();

			each(left_array in group) {			
				each(right_array in group) {
					if(left_array <> right_array) {
						distance := Distance(left_array, right_array);
						if(distance > max_intra_distance) {
							max_intra_distance := distance;
						}
					};
				};
			};
		};
		"max_intra_distance={$max_intra_distance}\n---"->PrintLine();

		min_inter_distance := Float->Inf();
		each(left_key_value in group_key_values) {
			left_group := left_key_value->GetSecond();
			left_group_name := left_key_value->GetFirst();

			each(right_key_value in group_key_values) {
				right_group := right_key_value->GetSecond();
				right_group_name := right_key_value->GetFirst();
				if(<>left_group_name->Equals(right_group_name)) {
					each(left_array in left_group) {
						each(right_array in right_group) {
							distance := Distance(left_array, right_array);
							if(distance < min_inter_distance) {
								min_inter_distance := distance;
							};
						};
					};
				};
			};
		};
		"min_inter_distance={$min_inter_distance}\n---"->PrintLine();

		(min_inter_distance / max_intra_distance)->PrintLine();
	}

	function : private : native : Distance(left : FloatArrayRef, right : FloatArrayRef) ~ Float {
			if(left = Nil | right = Nil) {
				return 0.0;
			};

			left_values := left->Get(); right_values := right->Get();
			if(left_values->Size() <> right_values->Size()) {
				return 0.0;
			};

			distance := 0.0;
	        each(i : left_values) {
	            distance += Float->Pow(left_values[i] - right_values[i], 2.0);
	        };

	        return distance->Sqrt();
		}
}