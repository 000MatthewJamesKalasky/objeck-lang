#~~
Credit: Learner1067, https://medium.com/@nirmal1067/java-k-mean-clustering-with-math-4077a6e2b6c0
~~#

use Collection;

class KMeans {
	@debug : static : Bool;

	function : Main(args : String[]) ~ Nil {
		records := Vector->New()<FloatArrayRef>;

		records->AddBack(FloatArrayRef->New([0.38615586, 1.214427208]));
		records->AddBack(FloatArrayRef->New([1.718464173, 3.372883202]));
		records->AddBack(FloatArrayRef->New([1.584066635, 9.475994705]));
		records->AddBack(FloatArrayRef->New([7.163115086, 3.790681535]));
		records->AddBack(FloatArrayRef->New([3.442126649, 1.697612421]));
		records->AddBack(FloatArrayRef->New([2.284682944, 1.737259037]));
		records->AddBack(FloatArrayRef->New([4.421239156, 7.947645822]));
		records->AddBack(FloatArrayRef->New([0.412965248, 9.610534599]));
		records->AddBack(FloatArrayRef->New([7.833552317, 7.483994114]));
		records->AddBack(FloatArrayRef->New([1.513004878, 7.382620369]));
		records->AddBack(FloatArrayRef->New([3.607487753, 5.005536167]));
		records->AddBack(FloatArrayRef->New([3.384052126, 3.064628698]));
		records->AddBack(FloatArrayRef->New([2.13966849, 8.265686125]));
		records->AddBack(FloatArrayRef->New([4.996348732, 4.698026935]));
		records->AddBack(FloatArrayRef->New([4.018244149, 4.710124032]));
		records->AddBack(FloatArrayRef->New([2.125462682, 3.958296964]));
		records->AddBack(FloatArrayRef->New([5.51003858, 4.950951249]));
		records->AddBack(FloatArrayRef->New([3.148218579, 5.412938048]));
		records->AddBack(FloatArrayRef->New([5.809705114, 5.95242922]));
		records->AddBack(FloatArrayRef->New([6.690433556, 7.809409341]));
		records->AddBack(FloatArrayRef->New([3.510805088, 0.737320193]));
		records->AddBack(FloatArrayRef->New([3.973897423, 8.047290782]));
		records->AddBack(FloatArrayRef->New([7.377464414, 3.034343973]));
		records->AddBack(FloatArrayRef->New([3.403090072, 6.541184122]));
		records->AddBack(FloatArrayRef->New([7.991916152, 1.474549104]));
		records->AddBack(FloatArrayRef->New([2.927025216, 9.045466629]));
		records->AddBack(FloatArrayRef->New([9.677901811, 3.044481052]));
		records->AddBack(FloatArrayRef->New([2.103293937, 2.446154204]));
		records->AddBack(FloatArrayRef->New([9.340432657, 2.896683906]));
		records->AddBack(FloatArrayRef->New([7.674354483, 4.765027229]));
		records->AddBack(FloatArrayRef->New([8.656404515, 0.481807722]));

		group_labels := ["group-a","group-b", "group-c"];

		@debug := false;
		groups := Group(group_labels, records, 2, 0.0, 10.0);
		groups->Size()->PrintLine();
	}

	#~
	K-Means group clustering
	@param group_labels group labels used to tag groups also specify K
	@param records input records
	@param record_length length of records, all records lengths be the same
	@param min_value smallest record value
	@param max_value largest record value
	@return labeled clustered groups
	~#
	function : native : Group(group_labels : String[], records : Vector<FloatArrayRef>, record_length : Int, min_value : Float, max_value : Float) ~ Hash<String, Vector<FloatArrayRef>> {
		# https://www.ibm.com/support/pages/how-does-k-mean-cluster-node-select-initial-records-clustering
		centroids := InitalCentroids(group_labels, records, record_length, min_value, max_value);
		updated_centroids := FloatArrayRef->New[group_labels->Size()];
		
		groups := Hash->New()<String, Vector<FloatArrayRef>>;
		each(centroid_label in group_labels) {
			groups->Insert(centroid_label, Vector->New()<FloatArrayRef>);
		};

		iter := 0;
		has_changed := true;
		while(has_changed) {
			if(@debug) {
				"=== {$iter} ==="->PrintLine();
				iter += 1;
			}

			each(datum in records) {
				shortest_index := -1;
				shortest_distance := Float->Inf();
				
				each(i : centroids) {
					centroid := centroids[i];

					distance := Distance(datum, centroid);
					if(distance <= shortest_distance) {
						shortest_distance := distance;
						shortest_index := i;
					}
				};

				nearest_centroid_label := group_labels[shortest_index];
				group := groups->Find(nearest_centroid_label)<FloatArrayRef>;
				group->AddBack(datum);
			};

			group_key_values := groups->GetKeyValues()<Pair<String, Vector<FloatArrayRef>>>;
			each(i : group_key_values) {
				group_key_value := group_key_values->Get(i);

				group_label := group_key_value->GetFirst();
				group := group_key_value->GetSecond();

				if(@debug) {
					group_size := group->Size();
					"label='{$group_label}', size={$group_size}: {$group}"->PrintLine();
				};

				update := Average(group, record_length);
				if(update <> Nil) {
					updated_centroids[i] := update;
				};
			};

			# update of centroids and rebuilding of buckets
			has_changed := HasChanged(centroids, updated_centroids);
			if(has_changed) {
				centroids := updated_centroids;
				updated_centroids := FloatArrayRef->New[group_labels->Size()];

				each(centroid_label in group_labels) {
					if(groups->Remove(centroid_label)) {
						groups->Insert(centroid_label, Vector->New()<FloatArrayRef>);
					};
				};
			};
		};

		return groups;
	}

	function : native : InitalCentroids(group_labels : String[], records : Vector<FloatArrayRef>, record_length : Int, min_value : Float, max_value : Float) ~ FloatArrayRef[] {
		centroids := FloatArrayRef->New[group_labels->Size()];

		each(i : centroids) {
			random_values := Float->New[record_length];
			each(j : random_values) {
				random_values[j] := Float->Random(min_value + 0.001, max_value - 0.001);
			};
			centroids[i] := FloatArrayRef->New(random_values);
		};

		return centroids;
	}

	function : native : HasChanged(old_centroids : FloatArrayRef[], new_centroids : FloatArrayRef[]) ~ Bool {
		has_changed := false;

		each(i : old_centroids) {
			old_centroid_values := old_centroids[i]->Get();
			new_centroid_values := new_centroids[i]->Get();
			
			each(j : old_centroid_values) {
				old_centroid_value := old_centroid_values[j];
				new_centroid_value := new_centroid_values[j];

				has_changed := Float->Abs(old_centroid_value - new_centroid_value) = 0.0;
				if(<>has_changed) {
					return true;
				}
			};
		};

		return false;
	}

	function : native : Average(group : Vector<FloatArrayRef>, record_length : Int) ~FloatArrayRef {
		if(group->IsEmpty()) {
			return Nil;
		};

		average_values := Float->New[record_length];
		each(i : average_values) {
			sum := 0.0;
			each(array in group) {
				array_values := array->Get();
				sum += array_values[i];
			};
			average := sum / group->Size()->As(Float);
			average_values[i] := average;
		}

		return FloatArrayRef->New(average_values);
	}

	function : native : Distance(left : FloatArrayRef, right : FloatArrayRef) ~ Float {
		if(left = Nil | right = Nil) {
			return 0.0;
		};

		left_values := left->Get(); right_values := right->Get();
		if(left_values->Size() <> right_values->Size()) {
			return 0.0;
		};

		distance := 0.0;
        each(i : left_values) {
            distance += Float->Pow(left_values[i] - right_values[i], 2.0);
        };

        return distance->Sqrt();
	}
}