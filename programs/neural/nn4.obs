use System.IO.File;
use System.Matrix;
use Collection;

class NeuralNetwork {
	@input_nodes : Float;
	@hidden_nodes : Float;
	@output_nodes : Float;
	@learning_rate : Float;
	@weight_inputs_hidden : Float[,];
	@weight_outputs_hidden : Float[,];

	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			lines := ReadLines(args[0]);
			lines := ReadLines(args[0]);
			lines->Size()->PrintLine();
			"---"->PrintLine();

			input_nodes := 784;
			hidden_nodes := 100;
			output_nodes := 10;
			learning_rate := 0.3;

			value := IntHolder->New();
			network := NeuralNetwork->New(input_nodes, hidden_nodes, output_nodes, learning_rate);
			for(i := 0; i < 100; i += 1;) {
				each(i : lines) {
					input := GetInput(lines->Get(i)->As(String), value);
					number := value->Get(); 

					"value: {$number}"->PrintLine();
					target := GetTarget(number);
					target->ToString()->PrintLine();
					"---"->PrintLine();

					network->Train(input, target, learning_rate);
				};
			};

#~
			in : Float[,]; # CHANGE ME
			out := network->Query(in);
			out->ToString()->Print();
~#
	 	};
	}
	
	New(input_nodes : Float, hidden_nodes : Float, output_nodes : Float, learning_rate : Float) {
		@input_nodes  := input_nodes;
		@hidden_nodes  := hidden_nodes;
		@output_nodes  := output_nodes;
		@learning_rate := learning_rate;

		@weight_inputs_hidden := Matrix2D->RandomNormal(0.01, Float->Power(@input_nodes, -0.5), 
			@hidden_nodes, @input_nodes);
		@weight_outputs_hidden := Matrix2D->RandomNormal(0.01, Float->Power(@input_nodes, -0.5), 
			@output_nodes, @input_nodes);
	}

	method : Query(inputs : Float[,]) ~ Float[,] {
		# calculate signals into hidden layer
		hidden_outputs := Matrix2D->DotSigmoid(@weight_inputs_hidden, inputs);
		# calculate the signals emerging from final output layer
		return Matrix2D->DotSigmoid(@weight_outputs_hidden, hidden_outputs);
	}

	method : Train(inputs : Float[,], targets : Float[,], rate : Float) ~ Nil {
DebugMeta(@weight_inputs_hidden, inputs);
		# calculate signals into hidden layer
        hidden_outputs := Matrix2D->DotSigmoid(@weight_inputs_hidden, inputs);
        # calculate signals into final output layer
        final_outputs  := Matrix2D->DotSigmoid(@weight_outputs_hidden, hidden_outputs);
        # output layer error is the (target - actual)
        output_errors := Matrix2D->Subtract(targets, final_outputs);
        # hidden layer error is the output_errors, split by weights, recombined at hidden nodes
		hidden_errors := Matrix2D->Dot(Matrix2D->Transpose(@weight_outputs_hidden), output_errors);
		# update the weights for the links between the input and hidden layers
		@weight_inputs_hidden := Matrix2D->Add(@weight_inputs_hidden, Adjust(rate, hidden_errors, hidden_outputs, inputs));
		# update the weights for the links between the hidden and output layers
		@weight_outputs_hidden := Matrix2D->Add(@weight_outputs_hidden, Adjust(rate, output_errors, final_outputs, hidden_outputs));		
	}

	method : Adjust(rate : Float, errors : Float[,], outputs : Float[,], inputs : Float[,]) ~ Float[,] {
		return Matrix2D->Multiple(rate, Matrix2D->Dot(Matrix2D->Multiple(errors, Matrix2D->Multiple(outputs, Matrix2D->Subtract(0.99, outputs))), Matrix2D->Transpose(inputs)));
	}

	# ---

	function : DebugMeta(a : Float[,], b : Float[,]) ~ Nil {
		a_dims := a->Size();
		a_rows := a_dims[0];
		a_cols := a_dims[1];

		b_dims := b->Size();
		b_rows := b_dims[0];
		b_cols := b_dims[1];

		"A: [{$a_rows},{$a_cols}]; B: [{$b_rows},{$b_cols}]"->PrintLine();
	}

	function : GetTarget(number : Int) ~ Float[,] {
		if(number < 0 | number > 9) {
			return Nil;
		};

		targets := Float->New[1, 10];
		for(j := 0; j < 10; j += 1;) {
			targets[0, j] := 0.1;
		};

		targets[0, number] := 0.99;

		return targets;
	}

	function : GetInput(line : String, value : IntHolder) ~ Float[,] {
		matrix := Float->New[28, 28];

		row := -1; col := 0;
		values := line->Split(",");

		index := values[0];
		value->Set(index->ToInt());

		for(i := 1; i < values->Size(); i += 1;) {
			col := (i - 1) % 28;
			if(col = 0) {
				row += 1;
			};
			matrix[row, col] := values[i]->ToFloat() / 255.0 * 0.99 + 0.01;
		};

		return matrix;
	}

	function : ReadLines(file : String) ~ Vector {
		lines := Vector->New();

		reader := FileReader->New(file);
		leaving {
			reader->Close();
		};

		buffer_size := 4096;
		buffer := Char->New[buffer_size + 1];

		line := "";
		while(<>reader->IsEOF()) {
			read := reader->ReadBuffer(0, buffer_size, buffer);
			for(i := 0; i < read; i += 1;) {
				if(buffer[i] = '\n') {
					lines->AddBack(line);
					line := "";
				}
				else if(buffer[i] <> '\r') {
					line += buffer[i];
				};
			};
		};

		return lines;
	}
}