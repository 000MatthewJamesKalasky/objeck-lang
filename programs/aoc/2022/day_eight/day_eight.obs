class AoC {
	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			inputs := ReadInput(args[0])<String>;
			if(<>inputs->IsEmpty()) {
				row := inputs->Get(0);
				if(row->Size() = inputs->Size()) {
					size := inputs->Size();
					"matrix: {$size}x{$size}"->PrintLine();
					"---"->PrintLine();

					forest := Int->New[size, size];
					each(i : size) {
						row := inputs->Get(i);
						each(j : row) {
							forest[i,j] := row->Get(j) - '0';
						};
					};

					count += ViewableExternalEdges(forest);
					count += ViewableExternal(forest);
					count->PrintLine();
					return;
				};
			};
		};

		">>> Unable to load matrix <<<"->PrintLine();
	}

	function : ViewableExternal(forest : Int[,]) ~ Int {
		dims := forest->Size();
		x := dims[0]; y := dims[1];
		
		count := 0;

		each(i : x) {
			each(j : y) {
				if(i > 0 & j > 0 & i < x - 1 & j < y - 1) {
#					"{$i},{$j}"->PrintLine();
					
					found := false;

					# up
					if(<>found) {
						found := ViewableExternalUp(i, j, forest);
						if(found) {
							start := forest[i, j];
							"{$start} is viewable up at {$i},{$j}"->PrintLine();
							count += 1;
						};
					};

					# down
					if(<>found) {
						found := ViewableExternalDown(i, j, forest);
						if(found) {
							start := forest[i, j];
							"{$start} is viewable down at {$i},{$j}"->PrintLine();
							count += 1;
						};
					};

					# left
					if(<>found) {
						found := ViewableExternalLeft(i, j, forest);
						if(found) {
							start := forest[i, j];
							"{$start} is viewable left at {$i},{$j}"->PrintLine();
							count += 1;
						};
					};

					# right
					if(<>found) {
						found := ViewableExternalRight(i, j, forest);
						if(found) {
							start := forest[i, j];
							"{$start} is viewable right at {$i},{$j}"->PrintLine();
							count += 1;
						};
					};
				};
			};
			
		};

		return count;
	}

	function : ViewableExternalUp(i : Int, j : Int, forest : Int[,]) ~ Bool {
		values := Collection.Generic.CompareVector->New()<IntHolder>; # TODO

		temp := i;
		while(temp <> -1) {
# System.IO.Standard->Print(forest[temp,j])->Print(',');
			values->AddBack(forest[temp,j]); # TODO

			temp -= 1;
		};

		# TODO
		check := values->Get(0)->Get();
		for(k := 1; k < values->Size(); k += 1;) {
			cur := values->Get(k)->Get();
			if(cur >= check) {
				return false;
			};
		};

		return true;
	}

	function : ViewableExternalDown(i : Int, j : Int, forest : Int[,]) ~ Bool {
		dims := forest->Size();
		x := dims[0];

		values := Collection.Generic.CompareVector->New()<IntHolder>; # TODO
		temp := i;
		while(temp <> x) {
# System.IO.Standard->Print(forest[temp,j])->Print(',');
			values->AddBack(forest[temp,j]); # TODO

			temp += 1;
		};

		# TODO
		check := values->Get(0)->Get();
		for(k := 1; k < values->Size(); k += 1;) {
			cur := values->Get(k)->Get();
			if(cur >= check) {
				return false;
			};
		};

		return true;
	}

	function : ViewableExternalLeft(i : Int, j : Int, forest : Int[,]) ~ Bool {
		values := Collection.Generic.CompareVector->New()<IntHolder>; # TODO

		temp := i;
		while(temp <> -1) {
# System.IO.Standard->Print(forest[j, temp])->Print(',');
			values->AddBack(forest[j, temp]); # TODO
			
			temp -= 1;
		};		

		# TODO
		check := values->Get(0)->Get();
		for(k := 1; k < values->Size(); k += 1;) {
			cur := values->Get(k)->Get();
			if(cur >= check) {
				return false;
			};
		};

		return true;
	}

	function : ViewableExternalRight(i : Int, j : Int, forest : Int[,]) ~ Bool {
		dims := forest->Size();
		x := dims[0];

		values := Collection.Generic.CompareVector->New()<IntHolder>; # TODO

		temp := i;
		while(temp <> x) {
			values->AddBack(forest[j, temp]); # TODO
			temp += 1;
		};

		# TODO
		check := values->Get(0)->Get();
		for(k := 1; k < values->Size(); k += 1;) {
			cur := values->Get(k)->Get();
			if(cur >= check) {
				return false;
			};
		};

		return true;
	}

	function : ViewableExternalEdges(forest : Int[,]) ~ Int {
		dims := forest->Size();
		x := dims[0]; y := dims[1];

		count := 0;
		each(i : x) {
			each(j : y) {
				if(i = 0 | j = 0) {
					count += 1;
				}
				else if(i = x - 1 | j = y - 1) {
					count += 1;
				};
			};
		};

		return count;
	}

	function : ReadInput(file : String) ~ Collection.Generic.Vector<String> {
		inputs := Collection.Generic.Vector->New()<String>;

		reader := System.IO.Filesystem.FileReader->New(file);
		leaving {
			reader->Close();
		};

		line := reader->ReadLine();
		while(line <> Nil) {
			if(<>line->IsEmpty()) {
				inputs->AddBack(line);
			};
			line := reader->ReadLine();
		};

		return inputs;
	}
}